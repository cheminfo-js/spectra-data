{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///spectra-data.min.js","webpack:///webpack/bootstrap 4c5ea95b289e8d8306b7","webpack:///./src/index.js","webpack:///./src/SD.js","webpack:///./~/ml-stat/array.js","webpack:///./~/jcampconverter/src/index.js","webpack:///./src/NMR.js","webpack:///./src/PeakPicking.js","webpack:///./src/JAnalyzer.js","webpack:///./~/curve-fitting/src/index.js","webpack:///./~/curve-fitting/src/LM.js","webpack:///./~/curve-fitting/~/ml-matrix/src/index.js","webpack:///./~/curve-fitting/~/ml-matrix/src/matrix.js","webpack:///./~/curve-fitting/~/ml-matrix/src/decompositions.js","webpack:///./~/curve-fitting/~/ml-matrix/src/dc/svd.js","webpack:///./~/curve-fitting/~/ml-matrix/src/dc/util.js","webpack:///./~/curve-fitting/~/ml-matrix/src/dc/evd.js","webpack:///./~/curve-fitting/~/ml-matrix/src/dc/lu.js","webpack:///./~/curve-fitting/~/ml-matrix/src/dc/qr.js","webpack:///./~/curve-fitting/~/ml-matrix/src/dc/cholesky.js","webpack:///./~/curve-fitting/src/algebra.js","webpack:///./src/NMR2D.js","webpack:///./src/PeakPicking2D.js","webpack:///./src/FFTUtils.js","webpack:///./src/fftlib.js","webpack:///./src/PeakOptimizer.js","webpack:///./src/SimpleClustering.js","webpack:///./src/AcsParser.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","SD","NMR","NMR2D","ACS","JAnalyzer","sd","activeElement","DATACLASS_XY","DATACLASS_PEAK","TYPE_NMR_SPECTRUM","TYPE_NMR_FID","TYPE_IR","TYPE_RAMAN","TYPE_UV","TYPE_MASS","TYPE_HPLC","TYPE_GC","TYPE_CD","TYPE_2DNMR_SPECTRUM","TYPE_2DNMR_FID","TYPE_XY_DEC","TYPE_XY_INC","TYPE_IV","StatArray","JcampConverter","fromJcamp","jcamp","options","xy","spectrum","convert","prototype","setActiveElement","nactiveSpectrum","getActiveElement","getXUnits","getSpectrum","xUnit","getYUnits","yUnit","getNbPoints","i","getSpectrumData","y","length","getFirstX","spectra","firstX","getLastX","lastX","getFirstY","firstY","getLastY","lastY","setDataClass","dataClass","isPeaktable","isXYdata","isDataClassPeak","isDataClassXY","setDataType","dataType","getDataType","data","getNbSubSpectra","getXData","x","getYData","getX","getY","getXYData","getTitle","title","setTitle","newTitle","getMinY","min","getMaxY","max","getMinMaxY","minMax","getNoiseLevel","mean","stddev","averageDeviations","Array","Math","abs","sort","getNMRPeakThreshold","getNucleus","arrayPointToUnits","doublePoint","unitsToArrayPoint","inValue","round","getDeltaX","midPoint","currentArrayPoint","upperLimit","lowerLimit","floor","setMinMax","factor","setMin","currentMin","setMax","YShift","value","shift","globalShift","fillWith","from","to","tmp","start","end","suppressZone","splice","simplePeakPicking","parameters","getMaxPeak","getSpectraDataY","index","getSpectraDataX","getParamDouble","name","defvalue","info","getParamString","getParamInt","getSpectrumDataY","putParam","getArea","i0","ie","area","getVector","nPoints","direction","reversed","winPoints","xwin","ywin","is2D","values","Infinity","l","sum","geometricMean","pow","logGeometricMean","lnsum","log","grandMean","means","samples","n","truncatedMean","percent","inPlace","slice","k","contraHarmonicMean","order","r1","r2","standardDeviation","unbiased","sqrt","variance","standardError","median","alreadySorted","half","quartiles","quart","q1","ceil","q2","q3","theMean","theVariance","pooledStandardDeviation","pooledVariance","vari","mode","itemCount","itemArray","count","indexOf","maxValue","maxIndex","covariance","vector1","vector2","mean1","mean2","cov","skewness","s2","s3","dev","m2","m3","g","a","b","kurtosis","s4","m4","v","entropy","eps","weightedMean","weights","weightedStandardDeviation","weightedVariance","z","w","center","result","standardize","standardDev","cumulativeSum","array","getConverter","convertToFloatArray","stringArray","floatArray","parseFloat","keepRecordsRegExp","ldr","dataLabel","dataValue","ldrs","ii","position","endLine","infos","Date","ntuples","profiling","logs","push","action","time","split","replace","substring","trim","toUpperCase","xIndex","yIndex","firstVariable","secondVariable","symbol","first","last","vardim","nbPoints","xFactor","yFactor","units","datatable","deltaX","twoD","observeFrequency","xType","indirectFrequency","shiftOffsetNum","shiftOffsetVal","varname","vartype","varform","yType","page","pageValue","pageSymbol","pageSymbolIndex","unit","prepareSpectrum","match","parseXYData","parsePeakTable","isMSField","convertMSFieldToLabel","Object","keys","newNtuples","key","j","add2D","keepSpectra","toLowerCase","addGCMS","newData","GC_MS_FIELDS","existingGCMSFields","label","gcms","gc","ms","jj","currentData","lines","removeCommentRegExp","peakTableSplitRegExp","lastDif","ascii","currentX","currentY","xyDataSplitRegExp","DEBUG","firstPoint","expectedCurrentX","charCodeAt","String","fromCharCode","dup","convertTo3DZ","noise","minZ","maxZ","ySize","xSize","minX","maxX","minY","maxY","zData","contourLines","generateContourLines","pAx","pAy","pBx","pBy","lineZValue","contourLevels","nbLevels","povarHeight","Float32Array","isOver","nbSubSpectra","nbPovars","x0","xN","dx","y0","yN","dy","level","contourLevel","side","exp","zValue","iSubSpectra","povar","segments","input","useWorker","postToWorker","worker","createWorker","Promise","resolve","stamp","now","random","stamps","postMessage","workerURL","URL","createObjectURL","Blob","toString","type","Worker","revokeObjectURL","addEventListener","event","output","PeakPicking","create","constructor","dim","getSolventName","observeFrequencyX","nucleus","addNoise","SNR","addSpectraDatas","spec2","factor1","factor2","autoscale","autoBaseline","fourierTransform","postFourierTransform","ph1corr","zeroFilling","nPointsX","nPointsY","haarWhittakerBaselineCorrection","waveletScale","whittakerLambda","whittakerBaselineCorrection","ranges","brukerSpectra","apodization","functionName","lineBroadening","echoAntiechoFilter","SNVFilter","powerFilter","power","console","warn","logarithmFilter","base","correlationFilter","func","phaseCorrection","phi0","phi1","automaticPhase","useBrukerPhase","nmrPeakDetection","peakPicking","toJcamp","LM","Matrix","math","algebra","impurities","maxJ","nH","clean","realTop","thresholdFactor","compile","integral","nHi","noiseLevel","peakList","GSD","optmizeSpectrum","signals","detectSignals","integralData","compilePattern","maskPattern","multiplicity","peaksO","peaks","peakR","intensity","width","peaksComp","nbPeaks","peaks1","newSignals","updateIntegrals","delta1","group","groups","nL","limits","optmimalPeaks","fitSpectrum","sampling","lm_func","t","p2","cols","rows","y_data","weight","dot","opts","consts","p_init","p_min","p_max","p_fit","optimize","rowWise","ic","more","updateLimits","signal","nbPeaks0","toRemove","sumIntegral","sumObserved","realTopDetection","alpha","beta","gamma","currentPoint","log10","init","shifts","proton","coupling","solvent","integralType","cs","frequency","signal1D","prevPeak","rangeX","spectrumIntegral","startX","stopX","pattern","observe","peak","labelPeaks","column","nImpurities","nPeaks","scores","diff","score","impurityID","prevImp","maxIntensity","prevIndex","candidates","impuritiesPeaks","updateScore","mul","indexMin","thisJ1","thisJ2","thisJ3","thisJ4","createSignals","frequencyX","X","Y","dY","ddY","stackInt","intervals","minddY","maxDdy","broadMask","pop","e","broadLines","Number","MAX_VALUE","f","possible","inter","linewidth","height","maxI","isPartOf","fitted","optimizeLorentzian","columns","pascalTriangle","patterns","symRatio","maxErrorIter1","maxErrorIter2","symRank","symmetrizeChoiseBest","asymmetric","P1","n2","maxFlagged","Jc","normalize","validPattern","getRanges","JSON","stringify","heights","getNextCombination","numbering","nFlagged","u","jSum","idealPattern","updateSignal","mask2","abstractPattern","tol","cont","newNmrJs","nmrJs","hsum","lng","ok","currentIndex","active","maxError","iteration","symRank1","symmetrize","tmpPeaks","tmpMask","mask","symRank2","avg","ratio","avgWidth","left","right","middle","error","heightSum","diffL","diffR","chemicalShift","isNaN","symFactor","newSumHeights","dxi","parse","norm","norm2","y_dat","dp","tensor_parameter","Npar","Npnt","p_old","zeros","y_old","X2","X2_old","J","length_t","length_y_dat","multiply","transpose","prnt","MaxIter","epsilon_1","epsilon_4","lambda_0","lambda_UP_fac","lambda_DN_fac","Update_Type","dp_array","idx","Nfit","stop","weight_sq","ones","dotMultiply","lm_matx","JtWJ","JtWdy","Chi_sq","y_hat","lambda","diag","nu","h","solve","add","eye","hidx","p_try","delta_y","subtract","X2_try","JtWdy_th","inv","mat","rho","dX2","apply","lm_FD_J","ps","clone","del","y1","dotDivide","lm_Broyden_J","h_t","div","Jt","Decompositions","DC","arr","nRows","nColumns","matrix","newInstance","isArray","TypeError","RangeError","defineProperty","writable","__proto__","Asplice","Aconcat","concat","from1DArray","newRows","newColumns","rowVector","columnVector","vector","empty","fill","rand","indices","stack","arg1","isMatrix","arguments","r","current","setRow","expand","expansion","checkMatrix","klass","get","checkRowIndex","checkColumnIndex","checkDimensions","otherMatrix","callback","to2DArray","to1DArray","copy","isRowVector","isColumnVector","isVector","isSquare","isSymmetric","set","rowIndex","columnIndex","neg","mulS","addS","addM","sub","subS","subM","mulM","divS","divM","getRow","getRowVector","removeRow","addRow","swapRows","row1","row2","temp","getColumn","getColumnVector","setColumn","removeColumn","addColumn","swapColumns","column1","column2","row","checkRowVector","checkColumnVector","addRowVector","subRowVector","mulRowVector","divRowVector","addColumnVector","subColumnVector","mulColumnVector","divColumnVector","mulRow","mulColumn","minIndex","maxRow","maxRowIndex","minRow","minRowIndex","maxColumn","maxColumnIndex","minColumn","minColumnIndex","size","prod","other","mmul","Bcolj","Arowi","s","sortRows","compareFunction","sortColumns","subMatrix","startRow","endRow","startColumn","endColumn","newMatrix","subMatrixRow","subMatrixColumn","trace","inverse","leftHandSide","rightHandSide","LuDecomposition","QrDecomposition","SingularValueDecomposition","EigenvalueDecomposition","CholeskyDecomposition","SVD","EVD","LU","QR","CHO","wantu","wantv","computeLeftSingularVectors","computeRightSingularVectors","autoTranspose","swapped","aux","ks","sn","kase","scale","sp","spm1","epm1","sk","ek","U","V","work","nct","nrt","hypotenuse","pp","iter",{"end":{"file":"spectra-data.min.js","comments_before":[],"nlb":false,"endpos":255323,"endcol":18,"endline":6236,"pos":255314,"col":9,"line":6236,"value":"condition","type":"name","_comments_dumped":true},"start":{"file":"spectra-data.min.js","comments_before":[],"nlb":false,"endpos":255323,"endcol":18,"endline":6236,"pos":255314,"col":9,"line":6236,"value":"condition","type":"name","_comments_dumped":true},"name":"condition"},"condition","rank","diagonal","threshold","leftSingularVectors","rightSingularVectors","diagonalMatrix","scols","Ls","VL","vrows","urows","VLU","solveForDiagonal","vcols","ucols","Error","d","tred2","tql2","H","ort","orthes","hqr2","hh","dl1","c2","c3","el1","tst1","low","high","nn","ra","sa","vr","vi","notlast","cdivres","exshift","q","cdiv","xr","xi","yr","yi","realEigenvalues","imaginaryEigenvalues","eigenvectorMatrix","LUrowi","LUcolj","kmax","lu","pivotVector","pivotSign","isSingular","col","determinant","lowerTriangularFactor","upperTriangularFactor","pivotPermutationVector","qr","rdiag","nrm","Rdiag","isFullRank","orthogonalFactor","dimension","positiveDefinite","Lrowj","Lrowk","L","leftTriangularFactor","B","A","dotPow","PeakPicking2D","isHomoNuclear","observeFrequencyY","getZUnits","getDeltaY","nmrPeakDetection2D","findPeaks2D","_highlight","FFTUtils","PeakOptimizer","SimpleClustering","smallFilter","getLoGnStdDevNMR","spectraData","isHomonuclear","iCol","nStdDev","convolutedSpectrum","convoluteWithLoG","peaksMC1","findPeaks2DLoG","peaksMax1","findPeaks2DMax","enhanceSymmetry","createSignals2D","inputSpectrum","nCols","ftSpectrum","fft2DArray","ftFilterData","iRow","ir","ftRows","ftCols","convolute2DI","ifft2DArray","bitmask","nbDetectedPoints","iStart","extractArea","rowI","colI","peakListMax","tmpIndex","peakPoints","scanBitmask","nValues","xAverage","yAverage","zSum","NEGATIVE_INFINITY","pt","minmax","newPeak","tolerance","bf1","bf2","connectivity","clusters","fullClusterGenerator","iCluster","nucleusX","nucleusY","resolutionX","resolutionY","peaks2D","shiftX","shiftY","sumZ","jPeak","FFT","ft","tempTransform","tmpCols","re","im","bt","finalTransform","tmpRows","indexB","iRow0","iRow1","iRow2","iRow3","fft1d","reconstructTwoRealFFT","realTransform1","realTransform2","rm","rp","ip","ftSignal","ftFilter","version","release","date","_n","_bitrev","_cstb","core","_initArray","_makeBitReversalTable","_makeCosSinTable","fft","ifft1d","bt1d","fft2d","tre","tim","x1","x2","y2","ifft2d","ik","wr","wi","n4","Uint32Array","Float64Array","_paddingZero","n8","n2p4","sin","PI","dc","ds","apis","ifft","diagonalError","toleranceX","toleranceY","properties","initializeProperties","hits","exist","checkCrossPeaks","completeMissingIfNeeded","toReturn","thisSignal","thisProp","addedPeaks","newSignal","tmpProp","diagX","diagY","updateProperties","cross","crossPeaksX","crossPeaksY","symmetricSearch","distanceTo","signalsProperties","toImage","conn","clusterList","available","remaining","cluster","nextAv","toInclude","formater","fromNMRSignal1D2ACS","acsString","parenthesis","spectro","undefined","rangeForMultiplet","formatAcs_default","ascending","decimalValue","decimalJ","appendSeparator","appendSpectroInformation","numberSmartPeakLabels","appendDelta","appendParenthesis","formatNucleus","toFixed","formatMF","line","nbDecimal","appendMultiplicity","appendIntegration","appendCoupling","appendAssignment","pubIntegration","appendParenthesisSeparator","pubAssignment","formatAssignment","assignment","pubMultiplicity","mf","fromACS2NMRSignal1D","SDAPI","AcsParserAsJSONString","toACS","toNMRSignal"],"mappings":"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","file":"spectra-data.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"spectraData\"] = factory();\n\telse\n\t\troot[\"spectraData\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"spectraData\"] = factory();\n\telse\n\t\troot[\"spectraData\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\texports.SD = __webpack_require__(1);\n\texports.NMR = __webpack_require__(4);\n\texports.NMR2D = __webpack_require__(19);\n\texports.ACS = __webpack_require__(25);\n\texports.JAnalyzer = __webpack_require__(6);\n\t//exports.SD2 = require('/SD2');\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// small note on the best way to define array\n\t// http://jsperf.com/lp-array-and-loops/2\n\t\n\tvar StatArray = __webpack_require__(2);\n\tvar JcampConverter=__webpack_require__(3);\n\t\n\tfunction SD(sd) {\n\t    this.sd=sd;\n\t    this.activeElement=0;\n\t\n\t    this.DATACLASS_XY = 1;\n\t    this.DATACLASS_PEAK = 2;\n\t\n\t    this.TYPE_NMR_SPECTRUM = 'NMR Spectrum';\n\t    this.TYPE_NMR_FID = 'NMR FID';\n\t    this.TYPE_IR = 'IR';\n\t    this.TYPE_RAMAN = 'RAMAN';\n\t    this.TYPE_UV = 'UV';\n\t    this.TYPE_MASS = 'MASS';\n\t    this.TYPE_HPLC = 'HPLC';\n\t    this.TYPE_GC = 'GC';\n\t    this.TYPE_CD = 'CD';\n\t    this.TYPE_2DNMR_SPECTRUM = 'nD NMR SPECTRUM';\n\t    this.TYPE_2DNMR_FID = 'nD NMR FID';\n\t    this.TYPE_XY_DEC = 'XY DEC';\n\t    this.TYPE_XY_INC= 'XY INC';\n\t    this.TYPE_IV = 'IV';\n\t}\n\t\n\tSD.fromJcamp = function(jcamp, options) {\n\t    options = options ||{};\n\t    if(typeof options.xy ===\"undefined\")\n\t        options.xy=true;\n\t\n\t    var spectrum= JcampConverter.convert(jcamp,options);\n\t    return new SD(spectrum);\n\t}\n\t\n\t\n\t/**\n\t * @function setActiveElement(nactiveSpectrum);\n\t * This function sets the nactiveSpectrum sub-spectrum as active\n\t * \n\t */\n\tSD.prototype.setActiveElement = function(nactiveSpectrum){\n\t    this.activeElement=nactiveSpectrum;\n\t}\n\t\n\t/**\n\t * @function getActiveElement();\n\t * This function returns the index of the active sub-spectrum.\n\t */\n\tSD.prototype.getActiveElement = function(){\n\t    return this.activeElement;\n\t}\n\t/**\n\t * This function returns the units of the independent dimension.\n\t * @returns {xUnit|*|M.xUnit}\n\t */\n\tSD.prototype.getXUnits = function(){\n\t    return this.getSpectrum().xUnit;\n\t}\n\t\n\t/**\n\t * * This function returns the units of the dependent variable.\n\t * @returns {yUnit|*|M.yUnit}\n\t */\n\tSD.prototype.getYUnits = function(){\n\t    return this.getSpectrum().yUnit;\n\t}\n\t\n\t/**\n\t*   Returns the number of points in the current spectrum\n\t*/\n\tSD.prototype.getNbPoints=function(i){\n\t    return this.getSpectrumData(i).y.length;\n\t}\n\t\n\t/**\n\t * Return the first value of the direct dimension\n\t */\n\tSD.prototype.getFirstX=function(i) {\n\t    i=i||this.activeElement;\n\t    return this.sd.spectra[i].firstX;\n\t}\n\t\n\t/**\n\t * Return the last value of the direct dimension\n\t */\n\tSD.prototype.getLastX=function(i) {\n\t    i=i||this.activeElement;\n\t    return this.sd.spectra[i].lastX;\n\t}\n\t\n\t/**\n\t * Return the first value of the direct dimension\n\t */\n\tSD.prototype.getFirstY=function(i) {\n\t    i=i||this.activeElement;\n\t    return this.sd.spectra[i].firstY;\n\t}\n\t\n\t/**\n\t * Return the first value of the direct dimension\n\t */\n\tSD.prototype.getLastY = function(i){\n\t    i=i||this.activeElement;\n\t    return this.sd.spectra[i].lastY;\n\t}\n\t\n\tSD.prototype.setDataClass = function(dataClass){\n\t    if(dataClass==this.DATACLASS_PEAK) {\n\t        this.getSpectrum().isPeaktable = true;\n\t        this.getSpectrum().isXYdata = false;\n\t    }\n\t    if(dataClass==this.DATACLASS_XY){\n\t        this.getSpectrum().isXYdata = true;\n\t        this.getSpectrum().isPeaktable = false;\n\t    }\n\t}\n\t\n\t/**\n\t * @function isDataClassPeak();\n\t * Is this a PEAKTABLE spectrum?\n\t */\n\tSD.prototype.isDataClassPeak = function(){\n\t    if(this.getSpectrum().isPeaktable)\n\t        return  this.getSpectrum().isPeaktable;\n\t    return false;\n\t}\n\t\n\t/**\n\t * @function isDataClassXY();\n\t * Is this a XY spectrum?\n\t */\n\tSD.prototype.isDataClassXY = function(){\n\t    if(this.getSpectrum().isXYdata)\n\t        return  this.getSpectrum().isXYdata;\n\t    return false\n\t}\n\t\n\tSD.prototype.setDataType = function(dataType){\n\t    this.getSpectrum().dataType=dataType;\n\t}\n\t\n\tSD.prototype.getDataType = function(){\n\t    return this.getSpectrum().dataType;\n\t}\n\t\n\t/**\n\t* Return the i-th sub-spectra in the current spectrum\n\t*/\n\tSD.prototype.getSpectrumData=function(i) {\n\t    i=i||this.activeElement;\n\t    return this.sd.spectra[i].data[0];\n\t}\n\t\n\t/**\n\t * Return the i-th sub-spectra in the current spectrum\n\t */\n\tSD.prototype.getSpectrum=function(i) {\n\t    i=i||this.activeElement;\n\t    return this.sd.spectra[i];\n\t}\n\t\n\t/**\n\t * Returns the number of sub-spectra in this object\n\t */\n\tSD.prototype.getNbSubSpectra=function(){\n\t    return this.sd.spectra.length;\n\t}\n\t\n\t\n\t/**\n\t *   Returns an array containing the x values of the spectrum\n\t */\n\tSD.prototype.getXData=function(i){\n\t    return this.getSpectrumData(i).x;\n\t}\n\t\n\t/**\n\t * @function getYData();\n\t * This function returns a double array containing the values of the intensity for the current sub-spectrum.\n\t */\n\tSD.prototype.getYData=function(i){\n\t    return this.getSpectrumData(i).y;\n\t}\n\t\n\tSD.prototype.getX=function(i){\n\t    return this.getXData()[i];\n\t}\n\t\n\tSD.prototype.getY=function(i){\n\t    return this.getYData()[i];\n\t}\n\t\n\t/**\n\t * @function getXYData();\n\t * To get a 2 dimensional array with the x and y of this spectraData( Only for 1D spectra).\n\t * Returns a double[2][nbPoints] where the first row contains the x values and the second row the y values.\n\t */\n\tSD.prototype.getXYData=function(i){\n\t    return [this.getXData(i),this.getYData(i)];\n\t}\n\t\n\tSD.prototype.getTitle=function(i) {\n\t    return this.getSpectrum(i).title;\n\t}\n\t\n\t/**\n\t * @function setTitle(newTitle);\n\t * To set the title of this spectraData.\n\t * @param newTitle The new title\n\t */\n\tSD.prototype.setTitle=function(newTitle,i) {\n\t    this.getSpectrum(i).title=newTitle;\n\t}\n\t\n\t/**\n\t * @function getMinY(i)\n\t * This function returns the minimal value of Y\n\t */\n\tSD.prototype.getMinY=function(i) {\n\t    return  StatArray.min(this.getYData(i));\n\t}\n\t\n\t/**\n\t * @function getMaxY(i)\n\t * This function returns the maximal value of Y\n\t */\n\tSD.prototype.getMaxY=function(i) {\n\t    return  StatArray.max(this.getYData(i));\n\t}\n\t\n\t/**\n\t * @function getMinMax(i)\n\t */\n\tSD.prototype.getMinMaxY=function(i) {\n\t    return  StatArray.minMax(this.getYData(i));\n\t}\n\t\n\t\n\t/**\n\t* Get the noise threshold level of the current spectrum. It uses median instead of the mean\n\t*/\n\tSD.prototype.getNoiseLevel=function(){\n\t    var mean = 0,stddev=0;\n\t    var y = this.getYData();\n\t    var length = this.getNbPoints(),i=0;\n\t    for(i = 0; i < length; i++){\n\t        mean+=y[i];\n\t    }\n\t    mean/=this.getNbPoints();\n\t    var averageDeviations = new Array(length);\n\t    for (i = 0; i < length; i++)\n\t        averageDeviations[i] = Math.abs(y[i] - mean);\n\t    averageDeviations.sort();\n\t    if (length % 2 == 1) {\n\t        stddev = averageDeviations[(length-1)/2] / 0.6745;\n\t    } else {\n\t        stddev = 0.5*(averageDeviations[length/2]+averageDeviations[length/2-1]) / 0.6745;\n\t    }\n\t\n\t    return stddev*this.getNMRPeakThreshold(this.getNucleus(1));\n\t}\n\t\n\t\n\t/**\n\t* Return the xValue for the given index\n\t*/\n\tSD.prototype.arrayPointToUnits=function(doublePoint){\n\t    return (this.getFirstX() - (doublePoint* (this.getFirstX() - this.getLastX()) / (this.getNbPoints()-1)));\n\t}\n\t\n\t/**\n\t * Returns the index-value for the data array corresponding to a X-value in\n\t * units for the element of spectraData to which it is linked (spectraNb).\n\t * This method makes use of spectraData.getFirstX(), spectraData.getLastX()\n\t * and spectraData.getNbPoints() to derive the return value if it of data class XY\n\t * It performs a binary search if the spectrum is a peak table\n\t *\n\t * @param inValue\n\t *            (value in Units to be converted)\n\t * @return an integer representing the index value of the inValue\n\t */\n\tSD.prototype.unitsToArrayPoint=function(inValue){\n\t    if (this.isDataClassXY()) {\n\t        return Math.round((this.getFirstX() - inValue) * (-1.0 / this.getDeltaX()));\n\t    } else if (this.isDataClassPeak())\n\t    {\n\t        var currentArrayPoint = 0,upperLimit=this.getNbPoints()-1, lowerLimit=0, midPoint;\n\t        //If inverted scale\n\t        if(this.getFirstX()>this.getLastX()){\n\t            upperLimit=0;\n\t            lowerLimit=this.getNbPoints()-1;\n\t\n\t            if(inValue>this.getFirstX())\n\t                return this.getNbPoints();\n\t            if(inValue<this.getLastX())\n\t                return -1;\n\t        }\n\t        else{\n\t            if(inValue<this.getFirstX())\n\t                return -1;\n\t            if(inValue>this.getLastX())\n\t                return this.getNbPoints();\n\t        }\n\t\n\t        while (Math.abs(upperLimit-lowerLimit) > 1)\n\t        {\n\t            midPoint=Math.round(Math.floor((upperLimit+lowerLimit)/2));\n\t            //x=this.getX(midPoint);\n\t            if(this.getX(midPoint)==inValue)\n\t                return midPoint;\n\t            if(this.getX(midPoint)>inValue)\n\t                upperLimit=midPoint;\n\t            else\n\t                lowerLimit=midPoint;\n\t        }\n\t        currentArrayPoint=lowerLimit;\n\t        if(Math.abs(this.getX(lowerLimit)-inValue)>Math.abs(this.getX(upperLimit)-inValue))\n\t            currentArrayPoint=upperLimit;\n\t        return currentArrayPoint;\n\t    } else {\n\t        return 0;\n\t    }\n\t}\n\t\n\t\n\t\n\t/**\n\t* Returns the separation between 2 consecutive points in the spectra domain\n\t*/\n\tSD.prototype.getDeltaX=function(){\n\t    return (this.getLastX()-this.getFirstX()) / (this.getNbPoints()-1);\n\t}\n\t\n\t/**\n\t * @function setMinMax(min,max)\n\t * This function scales the values of Y between the min and max parameters\n\t * @param min   Minimum desired value for Y\n\t * @param max   Maximum desired value for Y\n\t */\n\tSD.prototype.setMinMax=function(min,max) {\n\t    var y = this.getYData();\n\t    var minMax = StatArray.minMax(y);\n\t    var factor = (max - min)/(minMax.max-minMax.min);\n\t    for(var i=0;i< y.length;i++){\n\t        y[i]=(y[i]-minMax.min)*factor+min;\n\t    }\n\t}\n\t\n\t/**\n\t * @function setMin(min)\n\t * This function scales the values of Y to fit the min parameter\n\t * @param min   Minimum desired value for Y\n\t */\n\tSD.prototype.setMin=function(min) {\n\t    var y = this.getYData();\n\t    var currentMin = StatArray.min(y);\n\t    var factor = min/currentMin;\n\t    for(var i=0;i< y.length;i++){\n\t        y[i]*=factor;\n\t    }\n\t}\n\t\n\t/**\n\t * @function setMax(max)\n\t * This function scales the values of Y to fit the max parameter\n\t * @param max   Maximum desired value for Y\n\t */\n\tSD.prototype.setMax=function(max) {\n\t    var y = this.getYData();\n\t    var currentMin = StatArray.max(y);\n\t    var factor = max/currentMin;\n\t    for(var i=0;i< y.length;i++){\n\t        y[i]*=factor;\n\t    }\n\t}\n\t\n\t/**\n\t * @function YShift(value)\n\t * This function shifts the values of Y\n\t * @param value Distance of the shift\n\t */\n\tSD.prototype.YShift=function(value) {\n\t    var y = this.getSpectrumData().y;\n\t    var length = this.getNbPoints(),i=0;\n\t    for(i=0;i<length;i++){\n\t        y[i]+=value;\n\t    }\n\t    this.getSpectrum().firstY+=value;\n\t    this.getSpectrum().lastY+=value;\n\t}\n\t\n\t/**\n\t * @function shift(globalShift)\n\t * This function shift the given spectraData. After this function is applied, all the peaks in the\n\t * spectraData will be found at xi+globalShift\n\t * @param globalShift\n\t */\n\tSD.prototype.shift=function(globalShift) {\n\t    for(var i=0;i<this.getNbSubSpectra();i++){\n\t        this.setActiveElement(i);\n\t        var x = this.getSpectrumData().x;\n\t        var length = this.getNbPoints(),i=0;\n\t        for(i=0;i<length;i++){\n\t            x[i]+=globalShift;\n\t        }\n\t\n\t        this.getSpectrum().firstX+=globalShift;\n\t        this.getSpectrum().lastX+=globalShift;\n\t    }\n\t\n\t}\n\t\n\t/**\n\t * @function fillWith(from, to, value)\n\t * This function fills a zone of the spectrum with the given value.\n\t * @param from\n\t * @param to\n\t * @param fillWith\n\t */\n\tSD.prototype.fillWith=function(from, to, value) {\n\t    var tmp, start, end, x, y;\n\t    if(from > to) {\n\t        var tmp = from;\n\t        from = to;\n\t        to = tmp;\n\t    }\n\t\n\t    for(var i=0;i<this.getNbSubSpectra();i++){\n\t        this.setActiveElement(i);\n\t        x = this.getXData();\n\t        y = this.getYData();\n\t        start = this.unitsToArrayPoint(from);\n\t        end = this.unitsToArrayPoint(to);\n\t        if(start > end){\n\t            tmp = start;\n\t            start = end;\n\t            end = tmp;\n\t        }\n\t        if(start<0)\n\t            start=0;\n\t        if(end>=this.getNbPoints)\n\t            end=this.getNbPoints-1;\n\t        for(i=start;i<=end;i++){\n\t                y[i]=value;\n\t        }\n\t    }\n\t}\n\t\n\t/**\n\t * @function suppressZone(from, to)\n\t * This function suppress a zone from the given spectraData within the given x range.\n\t * Returns a spectraData of type PEAKDATA without peaks in the given region\n\t * @param from\n\t * @param to\n\t */\n\tSD.prototype.suppressZone=function(from, to) {\n\t    var tmp, start, end, x, y;\n\t    if(from > to) {\n\t        var tmp = from;\n\t        from = to;\n\t        to = tmp;\n\t    }\n\t\n\t    for(var i=0;i<this.getNbSubSpectra();i++){\n\t        this.setActiveElement(i);\n\t        x = this.getXData();\n\t        y = this.getYData();\n\t        start = this.unitsToArrayPoint(from);\n\t        end = this.unitsToArrayPoint(to);\n\t        if(start > end){\n\t            tmp = start;\n\t            start = end;\n\t            end = tmp;\n\t        }\n\t        if(start<0)\n\t            start=0;\n\t        if(end>=this.getNbPoints)\n\t            end=this.getNbPoints-1;\n\t        for(i=end;i>=start;i--){\n\t            y.splice(i,1);\n\t            x.splice(i,1);\n\t        }\n\t    }\n\t    this.setDataClass(this.DATACLASS_PEAK);\n\t}\n\t\n\t\n\t/**\n\t * @function peakPicking(parameters)\n\t * This function performs a simple peak detection in a spectraData. The parameters that can be specified are:\n\t * Returns a two dimensional array of double specifying [x,y] of the detected peaks.\n\t * @option from:    Lower limit.\n\t * @option to:      Upper limit.\n\t * @option threshold: The minimum intensity to consider a peak as a signal, expressed as a percentage of the highest peak. \n\t * @option stdev: Number of standard deviation of the noise for the threshold calculation if a threshold is not specified.\n\t * @option resolution: The maximum resolution of the spectrum for considering peaks.\n\t * @option yInverted: Is it a Y inverted spectrum?(like an IR spectrum)\n\t * @option smooth: A function for smoothing the spectraData before the detection. If your are dealing with\n\t * experimental spectra, smoothing will make the algorithm less prune to false positives.\n\t */\n\tSD.prototype.simplePeakPicking=function(parameters) {\n\t    //@TODO implements this filter\n\t}\n\t\n\t/**\n\t * @function getMaxPeak();\n\t * Get the maximum peak\n\t */\n\tSD.prototype.getMaxPeak = function(){\n\t    var y = this.getSpectraDataY();\n\t    var max=y[0], index=0;\n\t    for(var i=0;i< y.length;i++){\n\t        if(max<y[i]){\n\t            max = y[i];\n\t            index=i;\n\t        }\n\t    }\n\t    return [this.getSpectraDataX()[index],max];\n\t}\n\t\n\t/**\n\t * @function getParamDouble(name, defvalue);\n\t * Get the value of the parameter\n\t * @param  name The parameter name\n\t * @param  defvalue The default value\n\t */\n\tSD.prototype.getParamDouble = function(name, defvalue){\n\t    var value = this.sd.info[name];\n\t    if(!value)\n\t        value = defvalue;\n\t    return value;\n\t}\n\t\n\t/**\n\t * @function getParamString(name, defvalue);\n\t * Get the value of the parameter\n\t * @param  name The parameter name\n\t * @param  defvalue The default value\n\t */\n\tSD.prototype.getParamString = function(name, defvalue){\n\t    var value = this.sd.info[name];\n\t    if(!value)\n\t        value = defvalue;\n\t    return value+\"\";\n\t}\n\t\n\t/**\n\t * @function getParamInt(name, defvalue);\n\t * Get the value of the parameter\n\t * @param  name The parameter name\n\t * @param  defvalue The default value\n\t */\n\tSD.prototype.getParamInt = function(name, defvalue){\n\t    var value = this.sd.info[name];\n\t    if(!value)\n\t        value = defvalue;\n\t    return value;\n\t}\n\t\n\t/**\n\t * Return the y elements of the current spectrum\n\t * @returns {*}\n\t */\n\tSD.prototype.getSpectrumDataY = function(){\n\t    return this.getYData();\n\t}\n\t\n\t/**\n\t * Return the x elements of the current spectrum\n\t * @returns {*}\n\t */\n\tSD.prototype.getSpectraDataX = function(){\n\t    return this.getXData();\n\t}\n\t\n\t/**\n\t * Set a new parameter to this spectrum\n\t * @param name\n\t * @param value\n\t */\n\tSD.prototype.putParam = function(name, value){\n\t    this.sd.info[name]=value;\n\t}\n\t\n\t/**\n\t * This function returns the area under the spectrum in the given window\n\t */\n\tSD.prototype.getArea = function(from, to){\n\t    var i0 = this.unitsToArrayPoint(from);\n\t    var ie = this.unitsToArrayPoint(to);\n\t    var area = 0;\n\t    if(i0>ie){\n\t        var tmp = i0;\n\t        i0 = ie;\n\t        ie = tmp;\n\t    }\n\t    i0=i0<0?0:i0;\n\t    ie=ie>=this.getNbPoints()?this.getNbPoints()-1:ie;\n\t    for(var i=i0;i<ie;i++){\n\t        area+= this.getY(i);\n\t    }\n\t    return area*Math.abs(this.getDeltaX());\n\t},\n\t\n\t/**\n\t * Returns a equally spaced vector within the given window.\n\t * @param from\n\t * @param to\n\t * @param nPoints\n\t * @returns {*}\n\t */\n\tSD.prototype.getVector = function(from, to, nPoints){\n\t    var x = this.getSpectraDataX();\n\t    var y = this.getSpectraDataY();\n\t    var result = [];\n\t    var start = 0, end = x.length- 1,direction=1;\n\t    var reversed = false;\n\t\n\t    if(x[0]>x[1]){\n\t        direction = -1;\n\t        start= x.length-1;\n\t        end = 0;\n\t    }\n\t\n\t    if(from > to){\n\t        var tmp = from;\n\t        from = to;\n\t        to = tmp;\n\t        reversed = true;\n\t    }\n\t\n\t    if(x[end]>from||x[start]>to)\n\t        return [];\n\t\n\t    while(x[start]<from){start+=direction;}\n\t\n\t    if(x[end]>to){\n\t        var end = start;\n\t        while(x[end]<to){end+=direction;}\n\t    }\n\t    var winPoints = Math.abs(end-start)+1;\n\t    var xwin = new Array(winPoints), ywin = new Array(winPoints);\n\t    var index = 0;\n\t    if(direction==-1)\n\t        index=winPoints-1;\n\t    var i=start-direction;\n\t    do{\n\t        i+=direction;\n\t        xwin[index]=x[i];\n\t        ywin[index]=y[i];\n\t        index+=direction;\n\t    }while(i!=end);\n\t\n\t    return [xwin,ywin];\n\t}\n\t\n\t/**\n\t * @function is2D();\n\t * Is it a 2D spectrum?\n\t */\n\tSD.prototype.is2D = function(){\n\t    return false;\n\t}\n\t\n\t\n\tmodule.exports = SD;\n\t\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t// https://github.com/accord-net/framework/blob/development/Sources/Accord.Statistics/Tools.cs\n\t\n\tfunction max(values) {\n\t    var max = -Infinity, l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        if (values[i] > max) max = values[i];\n\t    }\n\t    return max;\n\t}\n\t\n\tfunction min(values) {\n\t    var min = Infinity, l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        if (values[i] < min) min = values[i];\n\t    }\n\t    return min;\n\t}\n\t\n\tfunction minMax(values) {\n\t    var min = Infinity,\n\t        max = -Infinity,\n\t        l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        if (values[i] < min) min = values[i];\n\t        if (values[i] > max) max = values[i];\n\t    }\n\t    return {\n\t        min: min,\n\t        max: max\n\t    };\n\t}\n\t\n\tfunction mean(values) {\n\t    var sum = 0, l = values.length;\n\t    for (var i = 0; i < l; i++)\n\t        sum += values[i];\n\t    return sum / l;\n\t}\n\t\n\tfunction geometricMean(values) {\n\t    var sum = 0, l = values.length;\n\t    for (var i = 0; i < l; i++)\n\t        sum *= values[i];\n\t    return Math.pow(sum, 1 / l);\n\t}\n\t\n\tfunction logGeometricMean(values) {\n\t    var lnsum = 0, l = values.length;\n\t    for (var i = 0; i < l; i++)\n\t        lnsum += Math.log(values[i]);\n\t    return lnsum / l;\n\t}\n\t\n\tfunction grandMean(means, samples) {\n\t    var sum = 0, n = 0, l = means.length;\n\t    for (var i = 0; i < l; i++) {\n\t        sum += samples[i] * means[i];\n\t        n += samples[i];\n\t    }\n\t    return sum / n;\n\t}\n\t\n\tfunction truncatedMean(values, percent, inPlace) {\n\t    if (typeof(inPlace) === 'undefined') inPlace = false;\n\t\n\t    values = inPlace ? values : values.slice();\n\t    values.sort();\n\t\n\t    var l = values.length;\n\t    var k = Math.floor(l * percent);\n\t\n\t    var sum = 0;\n\t    for (var i = k; i < l - k; i++)\n\t        sum += values[i];\n\t\n\t    return sum / (l - 2 * k);\n\t}\n\t\n\tfunction contraHarmonicMean(values, order) {\n\t    if (typeof(order) === 'undefined') order = 1;\n\t    var r1 = 0, r2 = 0, l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        r1 += Math.pow(values[i], order + 1);\n\t        r2 += Math.pow(values[i], order);\n\t    }\n\t    return r1 / r2;\n\t}\n\t\n\tfunction standardDeviation(values, unbiased) {\n\t    return Math.sqrt(variance(values, unbiased));\n\t}\n\t\n\tfunction standardError(values) {\n\t    return standardDeviation(values) / Math.sqrt(values.length);\n\t}\n\t\n\tfunction median(values, alreadySorted) {\n\t    if (typeof(alreadySorted) === 'undefined') alreadySorted = false;\n\t    if (!alreadySorted) {\n\t        values = values.slice();\n\t        values.sort();\n\t    }\n\t\n\t    var l = values.length;\n\t    var half = Math.floor(l / 2);\n\t    if (l % 2 === 0)\n\t        return (values[half - 1] + values[half]) * 0.5;\n\t    return values[half];\n\t}\n\t\n\tfunction quartiles(values, alreadySorted) {\n\t    if (typeof(alreadySorted) === 'undefined') alreadySorted = false;\n\t    if (!alreadySorted) {\n\t        values = values.slice();\n\t        values.sort();\n\t    }\n\t\n\t    var quart = values.length / 4;\n\t    var q1 = values[Math.ceil(quart) - 1];\n\t    var q2 = median(values, true);\n\t    var q3 = values[Math.ceil(quart * 3) - 1];\n\t\n\t    return {q1: q1, q2: q2, q3: q3};\n\t}\n\t\n\tfunction variance(values, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var theMean = mean(values);\n\t    var theVariance = 0, l = values.length;\n\t\n\t    for (var i = 0; i < l; i++) {\n\t        var x = values[i] - theMean;\n\t        theVariance += x * x;\n\t    }\n\t\n\t    if (unbiased)\n\t        return theVariance / (l - 1);\n\t    else\n\t        return theVariance / l;\n\t}\n\t\n\tfunction pooledStandardDeviation(samples, unbiased) {\n\t    return Math.sqrt(pooledVariance(samples, unbiased));\n\t}\n\t\n\tfunction pooledVariance(samples, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var sum = 0;\n\t    var length = 0, l = samples.length;\n\t    for (var i = 0; i < l; i++) {\n\t        var values = samples[i];\n\t        var vari = variance(values);\n\t\n\t        sum += (values.length - 1) * vari;\n\t\n\t        if (unbiased)\n\t            length += values.length - 1;\n\t        else\n\t            length += values.length;\n\t    }\n\t    return sum / length;\n\t}\n\t\n\tfunction mode(values) {\n\t    var l = values.length,\n\t        itemCount = new Array(l),\n\t        i;\n\t    for (i = 0; i < l; i++) {\n\t        itemCount[i] = 0;\n\t    }\n\t    var itemArray = new Array(l);\n\t    var count = 0;\n\t\n\t    for (i = 0; i < l; i++) {\n\t        var index = itemArray.indexOf(values[i]);\n\t        if (index >= 0)\n\t            itemCount[index]++;\n\t        else {\n\t            itemArray[count] = values[i];\n\t            itemCount[count] = 1;\n\t            count++;\n\t        }\n\t    }\n\t\n\t    var maxValue = 0, maxIndex = 0;\n\t    for (i = 0; i < count; i++) {\n\t        if (itemCount[i] > maxValue) {\n\t            maxValue = itemCount[i];\n\t            maxIndex = i;\n\t        }\n\t    }\n\t\n\t    return itemArray[maxIndex];\n\t}\n\t\n\tfunction covariance(vector1, vector2, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var mean1 = mean(vector1);\n\t    var mean2 = mean(vector2);\n\t\n\t    if (vector1.length !== vector2.length)\n\t        throw \"Vectors do not have the same dimensions\";\n\t\n\t    var cov = 0, l = vector1.length;\n\t    for (var i = 0; i < l; i++) {\n\t        var x = vector1[i] - mean1;\n\t        var y = vector2[i] - mean2;\n\t        cov += x * y;\n\t    }\n\t\n\t    if (unbiased)\n\t        return cov / (l - 1);\n\t    else\n\t        return cov / l;\n\t}\n\t\n\tfunction skewness(values, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var theMean = mean(values);\n\t\n\t    var s2 = 0, s3 = 0, l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        var dev = values[i] - theMean;\n\t        s2 += dev * dev;\n\t        s3 += dev * dev * dev;\n\t    }\n\t    var m2 = s2 / l;\n\t    var m3 = s3 / l;\n\t\n\t    var g = m3 / (Math.pow(m2, 3 / 2.0));\n\t    if (unbiased) {\n\t        var a = Math.sqrt(l * (l - 1));\n\t        var b = l - 2;\n\t        return (a / b) * g;\n\t    }\n\t    else {\n\t        return g;\n\t    }\n\t}\n\t\n\tfunction kurtosis(values, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var theMean = mean(values);\n\t    var n = values.length, s2 = 0, s4 = 0;\n\t\n\t    for (var i = 0; i < n; i++) {\n\t        var dev = values[i] - theMean;\n\t        s2 += dev * dev;\n\t        s4 += dev * dev * dev * dev;\n\t    }\n\t    var m2 = s2 / n;\n\t    var m4 = s4 / n;\n\t\n\t    if (unbiased) {\n\t        var v = s2 / (n - 1);\n\t        var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n\t        var b = s4 / (v * v);\n\t        var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n\t\n\t        return a * b - 3 * c;\n\t    }\n\t    else {\n\t        return m4 / (m2 * m2) - 3;\n\t    }\n\t}\n\t\n\tfunction entropy(values, eps) {\n\t    if (typeof(eps) === 'undefined') eps = 0;\n\t    var sum = 0, l = values.length;\n\t    for (var i = 0; i < l; i++)\n\t        sum += values[i] * Math.log(values[i] + eps);\n\t    return -sum;\n\t}\n\t\n\tfunction weightedMean(values, weights) {\n\t    var sum = 0, l = values.length;\n\t    for (var i = 0; i < l; i++)\n\t        sum += values[i] * weights[i];\n\t    return sum;\n\t}\n\t\n\tfunction weightedStandardDeviation(values, weights) {\n\t    return Math.sqrt(weightedVariance(values, weights));\n\t}\n\t\n\tfunction weightedVariance(values, weights) {\n\t    var theMean = weightedMean(values, weights);\n\t    var vari = 0, l = values.length;\n\t    var a = 0, b = 0;\n\t\n\t    for (var i = 0; i < l; i++) {\n\t        var z = values[i] - theMean;\n\t        var w = weights[i];\n\t\n\t        vari += w * (z * z);\n\t        b += w;\n\t        a += w * w;\n\t    }\n\t\n\t    return vari * (b / (b * b - a));\n\t}\n\t\n\tfunction center(values, inPlace) {\n\t    if (typeof(inPlace) === 'undefined') inPlace = false;\n\t\n\t    var result = values;\n\t    if (!inPlace)\n\t        result = values.slice();\n\t\n\t    var theMean = mean(result), l = result.length;\n\t    for (var i = 0; i < l; i++)\n\t        result[i] -= theMean;\n\t}\n\t\n\tfunction standardize(values, standardDev, inPlace) {\n\t    if (typeof(standardDev) === 'undefined') standardDev = standardDeviation(values);\n\t    if (typeof(inPlace) === 'undefined') inPlace = false;\n\t    var l = values.length;\n\t    var result = inPlace ? values : new Array(l);\n\t    for (var i = 0; i < l; i++)\n\t        result[i] = values[i] / standardDev;\n\t    return result;\n\t}\n\t\n\tfunction cumulativeSum(array) {\n\t    var l = array.length;\n\t    var result = new Array(l);\n\t    result[0] = array[0];\n\t    for (var i = 1; i < l; i++)\n\t        result[i] = result[i - 1] + array[i];\n\t    return result;\n\t}\n\t\n\tmodule.exports = {\n\t    min: min,\n\t    max: max,\n\t    minMax: minMax,\n\t    mean: mean,\n\t    geometricMean: geometricMean,\n\t    logGeometricMean: logGeometricMean,\n\t    grandMean: grandMean,\n\t    truncatedMean: truncatedMean,\n\t    contraHarmonicMean: contraHarmonicMean,\n\t    standardDeviation: standardDeviation,\n\t    standardError: standardError,\n\t    median: median,\n\t    quartiles: quartiles,\n\t    variance: variance,\n\t    pooledStandardDeviation: pooledStandardDeviation,\n\t    pooledVariance: pooledVariance,\n\t    mode: mode,\n\t    covariance: covariance,\n\t    skewness: skewness,\n\t    kurtosis: kurtosis,\n\t    entropy: entropy,\n\t    weightedMean: weightedMean,\n\t    weightedStandardDeviation: weightedStandardDeviation,\n\t    weightedVariance: weightedVariance,\n\t    center: center,\n\t    standardize: standardize,\n\t    cumulativeSum: cumulativeSum\n\t};\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction getConverter() {\n\t\n\t    // the following RegExp can only be used for XYdata, some peakTables have values with a \"E-5\" ...\n\t    var xyDataSplitRegExp = /[,\\t \\+-]*(?=[^\\d,\\t \\.])|[ \\t]+(?=[\\d+\\.-])/;\n\t    var removeCommentRegExp = /\\$\\$.*/;\n\t    var peakTableSplitRegExp = /[,\\t ]+/;\n\t    var DEBUG = false;\n\t\n\t    var GC_MS_FIELDS = ['TIC', '.RIC', 'SCANNUMBER'];\n\t\n\t    function convertToFloatArray(stringArray) {\n\t        var l = stringArray.length;\n\t        var floatArray = new Array(l);\n\t        for (var i = 0; i < l; i++) {\n\t            floatArray[i] = parseFloat(stringArray[i]);\n\t        }\n\t        return floatArray;\n\t    }\n\t\n\t    /*\n\t     options.keepSpectra: keep the original spectra for a 2D\n\t     options.xy: true // create x / y array instead of a 1D array\n\t     options.keepRecordsRegExp: which fields do we keep\n\t     */\n\t\n\t    function convert(jcamp, options) {\n\t        options = options || {};\n\t\n\t        var keepRecordsRegExp=/^[A-Z]+$/;\n\t        if (options.keepRecordsRegExp) keepRecordsRegExp=options.keepRecordsRegExp;\n\t\n\t        var start = new Date();\n\t\n\t        var ntuples = {},\n\t            ldr,\n\t            dataLabel,\n\t            dataValue,\n\t            ldrs,\n\t            i, ii, position, endLine, infos;\n\t\n\t        var result = {};\n\t        result.profiling = [];\n\t        result.logs = [];\n\t        var spectra = [];\n\t        result.spectra = spectra;\n\t        result.info = {};\n\t        var spectrum = {};\n\t\n\t        if (!(typeof jcamp === 'string')) return result;\n\t        // console.time('start');\n\t\n\t        if (result.profiling) result.profiling.push({action: 'Before split to LDRS', time: new Date() - start});\n\t\n\t        ldrs = jcamp.split(/[\\r\\n]+##/);\n\t\n\t        if (result.profiling) result.profiling.push({action: 'Split to LDRS', time: new Date() - start});\n\t\n\t        if (ldrs[0]) ldrs[0] = ldrs[0].replace(/^[\\r\\n ]*##/, '');\n\t\n\t        for (i = 0, ii = ldrs.length; i < ii; i++) {\n\t            ldr = ldrs[i];\n\t            // This is a new LDR\n\t            position = ldr.indexOf('=');\n\t            if (position > 0) {\n\t                dataLabel = ldr.substring(0, position);\n\t                dataValue = ldr.substring(position + 1).trim();\n\t            } else {\n\t                dataLabel = ldr;\n\t                dataValue = '';\n\t            }\n\t            dataLabel = dataLabel.replace(/[_ -]/g, '').toUpperCase();\n\t\n\t            if (dataLabel === 'DATATABLE') {\n\t                endLine = dataValue.indexOf('\\n');\n\t                if (endLine === -1) endLine = dataValue.indexOf('\\r');\n\t                if (endLine > 0) {\n\t                    var xIndex = -1;\n\t                    var yIndex = -1;\n\t                    // ##DATA TABLE= (X++(I..I)), XYDATA\n\t                    // We need to find the variables\n\t\n\t                    infos = dataValue.substring(0, endLine).split(/[ ,;\\t]+/);\n\t                    if (infos[0].indexOf('++') > 0) {\n\t                        var firstVariable = infos[0].replace(/.*\\(([a-zA-Z0-9]+)\\+\\+.*/, '$1');\n\t                        var secondVariable = infos[0].replace(/.*\\.\\.([a-zA-Z0-9]+).*/, '$1');\n\t                        xIndex = ntuples.symbol.indexOf(firstVariable);\n\t                        yIndex = ntuples.symbol.indexOf(secondVariable);\n\t                    }\n\t\n\t                    if (xIndex === -1) xIndex = 0;\n\t                    if (yIndex === -1) yIndex = 0;\n\t\n\t                    if (ntuples.first) {\n\t                        if (ntuples.first.length > xIndex) spectrum.firstX = ntuples.first[xIndex];\n\t                        if (ntuples.first.length > yIndex) spectrum.firstY = ntuples.first[yIndex];\n\t                    }\n\t                    if (ntuples.last) {\n\t                        if (ntuples.last.length > xIndex) spectrum.lastX = ntuples.last[xIndex];\n\t                        if (ntuples.last.length > yIndex) spectrum.lastY = ntuples.last[yIndex];\n\t                    }\n\t                    if (ntuples.vardim && ntuples.vardim.length > xIndex) {\n\t                        spectrum.nbPoints = ntuples.vardim[xIndex];\n\t                    }\n\t                    if (ntuples.factor) {\n\t                        if (ntuples.factor.length > xIndex) spectrum.xFactor = ntuples.factor[xIndex];\n\t                        if (ntuples.factor.length > yIndex) spectrum.yFactor = ntuples.factor[yIndex];\n\t                    }\n\t                    if (ntuples.units) {\n\t                        if (ntuples.units.length > xIndex) spectrum.xUnit = ntuples.units[xIndex];\n\t                        if (ntuples.units.length > yIndex) spectrum.yUnit = ntuples.units[yIndex];\n\t                    }\n\t                    spectrum.datatable = infos[0];\n\t                    if (infos[1] && infos[1].indexOf('PEAKS') > -1) {\n\t                        dataLabel = 'PEAKTABLE';\n\t                    } else if (infos[1] && (infos[1].indexOf('XYDATA') || infos[0].indexOf('++') > 0)) {\n\t                        dataLabel = 'XYDATA';\n\t                        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n\t                    }\n\t                }\n\t            }\n\t\n\t\n\t            if (dataLabel === 'TITLE') {\n\t                spectrum.title = dataValue;\n\t            } else if (dataLabel === 'DATATYPE') {\n\t                spectrum.dataType = dataValue;\n\t                if (dataValue.indexOf('nD') > -1) {\n\t                    result.twoD = true;\n\t                }\n\t            } else if (dataLabel === 'XUNITS') {\n\t                spectrum.xUnit = dataValue;\n\t            } else if (dataLabel === 'YUNITS') {\n\t                spectrum.yUnit = dataValue;\n\t            } else if (dataLabel === 'FIRSTX') {\n\t                spectrum.firstX = parseFloat(dataValue);\n\t            } else if (dataLabel === 'LASTX') {\n\t                spectrum.lastX = parseFloat(dataValue);\n\t            } else if (dataLabel === 'FIRSTY') {\n\t                spectrum.firstY = parseFloat(dataValue);\n\t            } else if (dataLabel === 'NPOINTS') {\n\t                spectrum.nbPoints = parseFloat(dataValue);\n\t            } else if (dataLabel === 'XFACTOR') {\n\t                spectrum.xFactor = parseFloat(dataValue);\n\t            } else if (dataLabel === 'YFACTOR') {\n\t                spectrum.yFactor = parseFloat(dataValue);\n\t            } else if (dataLabel === 'DELTAX') {\n\t                spectrum.deltaX = parseFloat(dataValue);\n\t            } else if (dataLabel === '.OBSERVEFREQUENCY' || dataLabel === '$SFO1') {\n\t                if (!spectrum.observeFrequency) spectrum.observeFrequency = parseFloat(dataValue);\n\t            } else if (dataLabel === '.OBSERVENUCLEUS') {\n\t                if (!spectrum.xType) result.xType = dataValue.replace(/[^a-zA-Z0-9]/g, '');\n\t            } else if (dataLabel === '$SFO2') {\n\t                if (!result.indirectFrequency) result.indirectFrequency = parseFloat(dataValue);\n\t\n\t            } else if (dataLabel === '$OFFSET') {   // OFFSET for Bruker spectra\n\t                result.shiftOffsetNum = 0;\n\t                if (!result.shiftOffsetVal)  result.shiftOffsetVal = parseFloat(dataValue);\n\t            } else if (dataLabel === '$REFERENCEPOINT') {   // OFFSET for Varian spectra\n\t\n\t\n\t                // if we activate this part it does not work for ACD specmanager\n\t                //         } else if (dataLabel=='.SHIFTREFERENCE') {   // OFFSET FOR Bruker Spectra\n\t                //                 var parts = dataValue.split(/ *, */);\n\t                //                 result.shiftOffsetNum = parseInt(parts[2].trim());\n\t                //                 result.shiftOffsetVal = parseFloat(parts[3].trim());\n\t            } else if (dataLabel === 'VARNAME') {\n\t                ntuples.varname = dataValue.split(/[, \\t]{2,}/);\n\t            } else if (dataLabel === 'SYMBOL') {\n\t                ntuples.symbol = dataValue.split(/[, \\t]{2,}/);\n\t            } else if (dataLabel === 'VARTYPE') {\n\t                ntuples.vartype = dataValue.split(/[, \\t]{2,}/);\n\t            } else if (dataLabel === 'VARFORM') {\n\t                ntuples.varform = dataValue.split(/[, \\t]{2,}/);\n\t            } else if (dataLabel === 'VARDIM') {\n\t                ntuples.vardim = convertToFloatArray(dataValue.split(/[, \\t]{2,}/));\n\t            } else if (dataLabel === 'UNITS') {\n\t                ntuples.units = dataValue.split(/[, \\t]{2,}/);\n\t            } else if (dataLabel === 'FACTOR') {\n\t                ntuples.factor = convertToFloatArray(dataValue.split(/[, \\t]{2,}/));\n\t            } else if (dataLabel === 'FIRST') {\n\t                ntuples.first = convertToFloatArray(dataValue.split(/[, \\t]{2,}/));\n\t            } else if (dataLabel === 'LAST') {\n\t                ntuples.last = convertToFloatArray(dataValue.split(/[, \\t]{2,}/));\n\t            } else if (dataLabel === 'MIN') {\n\t                ntuples.min = convertToFloatArray(dataValue.split(/[, \\t]{2,}/));\n\t            } else if (dataLabel === 'MAX') {\n\t                ntuples.max = convertToFloatArray(dataValue.split(/[, \\t]{2,}/));\n\t            } else if (dataLabel === '.NUCLEUS') {\n\t                if (result.twoD) {\n\t                    result.yType = dataValue.split(/[, \\t]{2,}/)[0];\n\t                }\n\t            } else if (dataLabel === 'PAGE') {\n\t                spectrum.page = dataValue.trim();\n\t                spectrum.pageValue = parseFloat(dataValue.replace(/^.*=/, ''));\n\t                spectrum.pageSymbol = spectrum.page.replace(/=.*/, '');\n\t                var pageSymbolIndex = ntuples.symbol.indexOf(spectrum.pageSymbol);\n\t                var unit = '';\n\t                if (ntuples.units && ntuples.units[pageSymbolIndex]) {\n\t                    unit = ntuples.units[pageSymbolIndex];\n\t                }\n\t                if (result.indirectFrequency && unit !== 'PPM') {\n\t                    spectrum.pageValue /= result.indirectFrequency;\n\t                }\n\t            } else if (dataLabel === 'RETENTIONTIME') {\n\t                spectrum.pageValue = parseFloat(dataValue);\n\t            } else if (dataLabel === 'XYDATA') {\n\t                prepareSpectrum(result, spectrum);\n\t                // well apparently we should still consider it is a PEAK TABLE if there are no '++' after\n\t                if (dataValue.match(/.*\\+\\+.*/)) {\n\t                    parseXYData(spectrum, dataValue, result);\n\t                } else {\n\t                    parsePeakTable(spectrum, dataValue, result);\n\t                }\n\t                spectra.push(spectrum);\n\t                spectrum = {};\n\t            } else if (dataLabel === 'PEAKTABLE') {\n\t                prepareSpectrum(result, spectrum);\n\t                parsePeakTable(spectrum, dataValue, result);\n\t                spectra.push(spectrum);\n\t                spectrum = {};\n\t            } else if (isMSField(dataLabel)) {\n\t                spectrum[convertMSFieldToLabel(dataLabel)] = dataValue;\n\t            } else if (dataLabel.match(keepRecordsRegExp)) {\n\t                result.info[dataLabel] = dataValue.trim();\n\t            }\n\t        }\n\t\n\t        // Currently disabled\n\t        //    if (options && options.lowRes) addLowRes(spectra,options);\n\t\n\t        if (result.profiling) result.profiling.push({action: 'Finished parsing', time: new Date() - start});\n\t\n\t        if (Object.keys(ntuples).length>0) {\n\t            var newNtuples=[];\n\t            var keys=Object.keys(ntuples);\n\t            for (var i=0; i<keys.length; i++) {\n\t                var key=keys[i];\n\t                var values=ntuples[key];\n\t                for (var j=0; j<values.length; j++) {\n\t                    if (! newNtuples[j]) newNtuples[j]={};\n\t                    newNtuples[j][key]=values[j];\n\t                }\n\t            }\n\t            result.ntuples=newNtuples;\n\t        }\n\t\n\t        if (result.twoD) {\n\t            add2D(result);\n\t            if (result.profiling) result.profiling.push({\n\t                action: 'Finished countour plot calculation',\n\t                time: new Date() - start\n\t            });\n\t            if (!options.keepSpectra) {\n\t                delete result.spectra;\n\t            }\n\t        }\n\t\n\t\n\t        // maybe it is a GC (HPLC) / MS. In this case we add a new format\n\t        if (spectra.length > 1 && (! spectra[0].dataType || spectra[0].dataType.toLowerCase().match(/.*mass./))) {\n\t            addGCMS(result);\n\t            if (result.profiling) result.profiling.push({\n\t                action: 'Finished GCMS calculation',\n\t                time: new Date() - start\n\t            });\n\t        }\n\t\n\t\n\t        if (options.xy) { // the spectraData should not be a oneD array but an object with x and y\n\t            if (spectra.length > 0) {\n\t                for (var i=0; i<spectra.length; i++) {\n\t                    var spectrum=spectra[i];\n\t                    if (spectrum.data.length>0) {\n\t                        for (var j=0; j<spectrum.data.length; j++) {\n\t                            var data=spectrum.data[j];\n\t                            var newData={x:Array(data.length/2), y:Array(data.length/2)};\n\t                            for (var k=0; k<data.length; k=k+2) {\n\t                                newData.x[k/2]=data[k];\n\t                                newData.y[k/2]=data[k+1];\n\t                            }\n\t                            spectrum.data[j]=newData;\n\t                        }\n\t\n\t                    }\n\t\n\t                }\n\t            }\n\t        }\n\t\n\t        if (result.profiling) {\n\t            result.profiling.push({action: 'Total time', time: new Date() - start});\n\t        }\n\t\n\t        //   console.log(result);\n\t        //    console.log(JSON.stringify(spectra));\n\t        return result;\n\t\n\t    }\n\t\n\t\n\t    function convertMSFieldToLabel(value) {\n\t        return value.toLowerCase().replace(/[^a-z0-9]/g, '');\n\t    }\n\t\n\t    function isMSField(dataLabel) {\n\t        for (var i = 0; i < GC_MS_FIELDS.length; i++) {\n\t            if (dataLabel === GC_MS_FIELDS[i]) return true;\n\t        }\n\t        return false;\n\t    }\n\t\n\t    function addGCMS(result) {\n\t        var spectra = result.spectra;\n\t        var existingGCMSFields = [];\n\t        var i;\n\t        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n\t            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n\t            if (spectra[0][label]) {\n\t                existingGCMSFields.push(label);\n\t            }\n\t        }\n\t        if (existingGCMSFields.length===0) return;\n\t        var gcms = {};\n\t        gcms.gc = {};\n\t        gcms.ms = [];\n\t        for (i = 0; i < existingGCMSFields.length; i++) {\n\t            gcms.gc[existingGCMSFields[i]] = [];\n\t        }\n\t        for (i = 0; i < spectra.length; i++) {\n\t            var spectrum = spectra[i];\n\t            for (var j = 0; j < existingGCMSFields.length; j++) {\n\t                gcms.gc[existingGCMSFields[j]].push(spectrum.pageValue);\n\t                gcms.gc[existingGCMSFields[j]].push(parseFloat(spectrum[existingGCMSFields[j]]));\n\t            }\n\t          if (spectrum.data) gcms.ms[i] = spectrum.data[0];\n\t\n\t        }\n\t        result.gcms = gcms;\n\t    }\n\t\n\t    function prepareSpectrum(result, spectrum) {\n\t        if (!spectrum.xFactor) spectrum.xFactor = 1;\n\t        if (!spectrum.yFactor) spectrum.yFactor = 1;\n\t        if (spectrum.observeFrequency) {\n\t            if (spectrum.xUnit && spectrum.xUnit.toUpperCase() === 'HZ') {\n\t                spectrum.xUnit = 'PPM';\n\t                spectrum.xFactor = spectrum.xFactor / spectrum.observeFrequency;\n\t                spectrum.firstX = spectrum.firstX / spectrum.observeFrequency;\n\t                spectrum.lastX = spectrum.lastX / spectrum.observeFrequency;\n\t                spectrum.deltaX = spectrum.deltaX / spectrum.observeFrequency;\n\t            }\n\t        }\n\t        if (result.shiftOffsetVal) {\n\t            var shift = spectrum.firstX - result.shiftOffsetVal;\n\t            spectrum.firstX = spectrum.firstX - shift;\n\t            spectrum.lastX = spectrum.lastX - shift;\n\t        }\n\t    }\n\t\n\t    function parsePeakTable(spectrum, value, result) {\n\t        spectrum.isPeaktable=true;\n\t        var i, ii, j, jj, values;\n\t        var currentData = [];\n\t        spectrum.data = [currentData];\n\t\n\t        // counts for around 20% of the time\n\t        var lines = value.split(/,? *,?[;\\r\\n]+ */);\n\t\n\t        var k = 0;\n\t        for (i = 1, ii = lines.length; i < ii; i++) {\n\t            values = lines[i].trim().replace(removeCommentRegExp, '').split(peakTableSplitRegExp);\n\t            if (values.length % 2 === 0) {\n\t                for (j = 0, jj = values.length; j < jj; j = j + 2) {\n\t                    // takes around 40% of the time to add and parse the 2 values nearly exclusively because of parseFloat\n\t                    currentData[k++] = (parseFloat(values[j]) * spectrum.xFactor);\n\t                    currentData[k++] = (parseFloat(values[j + 1]) * spectrum.yFactor);\n\t                }\n\t            } else {\n\t                result.logs.push('Format error: ' + values);\n\t            }\n\t        }\n\t    }\n\t\n\t    function parseXYData(spectrum, value, result) {\n\t        // we check if deltaX is defined otherwise we calculate it\n\t        if (!spectrum.deltaX) {\n\t            spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n\t        }\n\t\n\t        spectrum.isXYdata=true;\n\t\n\t        var currentData = [];\n\t        spectrum.data = [currentData];\n\t\n\t        var currentX = spectrum.firstX;\n\t        var currentY = spectrum.firstY;\n\t        var lines = value.split(/[\\r\\n]+/);\n\t        var lastDif, values, ascii, expectedY;\n\t        values = [];\n\t        for (var i = 1, ii = lines.length; i < ii; i++) {\n\t            //var previousValues=JSON.parse(JSON.stringify(values));\n\t            values = lines[i].trim().replace(removeCommentRegExp, '').split(xyDataSplitRegExp);\n\t            if (values.length > 0) {\n\t                if (DEBUG) {\n\t                    if (!spectrum.firstPoint) {\n\t                        spectrum.firstPoint = parseFloat(values[0]);\n\t                    }\n\t                    var expectedCurrentX = parseFloat(values[0] - spectrum.firstPoint) * spectrum.xFactor + spectrum.firstX;\n\t                    if ((lastDif || lastDif === 0)) {\n\t                        expectedCurrentX += spectrum.deltaX;\n\t                    }\n\t                    result.logs.push('Checking X value: currentX: ' + currentX + ' - expectedCurrentX: ' + expectedCurrentX);\n\t                }\n\t                for (var j = 1, jj = values.length; j < jj; j++) {\n\t                    if (j === 1 && (lastDif || lastDif === 0)) {\n\t                        lastDif = null; // at the beginning of each line there should be the full value X / Y so the diff is always undefined\n\t                        // we could check if we have the expected Y value\n\t                        ascii = values[j].charCodeAt(0);\n\t\n\t                        if (false) { // this code is just to check the jcamp DIFDUP and the next line repeat of Y value\n\t                            // + - . 0 1 2 3 4 5 6 7 8 9\n\t                            if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n\t                                expectedY = parseFloat(values[j]);\n\t                            } else\n\t                            // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n\t                            if ((ascii > 63) && (ascii < 74)) {\n\t                                // we could use parseInt but parseFloat is faster at least in Chrome\n\t                                expectedY = parseFloat(String.fromCharCode(ascii - 16) + values[j].substring(1));\n\t                            } else\n\t                            // negative SQZ digits a b c d e f g h i (ascii 97-105)\n\t                            if ((ascii > 96) && (ascii < 106)) {\n\t                                // we could use parseInt but parseFloat is faster at least in Chrome\n\t                                expectedY = -parseFloat(String.fromCharCode(ascii - 48) + values[j].substring(1));\n\t                            }\n\t                            if (expectedY !== currentY) {\n\t                                result.logs.push('Y value check error: Found: ' + expectedY + ' - Current: ' + currentY);\n\t                                result.logs.push('Previous values: ' + previousValues.length);\n\t                                result.logs.push(previousValues);\n\t                            }\n\t                        }\n\t                    } else {\n\t                        if (values[j].length > 0) {\n\t                            ascii = values[j].charCodeAt(0);\n\t                            // + - . 0 1 2 3 4 5 6 7 8 9\n\t                            if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n\t                                lastDif = null;\n\t                                currentY = parseFloat(values[j]);\n\t                                currentData.push(currentX, currentY * spectrum.yFactor);;\n\t                                currentX += spectrum.deltaX;\n\t                            } else\n\t                            // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n\t                            if ((ascii > 63) && (ascii < 74)) {\n\t                                lastDif = null;\n\t                                currentY = parseFloat(String.fromCharCode(ascii - 16) + values[j].substring(1));\n\t                                currentData.push(currentX, currentY * spectrum.yFactor);;\n\t                                currentX += spectrum.deltaX;\n\t                            } else\n\t                            // negative SQZ digits a b c d e f g h i (ascii 97-105)\n\t                            if ((ascii > 96) && (ascii < 106)) {\n\t                                lastDif = null;\n\t                                currentY = -parseFloat(String.fromCharCode(ascii - 48) + values[j].substring(1));\n\t                                currentData.push(currentX, currentY * spectrum.yFactor);;\n\t                                currentX += spectrum.deltaX;\n\t                            } else\n\t\n\t\n\t\n\t                            // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n\t                            if (((ascii > 82) && (ascii < 91)) || (ascii === 115)) {\n\t                                var dup = parseFloat(String.fromCharCode(ascii - 34) + values[j].substring(1)) - 1;\n\t                                if (ascii === 115) {\n\t                                    dup = parseFloat('9' + values[j].substring(1)) - 1;\n\t                                }\n\t                                for (var l = 0; l < dup; l++) {\n\t                                    if (lastDif) {\n\t                                        currentY = currentY + lastDif;\n\t                                    }\n\t                                    currentData.push(currentX, currentY * spectrum.yFactor);;\n\t                                    currentX += spectrum.deltaX;\n\t                                }\n\t                            } else\n\t                            // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n\t                            if (ascii === 37) {\n\t                                lastDif = parseFloat('0' + values[j].substring(1));\n\t                                currentY += lastDif;\n\t                                currentData.push(currentX, currentY * spectrum.yFactor);;\n\t                                currentX += spectrum.deltaX;\n\t                            } else if ((ascii > 73) && (ascii < 83)) {\n\t                                lastDif = parseFloat(String.fromCharCode(ascii - 25) + values[j].substring(1));\n\t                                currentY += lastDif;\n\t                                currentData.push(currentX, currentY * spectrum.yFactor);;\n\t                                currentX += spectrum.deltaX;\n\t                            } else\n\t                            // negative DIF digits j k l m n o p q r (ascii 106-114)\n\t                            if ((ascii > 105) && (ascii < 115)) {\n\t                                lastDif = -parseFloat(String.fromCharCode(ascii - 57) + values[j].substring(1));\n\t                                currentY += lastDif;\n\t                                currentData.push(currentX, currentY * spectrum.yFactor);;\n\t                                currentX += spectrum.deltaX;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t    }\n\t\n\t    function convertTo3DZ(spectra) {\n\t        var noise = 0;\n\t        var minZ = spectra[0].data[0][0];\n\t        var maxZ = minZ;\n\t        var ySize = spectra.length;\n\t        var xSize = spectra[0].data[0].length / 2;\n\t        var z = new Array(ySize);\n\t        for (var i = 0; i < ySize; i++) {\n\t            z[i] = new Array(xSize);\n\t            for (var j = 0; j < xSize; j++) {\n\t                z[i][j] = spectra[i].data[0][j * 2 + 1];\n\t                if (z[i][j] < minZ) minZ = spectra[i].data[0][j * 2 + 1];\n\t                if (z[i][j] > maxZ) maxZ = spectra[i].data[0][j * 2 + 1];\n\t                if (i !== 0 && j !== 0) {\n\t                    noise += Math.abs(z[i][j] - z[i][j - 1]) + Math.abs(z[i][j] - z[i - 1][j]);\n\t                }\n\t            }\n\t        }\n\t        return {\n\t            z: z,\n\t            minX: spectra[0].data[0][0],\n\t            maxX: spectra[0].data[0][spectra[0].data[0].length - 2],\n\t            minY: spectra[0].pageValue,\n\t            maxY: spectra[ySize - 1].pageValue,\n\t            minZ: minZ,\n\t            maxZ: maxZ,\n\t            noise: noise / ((ySize - 1) * (xSize - 1) * 2)\n\t        };\n\t\n\t    }\n\t\n\t    function add2D(result) {\n\t        var zData = convertTo3DZ(result.spectra);\n\t        result.contourLines = generateContourLines(zData);\n\t        delete zData.z;\n\t        result.minMax = zData;\n\t    }\n\t\n\t\n\t    function generateContourLines(zData, options) {\n\t        //console.time('generateContourLines');\n\t        var noise = zData.noise;\n\t        var z = zData.z;\n\t        var contourLevels = [];\n\t        var nbLevels = 7;\n\t        var povarHeight = new Float32Array(4);\n\t        var isOver = [];\n\t        var nbSubSpectra = z.length;\n\t        var nbPovars = z[0].length;\n\t        var pAx, pAy, pBx, pBy;\n\t\n\t        var x0 = zData.minX;\n\t        var xN = zData.maxX;\n\t        var dx = (xN - x0) / (nbPovars - 1);\n\t        var y0 = zData.minY;\n\t        var yN = zData.maxY;\n\t        var dy = (yN - y0) / (nbSubSpectra - 1);\n\t        var minZ = zData.minZ;\n\t        var maxZ = zData.maxZ;\n\t\n\t        //System.out.prvarln('y0 '+y0+' yN '+yN);\n\t        // -------------------------\n\t        // Povars attribution\n\t        //\n\t        // 0----1\n\t        // |  / |\n\t        // | /  |\n\t        // 2----3\n\t        //\n\t        // ---------------------d------\n\t\n\t        var lineZValue;\n\t        for (var level = 0; level < nbLevels * 2; level++) { // multiply by 2 for positif and negatif\n\t            var contourLevel = {};\n\t            contourLevels.push(contourLevel);\n\t            var side = level % 2;\n\t            if (side === 0) {\n\t                lineZValue = (maxZ - 5 * noise) * Math.exp(level / 2 - nbLevels) + 5 * noise;\n\t            } else {\n\t                lineZValue = -(maxZ - 5 * noise) * Math.exp(level / 2 - nbLevels) - 5 * noise;\n\t            }\n\t            var lines = [];\n\t            contourLevel.zValue = lineZValue;\n\t            contourLevel.lines = lines;\n\t\n\t            if (lineZValue <= minZ || lineZValue >= maxZ) continue;\n\t\n\t            for (var iSubSpectra = 0; iSubSpectra < nbSubSpectra - 1; iSubSpectra++) {\n\t                for (var povar = 0; povar < nbPovars - 1; povar++) {\n\t                    povarHeight[0] = z[iSubSpectra][povar];\n\t                    povarHeight[1] = z[iSubSpectra][povar + 1];\n\t                    povarHeight[2] = z[(iSubSpectra + 1)][povar];\n\t                    povarHeight[3] = z[(iSubSpectra + 1)][(povar + 1)];\n\t\n\t                    for (var i = 0; i < 4; i++) {\n\t                        isOver[i] = (povarHeight[i] > lineZValue);\n\t                    }\n\t\n\t                    // Example povar0 is over the plane and povar1 and\n\t                    // povar2 are below, we find the varersections and add\n\t                    // the segment\n\t                    if (isOver[0] !== isOver[1] && isOver[0] !== isOver[2]) {\n\t                        pAx = povar + (lineZValue - povarHeight[0]) / (povarHeight[1] - povarHeight[0]);\n\t                        pAy = iSubSpectra;\n\t                        pBx = povar;\n\t                        pBy = iSubSpectra + (lineZValue - povarHeight[0]) / (povarHeight[2] - povarHeight[0]);\n\t                        lines.push(pAx * dx + x0, pAy * dy + y0, pBx * dx + x0, pBy * dy + y0);\n\t                    }\n\t                    if (isOver[3] !== isOver[1] && isOver[3] !== isOver[2]) {\n\t                        pAx = povar + 1;\n\t                        pAy = iSubSpectra + 1 - (lineZValue - povarHeight[3]) / (povarHeight[1] - povarHeight[3]);\n\t                        pBx = povar + 1 - (lineZValue - povarHeight[3]) / (povarHeight[2] - povarHeight[3]);\n\t                        pBy = iSubSpectra + 1;\n\t                        lines.push(pAx * dx + x0, pAy * dy + y0, pBx * dx + x0, pBy * dy + y0);\n\t                    }\n\t                    // test around the diagonal\n\t                    if (isOver[1] !== isOver[2]) {\n\t                        pAx = povar + 1 - (lineZValue - povarHeight[1]) / (povarHeight[2] - povarHeight[1]);\n\t                        pAy = iSubSpectra + (lineZValue - povarHeight[1]) / (povarHeight[2] - povarHeight[1]);\n\t                        if (isOver[1] !== isOver[0]) {\n\t                            pBx = povar + 1 - (lineZValue - povarHeight[1]) / (povarHeight[0] - povarHeight[1]);\n\t                            pBy = iSubSpectra;\n\t                            lines.push(pAx * dx + x0, pAy * dy + y0, pBx * dx + x0, pBy * dy + y0);\n\t                        }\n\t                        if (isOver[2] !== isOver[0]) {\n\t                            pBx = povar;\n\t                            pBy = iSubSpectra + 1 - (lineZValue - povarHeight[2]) / (povarHeight[0] - povarHeight[2]);\n\t                            lines.push(pAx * dx + x0, pAy * dy + y0, pBx * dx + x0, pBy * dy + y0);\n\t                        }\n\t                        if (isOver[1] !== isOver[3]) {\n\t                            pBx = povar + 1;\n\t                            pBy = iSubSpectra + (lineZValue - povarHeight[1]) / (povarHeight[3] - povarHeight[1]);\n\t                            lines.push(pAx * dx + x0, pAy * dy + y0, pBx * dx + x0, pBy * dy + y0);\n\t                        }\n\t                        if (isOver[2] !== isOver[3]) {\n\t                            pBx = povar + (lineZValue - povarHeight[2]) / (povarHeight[3] - povarHeight[2]);\n\t                            pBy = iSubSpectra + 1;\n\t                            lines.push(pAx * dx + x0, pAy * dy + y0, pBx * dx + x0, pBy * dy + y0);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        // console.timeEnd('generateContourLines');\n\t        return {\n\t            minX: zData.minX,\n\t            maxX: zData.maxX,\n\t            minY: zData.minY,\n\t            maxY: zData.maxY,\n\t            segments: contourLevels\n\t        };\n\t        //return contourLevels;\n\t    }\n\t\n\t\n\t    function addLowRes(spectra, options) {\n\t        var spectrum;\n\t        var averageX, averageY;\n\t        var targetNbPoints = options.lowRes;\n\t        var highResData;\n\t        for (var i = 0; i < spectra.length; i++) {\n\t            spectrum = spectra[i];\n\t            // we need to find the current higher resolution\n\t            if (spectrum.data.length > 0) {\n\t                highResData = spectrum.data[0];\n\t                for (var j = 1; j < spectrum.data.length; j++) {\n\t                    if (spectrum.data[j].length > highResData.length) {\n\t                        highResData = spectrum.data[j];\n\t                    }\n\t                }\n\t\n\t                if (targetNbPoints > (highResData.length / 2)) return;\n\t                var i, ii;\n\t                var lowResData = [];\n\t                var modulo = Math.ceil(highResData.length / (targetNbPoints * 2));\n\t                for (i = 0, ii = highResData.length; i < ii; i = i + 2) {\n\t                    if (i % modulo === 0) {\n\t                        lowResData.push(highResData[i], highResData[i + 1])\n\t                    }\n\t                }\n\t                spectrum.data.push(lowResData);\n\t            }\n\t        }\n\t    }\n\t\n\t    return convert;\n\t\n\t}\n\t\n\tvar convert = getConverter();\n\t\n\tfunction JcampConverter(input, options, useWorker) {\n\t    if (typeof options === 'boolean') {\n\t        useWorker = options;\n\t        options = {};\n\t    }\n\t    if (useWorker) {\n\t        return postToWorker(input, options);\n\t    } else {\n\t        return convert(input, options);\n\t    }\n\t}\n\t\n\tvar stamps = {},\n\t    worker;\n\t\n\tfunction postToWorker(input, options) {\n\t    if (!worker) {\n\t        createWorker();\n\t    }\n\t    return new Promise(function (resolve) {\n\t        var stamp = Date.now() + '' + Math.random();\n\t        stamps[stamp] = resolve;\n\t        worker.postMessage({stamp: stamp, input: input, options: options});\n\t    });\n\t}\n\t\n\tfunction createWorker() {\n\t    var workerURL = URL.createObjectURL(new Blob([\n\t        'var getConverter =' + getConverter.toString() + ';var convert = getConverter(); onmessage = function (event) { postMessage({stamp: event.data.stamp, output: convert(event.data.input, event.data.options)}); };'\n\t    ], {type: 'application/javascript'}));\n\t    worker = new Worker(workerURL);\n\t    URL.revokeObjectURL(workerURL);\n\t    worker.addEventListener('message', function (event) {\n\t        var stamp = event.data.stamp;\n\t        if (stamps[stamp]) {\n\t            stamps[stamp](event.data.output);\n\t        }\n\t    });\n\t}\n\t\n\tmodule.exports = {\n\t    convert: JcampConverter\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar SD = __webpack_require__(1);\n\tvar PeakPicking = __webpack_require__(5);\n\tvar JcampConverter=__webpack_require__(3);\n\t\n\tfunction NMR(sd) {\n\t    SD.call(this, sd); // Héritage\n\t}\n\t\n\tNMR.prototype = Object.create(SD.prototype);\n\tNMR.prototype.constructor = NMR;\n\t\n\tNMR.fromJcamp = function(jcamp,options) {\n\t    options = options || {xy:true,keepSpectra:true,keepRecordsRegExp:/^.+$/};\n\t    var spectrum= JcampConverter.convert(jcamp,options);\n\t    return new NMR(spectrum);\n\t}\n\t\n\t/**\n\t* Return the observed nucleus \n\t*/\n\tNMR.prototype.getNucleus=function(dim){\n\t    if(!dim||dim==0)\n\t        return this.sd.xType;\n\t    else{\n\t        return \"\";\n\t    }\n\t}\n\t\n\t/**\n\t* Returns the solvent name\n\t*/\n\tNMR.prototype.getSolventName=function(){\n\t    return (this.sd.info[\".SOLVENTNAME\"]||this.sd.info[\"$SOLVENT\"]||\"\").replace(\"<\",\"\").replace(\">\",\"\");\n\t}\n\t\n\t//Returns the observe frequency in the direct dimension\n\tNMR.prototype.observeFrequencyX=function(){\n\t    return this.sd.spectra[0].observeFrequency;\n\t}\n\t\n\t/**\n\t* Returns the noise factor depending on the nucleus.\n\t*/\n\tNMR.prototype.getNMRPeakThreshold=function(nucleus) {\n\t    if (nucleus == \"1H\")\n\t        return 3.0;\n\t    if (nucleus ==\"13C\")\n\t        return 5.0;\n\t    return 1.0;\n\t}\n\t\n\t\n\t    \n\t/**\n\t * @function addNoise(SNR)\n\t * This function adds white noise to the the given spectraData. The intensity of the noise is \n\t * calculated from the given signal to noise ratio.\n\t * @param SNR Signal to noise ratio\n\t */\n\t NMR.prototype.addNoise=function(SNR) {\n\t     //@TODO Implement addNoise filter\n\t}\n\t\n\t\n\t/**\n\t * @function addSpectraDatas(spec2,factor1,factor2,autoscale )   \n\t *  This filter performs a linear combination of two spectraDatas.\n\t * A=spec1\n\t * B=spec2\n\t * After to apply this filter you will get:\n\t *      A=A*factor1+B*factor2\n\t * if autoscale is set to 'true' then you will obtain:\n\t *  A=A*factor1+B*k*factor2\n\t * Where the k is a factor such that the maximum peak in A is equal to the maximum peak in spectraData2 \n\t * @param spec2 spectraData2\n\t * @param factor1 linear factor for spec1\n\t * @param factor2 linear factor for spec2\n\t * @param autoscale Auto-adjust scales before combine the spectraDatas\n\t * @example spec1 = addSpectraDatas(spec1,spec2,1,-1, false) This subtract spec2 from spec1\n\t*/\n\tNMR.prototype.addSpectraDatas=function(spec2,factor1,factor2,autoscale ) {\n\t    //@TODO Implement addSpectraDatas filter\n\t}\n\t\n\t/**\n\t * @function autoBaseline()\n\t * Automatically corrects the base line of a given spectraData. After this process the spectraData\n\t * should have meaningful integrals.\n\t */\n\tNMR.prototype.autoBaseline=function( ) {\n\t    //@TODO Implement autoBaseline filter\n\t}\n\t\n\t/**\n\t * @function fourierTransform()\n\t * Fourier transforms the given spectraData (Note. no 2D handling yet) this spectraData have to be of type NMR_FID or 2DNMR_FID\n\t */\n\tNMR.prototype.fourierTransform=function( ) {\n\t    //@TODO Implement fourierTransform filter\n\t}\n\t\n\t/**\n\t * @function postFourierTransform(ph1corr)\n\t * This filter makes an phase 1 correction that corrects the problem of the spectra that has been obtained \n\t * on spectrometers using the Bruker digital filters. This method is used in cases when the BrukerSpectra \n\t * filter could not find the correct number of points to perform a circular shift.\n\t * The actual problem is that not all of the spectra has the necessary parameters for use only one method for \n\t * correcting the problem of the Bruker digital filters.\n\t * @param spectraData A fourier transformed spectraData.\n\t * @param ph1corr Phase 1 correction value in radians.\n\t */\n\tNMR.prototype.postFourierTransform=function(ph1corr) {\n\t    //@TODO Implement postFourierTransform filter\n\t}\n\t\n\t/**\n\t * @function zeroFilling(nPointsX [,nPointsY])\n\t * This function increase the size of the spectrum, filling the new positions with zero values. Doing it one \n\t * could increase artificially the spectral resolution.\n\t * @param nPointsX Number of new zero points in the direct dimension\n\t * @param nPointsY Number of new zero points in the indirect dimension\n\t */\n\tNMR.prototype.zeroFilling=function(nPointsX, nPointsY) {\n\t    //@TODO Implement zeroFilling filter\n\t}\n\t\n\t/**\n\t * @function  haarWhittakerBaselineCorrection(waveletScale,whittakerLambda)\n\t * Applies a baseline correction as described in J Magn Resonance 183 (2006) 145-151 10.1016/j.jmr.2006.07.013\n\t * The needed parameters are the wavelet scale and the lambda used in the whittaker smoother.\n\t * @param waveletScale To be described\n\t * @param whittakerLambda To be described\n\t */\n\tNMR.prototype.haarWhittakerBaselineCorrection=function(waveletScale,whittakerLambda) {\n\t    //@TODO Implement haarWhittakerBaselineCorrection filter\n\t}\n\t\n\t/**\n\t * @function whittakerBaselineCorrection(whittakerLambda,ranges)\n\t * Applies a baseline correction as described in J Magn Resonance 183 (2006) 145-151 10.1016/j.jmr.2006.07.013\n\t * The needed parameters are the Wavelet scale and the lambda used in the Whittaker smoother.\n\t * @param waveletScale To be described\n\t * @param whittakerLambda To be described\n\t * @param ranges A string containing the ranges of no signal.\n\t */\n\tNMR.prototype.whittakerBaselineCorrection=function(whittakerLambda,ranges) {\n\t    //@TODO Implement whittakerBaselineCorrection filter\n\t}\n\t\n\t/**\n\t * @function brukerSpectra(options)\n\t * This filter applies a circular shift(phase 1 correction in the time domain) to an NMR FID spectrum that \n\t * have been obtained on spectrometers using the Bruker digital filters. The amount of shift depends on the \n\t * parameters DECIM and DSPFVS. This spectraData have to be of type NMR_FID\n\t * @option DECIM: Acquisition parameter\n\t * @option DSPFVS: Acquisition parameter\n\t */\n\tNMR.prototype.brukerSpectra=function(options) {\n\t    //@TODO Implement brukerSpectra filter\n\t}\n\t\n\t/**\n\t * @function apodization(functionName, lineBroadening)\n\t * Apodization of a spectraData object.\n\t * @param spectraData An spectraData of type NMR_FID\n\t * @param functionName Valid values for functionsName are\n\t *  Exponential, exp\n\t *  Hamming, hamming\n\t *  Gaussian, gauss\n\t *  TRAF, traf\n\t *  Sine Bell, sb\n\t *  Sine Bell Squared, sb2\n\t * @param lineBroadening The parameter LB should either be a line broadening factor in Hz \n\t * or alternatively an angle given by degrees for sine bell functions and the like.\n\t * @example SD.apodization(, lineBroadening)\n\t */\n\tNMR.prototype.apodization=function(functionName, lineBroadening) {\n\t    //@TODO Implement apodization filter\n\t}\n\t\n\t/**\n\t * @function echoAntiechoFilter();\n\t * That decodes an Echo-Antiecho 2D spectrum.\n\t */\n\tNMR.prototype.echoAntiechoFilter=function() {\n\t    //@TODO Implement echoAntiechoFilter filter\n\t}\n\t\n\t/**\n\t * @function SNVFilter()\n\t * This function apply a Standard Normal Variate Transformation over the given spectraData. Mainly used for IR spectra.\n\t */\n\tNMR.prototype.SNVFilter=function() {\n\t    //@TODO Implement SNVFilter\n\t}\n\t\n\t/**\n\t * @function powerFilter(power)\n\t * This function applies a power to all the Y values.<br>If the power is less than 1 and the spectrum has negative values, it will be shifted so that the lowest value is zero \n\t * @param   power   The power to apply\n\t */\n\tNMR.prototype.powerFilter=function(power) {\n\t    var minY=this.getMinY();\n\t    if(power<1 && minY<0){\n\t        this.YShift(-1*minY);\n\t        console.warn(\"SD.powerFilter: The spectrum had negative values and was automatically shifted before applying the function.\");\n\t    }\n\t    //@TODO Implement powerFilter\n\t}\n\t\n\t/**\n\t * @function logarithmFilter(base)\n\t * This function applies a log to all the Y values.<br>If the spectrum has negative or zero values, it will be shifted so that the lowest value is 1 \n\t * @param   base    The base to use\n\t */\n\tNMR.prototype.logarithmFilter=function(base) {\n\t    var minY=this.getMinY();\n\t    if(minY<=0){\n\t        this.YShift((-1*minY)+1);\n\t        console.warn(\"SD.logarithmFilter: The spectrum had negative values and was automatically shifted before applying the function.\");\n\t    }\n\t   //@TODO Implement logarithmFilter filter\n\t}\n\t\n\t\n\t/**\n\t * @function correlationFilter(func) \n\t * This function correlates the given spectraData with the given vector func. The correlation\n\t * operation (*) is defined as:\n\t * \n\t *                    __ inf\n\t *  c(x)=f(x)(*)g(x)= \\        f(x)*g(x+i)\n\t *                   ./    \n\t *                    -- i=-inf\n\t * @param func A double array containing the function to correlates the spectraData\n\t * @example var smoothedSP = SD.correlationFilter(spectraData,[1,1]) returns a smoothed version of the\n\t * given spectraData. \n\t */\n\tNMR.prototype.correlationFilter=function(func) {\n\t    //@TODO Implement correlationFilter filter\n\t}\n\t\n\t/**\n\t * @function  phaseCorrection(phi0, phi1)\n\t * Applies the phase correction (phi0,phi1) to a Fourier transformed spectraData. The angles must be given in radians.\n\t * @param phi0 Zero order phase correction\n\t * @param phi1 One order phase correction\n\t*/\n\tNMR.prototype.phaseCorrection=function(phi0, phi1) {\n\t    //@TODO Implement phaseCorrection filter\n\t}\n\t\n\t/**\n\t * @function automaticPhase() \n\t * This function determines automatically the correct parameters phi0 and phi1 for a phaseCorrection\n\t * function and applies it.\n\t */ \n\tNMR.prototype.automaticPhase=function() {\n\t    //@TODO Implement automaticPhase filter\n\t}\n\t\n\t/**\n\t *  @function useBrukerPhase()\n\t *  This function extract the parameters of the phaseCorrection from the jcamp-dx parameters\n\t *  if the spectrum was acquired in Bruker spectrometers . Basically it will look for the parameters\n\t *  $PHC0 and $PHC1, and will use it to call the phaseCorrection function.\n\t */\n\tNMR.prototype.useBrukerPhase=function() {\n\t   //@TODO Implement useBrukerPhase filter\n\t}\n\t\n\t/**\n\t * @function nmrPeakDetection(parameters);\n\t * This function process the given spectraData and tries to determine the NMR signals. Returns an NMRSignal1D array containing all the detected 1D-NMR Signals\n\t * @param parameters A JSONObject containing the optional parameters:\n\t * @option fromX:   Lower limit.\n\t * @option toX:     Upper limit.\n\t * @option threshold: The minimum intensity to consider a peak as a signal, expressed as a percentage of the highest peak. \n\t * @option stdev: Number of standard deviation of the noise for the threshold calculation if a threshold is not specified.\n\t */\n\tNMR.prototype.nmrPeakDetection=function(parameters) {\n\t    return PeakPicking.peakPicking(this, parameters);\n\t}\n\t\n\t/**\n\t * @function toJcamp(options)\n\t * This function creates a String that represents the given spectraData in the format JCAM-DX 5.0\n\t * The X,Y data can be compressed using one of the methods described in: \n\t * \"JCAMP-DX. A STANDARD FORMAT FOR THE EXCHANGE OF ION MOBILITY SPECTROMETRY DATA\", \n\t *  http://www.iupac.org/publications/pac/pdf/2001/pdf/7311x1765.pdf\n\t * @option encode: ['FIX','SQZ','DIF','DIFDUP','CVS','PAC'] (Default: 'FIX')\n\t * @option yfactor: The YFACTOR. It allows to compress the data by removing digits from the ordinate. (Default: 1)\n\t * @option type: [\"NTUPLES\", \"SIMPLE\"] (Default: \"SIMPLE\")\n\t * @option keep: A set of user defined parameters of the given SpectraData to be stored in the jcamp.\n\t * @example SD.toJcamp(spectraData,{encode:'DIFDUP',yfactor:0.01,type:\"SIMPLE\",keep:['#batchID','#url']});\n\t */ \n\tNMR.prototype.toJcamp=function(options) {\n\t     //@TODO Implement toJcamp filter\n\t     return \"NOT ImplementED\"\n\t}\n\t\n\t\n\tmodule.exports = NMR;\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Implementation of the peak pickig method described by Cobas in:\n\t * A new approach to improving automated analysis of proton NMR spectra\n\t * through Global Spectral Deconvolution (GSD)\n\t * http://www.spectroscopyeurope.com/images/stories/ColumnPDFs/TD_23_1.pdf\n\t */\n\tvar JAnalyzer = __webpack_require__(6);\n\tvar LM = __webpack_require__(7);\n\tvar Matrix = LM.Matrix;\n\tvar math = Matrix.algebra;\n\t//var math = require('mathjs')\n\tvar PeakPicking={\n\t    impurities:[],\n\t    maxJ:20,\n\t\n\t    peakPicking:function(spectrum, options){\n\t        options = options||{nH:10, clean:true, realTop:false, thresholdFactor:1, compile:true, integral:0}\n\t\n\t        var nH=options.nH||10;\n\t        var i, j, nHi, sum;\n\t        //options.realTop = options.realTop||false;\n\t        //options.thresholdFactor = options.thresholdFactor || 1;\n\t        //options.compile = options.compile || false;\n\t        //options.clean = options.clean || false;\n\t        //var tmp = spectrum.clone();\n\t        var noiseLevel = Math.abs(spectrum.getNoiseLevel())*(options.thresholdFactor||1);\n\t        var peakList = this.GSD(spectrum, noiseLevel);\n\t        peakList = this.optmizeSpectrum(peakList,spectrum,noiseLevel);\n\t\n\t        var signals = this.detectSignals(peakList, spectrum, nH, options.integral||0);\n\t\n\t        //Remove all the signals with small integral\n\t        if(options.clean||false){\n\t            for(var i=signals.length-1;i>=0;i--){\n\t                if(signals[i].integralData.value<0.5) {\n\t                    signals.splice(i, 1);\n\t                }\n\t            }\n\t        }\n\t        if(options.compile||false){\n\t            for(i=0;i<signals.length;i++){\n\t                JAnalyzer.compilePattern(signals[i]);\n\t                if(signals[i].maskPattern&&signals[i].multiplicity!=\"m\"\n\t                    && signals[i].multiplicity!=\"\"){\n\t                    //Create a new signal with the removed peaks\n\t                    nHi = 0;\n\t                    sum=0;\n\t                    var peaksO = [];\n\t                    for(j=signals[i].maskPattern.length-1;j>=0;j--){\n\t                        sum+=this.area(signals[i].peaks[j]);\n\t                        if(signals[i].maskPattern[j]===false) {\n\t                            var peakR = signals[i].peaks.splice(j)[0];\n\t                            peaksO.push([peakR.x,peakR.intensity,peakR.width]);\n\t                            signals[i].maskPattern.splice(j);\n\t                            signals[i].peaksComp.splice(j);\n\t                            signals[i].nbPeaks--;\n\t                            nHi+=this.area(peakR);\n\t                        }\n\t                    }\n\t\n\t                    if(peaksO.length>0){\n\t                        nHi=nHi*signals[i].integralData.value/sum;\n\t                        signals[i].integralData.value-=nHi;\n\t                        var peaks1 = [];\n\t                        for(var j=peaksO.length-1;j>=0;j--)\n\t                            peaks1.push(peaksO[j]);\n\t                        var newSignals = this.detectSignals(peaks1, spectrum, nHi, options.integral||0);\n\t                        for(j=0;j<newSignals.length;j++)\n\t                            signals.push(newSignals[j]);\n\t                    }\n\t                }\n\t            }\n\t            this.updateIntegrals(signals, nH);\n\t        }\n\t        signals.sort(function(a,b){\n\t            return a.delta1- b.delta1\n\t        });\n\t\n\t        //Remove all the signals with small integral\n\t        if(options.clean||false){\n\t            for(var i=signals.length-1;i>=0;i--){\n\t                if(signals[i].integralData.value<0.5) {\n\t                    signals.splice(i, 1);\n\t                }\n\t            }\n\t        }\n\t\n\t        return signals;\n\t\n\t        /*var frequency = spectrum.observeFrequencyX();//getParamDouble(\"$BF1\",400);\n\t        var imp = this.labelPeaks(peakList, solvent, frequency);\n\t        return [peakList,imp];\n\t        */\n\t        //return createSignals(peakList,nH);\n\t    },\n\t\n\t    optmizeSpectrum: function(peakList, spectrum, noiseLevel){\n\t        var frequency = spectrum.observeFrequencyX();\n\t        var group = [];\n\t        var groups = [];\n\t        var nL = 4, i, j;\n\t        var limits = [peakList[0][0],nL*peakList[0][2]];\n\t        var upperLimit, lowerLimit;\n\t        //Merge forward\n\t        for(i=0;i<peakList.length;i++){\n\t            //If the 2 things overlaps\n\t            //console.log(peakList[i]+\" - \"+limits);\n\t            if(Math.abs(peakList[i][0]-limits[0])<(nL*peakList[i][2]+limits[1])){\n\t                //console.log(\"Here\");\n\t                //Add the peak to the group\n\t                group.push(peakList[i]);\n\t                //Update the group limits\n\t                upperLimit = limits[0]+limits[1];\n\t                if(peakList[i][0]+nL*peakList[i][2]>upperLimit){\n\t                    upperLimit = peakList[i][0]+nL*peakList[i][2];\n\t                }\n\t                lowerLimit = limits[0]-limits[1];\n\t                if(peakList[i][0]-nL*peakList[i][2]<lowerLimit){\n\t                    lowerLimit = peakList[i][0]-nL*peakList[i][2];\n\t                }\n\t                //console.log(limits);\n\t                limits = [(upperLimit+lowerLimit)/2,Math.abs(upperLimit-lowerLimit)/2];\n\t                //console.log(limits);\n\t            }\n\t            else{\n\t                groups.push({limits:limits,group:group});\n\t                //var optmimalPeak = fitSpectrum(group,limits,spectrum);\n\t                group=[peakList[i]];\n\t                limits = [peakList[i][0],nL*peakList[i][2]];\n\t            }\n\t        }\n\t        groups.push({limits:limits,group:group});\n\t        //Merge backward\n\t        for(i =groups.length-2;i>=0;i--){\n\t            //The groups overlaps\n\t            if(Math.abs(groups[i].limits[0]-groups[i+1].limits[0])<\n\t                (groups[i].limits[1]+groups[i+1].limits[1])/2){\n\t                for(j=0;j<groups[i+1].group.length;j++){\n\t                    groups[i].group.push(groups[i+1].group[j]);\n\t                }\n\t                upperLimit = groups[i].limits[0]+groups[i].limits[1];\n\t                if(groups[i+1].limits[0]+groups[i+1].limits[1]>upperLimit){\n\t                    upperLimit = groups[i+1].limits[0]+groups[i+1].limits[1];\n\t                }\n\t                lowerLimit = groups[i].limits[0]-groups[i].limits[1];\n\t                if(groups[i+1].limits[0]-groups[i+1].limits[1]<lowerLimit){\n\t                    lowerLimit = groups[i+1].limits[0]-groups[i+1].limits[1];\n\t                }\n\t                //console.log(limits);\n\t                groups[i].limits = [(upperLimit+lowerLimit)/2,Math.abs(upperLimit-lowerLimit)/2];\n\t\n\t                groups.splice(i+1,1);\n\t            }\n\t\n\t        }\n\t        var result = [];\n\t        var index = 0;\n\t        for(i =0;i<groups.length;i++){\n\t            //console.log(i+\" \"+groups[i].limits);\n\t            //if(Math.abs(groups[i].limits[0]-3.1)<0.1){\n\t                var optmimalPeaks = this.fitSpectrum(groups[i].group,groups[i].limits,spectrum);\n\t                for(j=0;j<optmimalPeaks.length;j++){\n\t                    if(optmimalPeaks[j][1]>noiseLevel){\n\t                        result.push(optmimalPeaks[j]);\n\t                    }\n\t                }\n\t            //}\n\t            //index++;\n\t        }\n\t        return result;\n\t\n\t    },\n\t\n\t    fitSpectrum: function(group,limits,spectrum){\n\t        var xy = this.sampling(spectrum, group,false);\n\t\n\t        //This function calculates the spectrum as a sum of lorentzian functions. The Lorentzian\n\t        //parameters are divided in 3 batches. 1st: centers; 2nd: heights; 3th: widths;\n\t        var lm_func = function(t,p,c){\n\t            var nL = p.length/3,factor,i, j,p2, cols = t.rows;\n\t            var tmp = new Matrix(t.length,1), result = new Matrix(t.length,1);\n\t            for(j=0;j<cols;j++){\n\t                result[j][0]=0;\n\t            }\n\t            for(i=0;i<nL;i++){\n\t                p2 = Math.pow(p[i+nL*2][0],2);\n\t                factor = p[i+nL][0]*p2;\n\t                for(j=0;j<cols;j++){\n\t                    result[j][0]+=factor/(Math.pow(t[j][0]-p[i][0],2)+p2);\n\t                }\n\t            }\n\t            return result;\n\t        };\n\t\n\t\n\t        var nbPoints = xy[0].length;\n\t        var t = new Matrix(nbPoints,1);//independent variable\n\t        var y_data = new Matrix(nbPoints,1);\n\t        var maxY = 0,i;\n\t        for(i=0;i<nbPoints;i++){\n\t            t[i][0]=xy[0][i][0];\n\t            y_data[i][0]=xy[1][i][0];\n\t            if(y_data[i][0]>maxY)\n\t                maxY = y_data[i][0];\n\t        }\n\t        for(i=0;i<nbPoints;i++){\n\t            y_data[i][0]/=maxY\n\t        }\n\t        var weight = [nbPoints / math.sqrt(y_data.dot(y_data))];\n\t        //console.log(\"weight: \"+weight+\" \"+nbPoints );\n\t        var opts = [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ];\n\t        var consts = [ ];// optional vector of constants\n\t\n\t        var nL = group.length;\n\t        var p_init = new Matrix(nL*3,1);\n\t        var p_min =  new Matrix(nL*3,1);\n\t        var p_max =  new Matrix(nL*3,1);\n\t        for( i=0;i<nL;i++){\n\t            p_init[i][0] = group[i][0];\n\t            p_init[i+nL][0] = group[i][1]/maxY;\n\t            p_init[i+2*nL][0] = group[i][2]/2;\n\t\n\t            p_min[i][0] = group[i][0]-0.0025;\n\t            p_min[i+nL][0] = 0;\n\t            p_min[i+2*nL][0] = group[i][2]/8;\n\t\n\t            p_max[i][0] = group[i][0]+0.0025;\n\t            p_max[i+nL][0] = group[i][1]*1.3/maxY;\n\t            p_max[i+2*nL][0] = group[i][2]*2;\n\t        }\n\t        //console.log(p_init);\n\t        //console.log(\"y1=\"+JSON.stringify(lm_func(t,p_init,consts)));\n\t        var p_fit = LM.optimize(lm_func,p_init,t,y_data,weight,-0.00005,p_min,p_max,consts,opts);\n\t\n\t        //Put back the result in the correct format\n\t        var result = new Array(nL);\n\t        for( i=0;i<nL;i++){\n\t            result[i]=[p_fit[i][0],p_fit[i+nL][0]*maxY,p_fit[i+2*nL][0]*2];\n\t        }\n\t        //console.log(p_init);\n\t        //console.log(p_fit);\n\t        /*console.log(\"x=\"+JSON.stringify(t));\n\t        console.log(\"y=\"+JSON.stringify(y_data));\n\t        console.log(\"y0=\"+JSON.stringify(lm_func(t,p_fit,consts)));\n\t        console.log(\"y1=\"+JSON.stringify(lm_func(t,p_init,consts)));\n\t        console.log(\"plot(x,y,'r*');hold;plot(x,y0,'b');plot(x,y1,'g');\");*/\n\t        //console.log(p_init)\n\t        //console.log(p_fit);\n\t        return result;\n\t\n\t    },\n\t    /**\n\t     * This method implements a non linear sampling of the spectrum. The point close to\n\t     * the critic points are more sampled than the other ones.\n\t     * @param spectrum\n\t     * @param peaks\n\t     * @param rowWise\n\t     */\n\t    sampling: function(spectrum, peaks, rowWise){\n\t        var i0, ie, ic,i, j,nbPoints;\n\t        var xy = []\n\t        if(i0>ie){\n\t            var tmp = i0;\n\t            i0 = ie;\n\t            ie = tmp;\n\t        }\n\t        //Non linear sampling for each peak.\n\t        for(i=0;i<peaks.length;i++){\n\t            var more = true;\n\t            var nL = 4;\n\t            while(more) {\n\t                i0 = spectrum.unitsToArrayPoint(peaks[i][0] - peaks[i][2] * nL);\n\t                ie = spectrum.unitsToArrayPoint(peaks[i][0] + peaks[i][2] * nL);\n\t                ic = spectrum.unitsToArrayPoint(peaks[i][0]);\n\t                if (i0 > ie) {\n\t                    tmp = i0;\n\t                    i0 = ie;\n\t                    ie = tmp;\n\t                }\n\t                i0 = i0 < 0 ? 0 : i0;\n\t                ie = ie >= spectrum.getNbPoints() ? spectrum.getNbPoints() - 1 : ie;\n\t\n\t                if (ie - i0 < 10) {\n\t                    for (j = i0; j <= ie; j++) {\n\t                        xy.push([spectrum.getX(j), spectrum.getY(j)]);\n\t                    }\n\t                    more = false;\n\t                }\n\t                else {\n\t                    xy.push([spectrum.getX(i0), spectrum.getY(i0)]);\n\t                    xy.push([spectrum.getX(ie), spectrum.getY(ie)]);\n\t                    if (nL > 0.5) {\n\t                        nL -= 0.5;\n\t                    }\n\t                    else {\n\t                        nL /= 2;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        //console.log(xy);\n\t        xy.sort(function(a,b){\n\t            return a[0]-b[0];\n\t        });\n\t        //console.log(\"XX \"+xy.length);\n\t        var x=[],y=[];\n\t        var index =0;\n\t        if(rowWise){\n\t            x=[xy[0][0]],y=[xy[0][1]];\n\t            for(i=1;i<xy.length;i++){\n\t                if(x[index]!=xy[i][0]){\n\t                    x.push(xy[i][0]);\n\t                    y.push(xy[i][1]);\n\t                    index++;\n\t                }\n\t            }\n\t        }\n\t        else{\n\t            x=[[xy[0][0]]],y=[[xy[0][1]]];\n\t            for(i=1;i<xy.length;i++){\n\t                if(x[index][0]!=xy[i][0]){\n\t                    x.push([xy[i][0]]);\n\t                    y.push([xy[i][1]]);\n\t                    index++;\n\t                }\n\t            }\n\t        }\n\t        return [x,y];\n\t\n\t    },\n\t\n\t    getVector: function(spectrum, from, to, rowWise){\n\t        var i0 = spectrum.unitsToArrayPoint(from);\n\t        var ie = spectrum.unitsToArrayPoint(to);\n\t        var x = [];\n\t        var y = [];\n\t        if(i0>ie){\n\t            var tmp = i0;\n\t            i0 = ie;\n\t            ie = tmp;\n\t        }\n\t        i0=i0<0?0:i0;\n\t        ie=ie>=spectrum.getNbPoints()?spectrum.getNbPoints()-1:ie;\n\t        for(var i=i0;i<ie;i+=10){\n\t            if(rowWise){\n\t                y.push(spectrum.getY(i));\n\t                x.push(spectrum.getX(i));\n\t            }\n\t            else{\n\t                y.push([spectrum.getY(i)]);\n\t                x.push([spectrum.getX(i)]);\n\t            }\n\t        }\n\t        return [x,y];\n\t    },\n\t\n\t\n\t\n\t    updateLimits : function(signal){\n\t        if(signal.multiplicity!=\"m\" && signal.multiplicity!=\"\"){\n\t            //Remove the integral of the removed peaks\n\t            var peaksO = signal.peaks;\n\t            var nbPeaks0 = peaksO.length, index = 0, factor = 0, toRemove = 0;\n\t\n\t            for(var i=0;i<nbPeaks0;i++){\n\t                if(signal.maskPattern[i]===false)\n\t                    toRemove+=this.area(peaksO[i]);\n\t                factor+= this.area(peaksO[i]);\n\t            }\n\t            factor=signal.integralData.value/factor;\n\t            signal.integralData.value-=toRemove*factor;\n\t        }\n\t        return signal.integralData.value;\n\t    },\n\t\n\t    updateIntegrals : function(signals, nH){\n\t        var sumIntegral = 0,i,sumObserved=0;\n\t        for(i=0;i<signals.length;i++){\n\t            sumObserved+=Math.round(signals[i].integralData.value);\n\t        }\n\t        if(sumObserved!=nH){\n\t\n\t            sumIntegral=nH/sumObserved;\n\t            for(i=0;i<signals.length;i++){\n\t                signals[i].integralData.value*=sumIntegral;\n\t            }\n\t        }\n\t    },\n\t\n\t    realTopDetection: function(peakList, spectrum){\n\t        var listP = [];\n\t        var alpha, beta, gamma, p,currentPoint;\n\t        for(j=0;j<peakList.length;j++){\n\t            currentPoint = spectrum.unitsToArrayPoint(peakList[j][0]);\n\t            //The detected peak could be moved 1 or 2 unit to left or right.\n\t            if(spectrum.getY(currentPoint-1)>=spectrum.getY(currentPoint-2)\n\t                &&spectrum.getY(currentPoint-1)>=spectrum.getY(currentPoint)) {\n\t                currentPoint--;\n\t            }\n\t            else{\n\t                if(spectrum.getY(currentPoint+1)>=spectrum.getY(currentPoint)\n\t                    &&spectrum.getY(currentPoint+1)>=spectrum.getY(currentPoint+2)) {\n\t                    currentPoint++;\n\t                }\n\t                else{\n\t                    if(spectrum.getY(currentPoint-2)>=spectrum.getY(currentPoint-3)\n\t                        &&spectrum.getY(currentPoint-2)>=spectrum.getY(currentPoint-1)) {\n\t                        currentPoint-=2;\n\t                    }\n\t                    else{\n\t                        if(spectrum.getY(currentPoint+2)>=spectrum.getY(currentPoint+1)\n\t                            &&spectrum.getY(currentPoint+2)>=spectrum.getY(currentPoint+3)) {\n\t                            currentPoint+=2;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            if(spectrum.getY(currentPoint-1)>0&&spectrum.getY(currentPoint+1)>0\n\t                &&spectrum.getY(currentPoint)>=spectrum.getY(currentPoint-1)\n\t                &&spectrum.getY(currentPoint)>=spectrum.getY(currentPoint+1)) {\n\t                alpha = 20 * Math.log10(spectrum.getY(currentPoint - 1));\n\t                beta = 20 * Math.log10(spectrum.getY(currentPoint));\n\t                gamma = 20 * Math.log10(spectrum.getY(currentPoint + 1));\n\t                p = 0.5 * (alpha - gamma) / (alpha - 2 * beta + gamma);\n\t\n\t                peakList[j][0] = spectrum.arrayPointToUnits(currentPoint + p);\n\t                peakList[j][1] = spectrum.getY(currentPoint) - 0.25 * (spectrum.getY(currentPoint - 1)\n\t                    - spectrum.getY(currentPoint + 1)) * p;//signal.peaks[j].intensity);\n\t\n\t            }\n\t        }\n\t    },\n\t\n\t    /**\n\t     * Should we read the impurities table from somewhere else?\n\t     */\n\t    init:function(){\n\t        this.impurities = [{\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":7.26}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.56}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.1}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.17}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.1}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.36}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.28}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.19},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.22}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.98},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.01},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.27},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.43}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.26}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.43}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.73}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.3}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.21},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.48}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.65},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.57},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.39}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.4},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.55}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.09},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.02},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.94}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":8.02},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.96},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.88}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.62}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.71}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.25},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.72},{\"proton\":\"OH\",\"coupling\":5,\"multiplicity\":\"s,t\",\"shift\":1.32}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.05},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.12},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.26}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.14},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.46},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.06}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.76}],\"name\":\"ethylene_glycol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":0.86},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"br_s\",\"shift\":1.26}],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.88},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.26}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.65}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.49},{\"proton\":\"OH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.09}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.33}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":7},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.27}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.22},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":4.04}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.62},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.29},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.68}],\"name\":\"pyridine\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.07}],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.85},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.76}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.36},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.17},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.25}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.03},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.53}],\"name\":\"triethylamine\"}],\"solvent\":\"CDCl3\"},{\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":2.05}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.84}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.96}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.09}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.05}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.36}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.18}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.13},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.13}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.96},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.22},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.41}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":8.02}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.43}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.87}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.63}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.11},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.41}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.56},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.47},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.28}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.28},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.46}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.97},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.83}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.96},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.94},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.78}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.52}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.59}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.12},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.57},{\"proton\":\"OH\",\"coupling\":5,\"multiplicity\":\"s,t\",\"shift\":3.39}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.97},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.05},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.2}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.07},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.45},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.28}],\"name\":\"ethylene_glycol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":0.87},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"br_s\",\"shift\":1.29}],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.88},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.28}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.59}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.31},{\"proton\":\"OH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.12}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.43}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.88},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.27}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.1},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":3.9}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.58},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.35},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.76}],\"name\":\"pyridine\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.13}],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.79},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.63}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.32},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.5},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.5}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.45}],\"name\":\"triethylamine\"}],\"solvent\":\"(CD3)2CO\"},{\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":2.5}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.33}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.91}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.09}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.07}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.37}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.11},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.19}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.11},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.08}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.87},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.65},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.18},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.36}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":8.32}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.4}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.9}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.76}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.09},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.38}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.51},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.38},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.24}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.24},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.43}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.96},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.94},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.78}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.95},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.89},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.73}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.54}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.57}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.06},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.44},{\"proton\":\"OH\",\"coupling\":5,\"multiplicity\":\"s,t\",\"shift\":4.63}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.99},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.03},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.17}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.07},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.43},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.91}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.34}],\"name\":\"ethylene_glycol\"},{\"shifts\":[],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.86},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.25}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.53}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.16},{\"proton\":\"OH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.01}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.42}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.88},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.27}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.04},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":3.78}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.58},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.39},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.79}],\"name\":\"pyridine\"},{\"shifts\":[],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.76},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.6}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.3},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.18},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.25}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.93},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.43}],\"name\":\"triethylamine\"}],\"solvent\":\"(CD3)2SO/DMSO\"},{\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":7.16}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.4}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.55}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.55}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.55}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.15}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.05},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.55}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.07},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.04}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.05},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.79},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.24},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.38}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.15}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.4}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.9}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.27}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.11},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.26}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.46},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.34},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.11}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.12},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.33}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.6},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.57},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.05}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.63},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.36},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.86}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.68}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.35}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.34}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.65},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.89},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.92}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.58},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":1.81},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.85}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.41}],\"name\":\"ethylene_glycol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":0.92},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"br_s\",\"shift\":1.36}],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.89},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.24}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.4}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.07}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.94}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.86},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.23}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":0.95},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":3.67}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.53},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":6.66},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":6.98}],\"name\":\"pyridine\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.29}],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.4},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.57}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.11},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.02},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.13}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.4}],\"name\":\"triethylamine\"}],\"solvent\":\"C6D6\"},{\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":1.94}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.13}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.96}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.08}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.96}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.37}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.16},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.18}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.14},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.13}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.97},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.2},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.22},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.39}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.58}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.44}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.81}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.44}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.12},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.42}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.53},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.45},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.29}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.28},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.45}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.97},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.96},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.83}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.92},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.89},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.77}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.5}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.6}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.12},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.54},{\"proton\":\"OH\",\"coupling\":5,\"multiplicity\":\"s,t\",\"shift\":2.47}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.97},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.06},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.2}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.06},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.43},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.51}],\"name\":\"ethylene_glycol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":0.86},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"br_s\",\"shift\":1.27}],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.89},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.28}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.57}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.28},{\"proton\":\"OH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.16}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.31}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.87},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.29}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.09},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":3.87}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.57},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.33},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.73}],\"name\":\"pyridine\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.08}],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.8},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.64}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.33},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.2},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.2}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.45}],\"name\":\"triethylamine\"}],\"solvent\":\"CD3CN\"},{\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":3.31}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.87}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.99}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.15}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.03}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.33}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.4}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.15},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.2}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.92},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.21},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.4}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.9}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.45}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.78}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.49}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.18},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.49}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.61},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.58},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.35}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.35},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.52}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.07},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.31},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.92}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.97},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.99},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.86}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.65}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.66}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.19},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.6}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.01},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.09},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.24}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.12},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.5},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.01}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.59}],\"name\":\"ethylene_glycol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":0.88},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"br_s\",\"shift\":1.29}],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.9},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.29}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.64}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.34}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.34}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.89},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.29}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.5},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":3.92}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.53},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.44},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.85}],\"name\":\"pyridine\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.1}],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.87},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.71}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.32},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.16},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.16}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.05},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.58}],\"name\":\"triethylamine\"}],\"solvent\":\"CD3OD\"},{\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":4.79}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.08}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.22}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.06}],\"name\":\"acetonitrile\"},{\"shifts\":[],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.24}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.21},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.22}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[],\"name\":\"BHTb\"},{\"shifts\":[],\"name\":\"chloroform\"},{\"shifts\":[],\"name\":\"cyclohexane\"},{\"shifts\":[],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.17},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.56}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.67},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.61},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.37}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.37},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.6}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.08},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.06},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.9}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.92},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.01},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.85}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.71}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.75}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.17},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.65}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.07},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.14},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.24}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.19},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.18},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.26}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.65}],\"name\":\"ethylene_glycol\"},{\"shifts\":[],\"name\":\"grease^f\"},{\"shifts\":[],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.61}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.34}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.4}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.9}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.17},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":4.02}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.52},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.45},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.87}],\"name\":\"pyridine\"},{\"shifts\":[],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.88},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.74}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.99},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.57}],\"name\":\"triethylamine\"}],\"solvent\":\"D2O\"}];\n\t        //this.impurities = API.getVar(\"impurities\").getValue();\n\t        //File.parse(\"solvent1H.txt\", {header:false});\n\t        //console.log(this.impurities[0]);\n\t    },\n\t    /*\n\t     {\n\t     \"nbPeaks\":1,\"multiplicity\":\"\",\"units\":\"PPM\",\"startX\":3.43505,\"assignment\":\"\",\n\t     \"pattern\":\"s\",\"stopX\":3.42282,\"observe\":400.08,\"asymmetric\":false,\n\t     \"delta1\":3.42752,\n\t     \"integralData\":{\"to\":3.43505,\"value\":590586504,\"from\":3.42282},\n\t     \"nucleus\":\"1H\",\n\t     \"peaks\":[{\"intensity\":60066147,\"x\":3.42752}]\n\t     }\n\t     */\n\t    detectSignals: function(peakList, spectrum, nH, integralType){\n\t        var frequency = spectrum.observeFrequencyX();\n\t        var signals = [];\n\t        var signal1D = {};\n\t        var prevPeak = [100000,0],peaks=null;\n\t        var rangeX = 16/frequency;//Peaks withing this range are considered to belongs to the same signal1D\n\t        var spectrumIntegral = 0,cs,sum, i,j;\n\t        for(i=0;i<peakList.length;i++){\n\t            //console.log(i+\" \"+peakList[i]);\n\t            if(Math.abs(peakList[i][0]-prevPeak[0])>rangeX){\n\t                signal1D = {\"nbPeaks\":1,\"units\":\"PPM\",\n\t                    \"startX\":peakList[i][0]+peakList[i][2],\n\t                    \"stopX\":peakList[i][0]-peakList[i][2],\n\t                    \"multiplicity\":\"\",\"pattern\":\"\",\n\t                    \"observe\":frequency,\"nucleus\":\"1H\",\n\t                    \"integralData\":{\"from\":peakList[i][0]-peakList[i][2]*3,\n\t                                    \"to\":peakList[i][0]+peakList[i][2]*3\n\t                                    //\"value\":this.area(peakList[i])\n\t                    },\n\t                    \"peaks\":[]};\n\t                signal1D.peaks.push({x:peakList[i][0],\"intensity\":peakList[i][1], width:peakList[i][2]});\n\t                signals.push(signal1D);\n\t                //spectrumIntegral+=this.area(peakList[i]);\n\t            }\n\t            else{\n\t                var tmp = peakList[i][0]-peakList[i][2];\n\t                signal1D.stopX=Math.min(signal1D.stopX,tmp);\n\t                tmp = peakList[i][0]+peakList[i][2];\n\t                signal1D.stopX=Math.max(signal1D.stopX,tmp);\n\t                signal1D.nbPeaks++;\n\t                signal1D.peaks.push({x:peakList[i][0],\"intensity\":peakList[i][1], width:peakList[i][2]});\n\t                //signal1D.integralData.value+=this.area(peakList[i]);\n\t                signal1D.integralData.from=Math.min(signal1D.integralData.from, peakList[i][0]-peakList[i][2]*3);\n\t                signal1D.integralData.to=Math.max(signal1D.integralData.to,peakList[i][0]+peakList[i][2]*3);\n\t                //spectrumIntegral+=this.area(peakList[i]);\n\t            }\n\t            prevPeak = peakList[i];\n\t        }\n\t        //Normalize the integral to the normalization parameter and calculate cs\n\t        for(i=0;i<signals.length;i++){\n\t            peaks = signals[i].peaks;\n\t            var integral = signals[i].integralData;\n\t            cs = 0;\n\t            sum = 0;\n\t            for(var j=0;j<peaks.length;j++){\n\t                cs+=peaks[j].x*this.area(peaks[j]);//.intensity;\n\t                sum+=this.area(peaks[j]);\n\t            }\n\t            signals[i].delta1 = cs/sum;\n\t\n\t            if(integralType==0)\n\t                integral.value = sum;\n\t            else {\n\t                integral.value=spectrum.getArea(integral.from,integral.to);//*nH/spectrumIntegral;\n\t            }\n\t            spectrumIntegral+=integral.value;\n\t\n\t        }\n\t        for(var i=0;i<signals.length;i++){\n\t            //console.log(integral.value);\n\t            var integral = signals[i].integralData;\n\t            integral.value*=nH/spectrumIntegral;\n\t        }\n\t\n\t        return signals;\n\t    },\n\t\n\t    area: function(peak){\n\t        return Math.abs(peak.intensity*peak.width*1.57)//1.772453851);\n\t    },\n\t    /**\n\t     This function tries to determine which peaks belongs to common laboratory solvents\n\t     as trace impurities from DOI:10.1021/jo971176v. The only parameter of the table is\n\t     the solvent name.\n\t     */\n\t    labelPeaks:function(peakList, solvent, frequency){\n\t        var column = 0;\n\t        //console.log(this.impurities[0]);\n\t        for(column=4;column<this.impurities.length;column++){\n\t            //console.log(\"sss\".contains);\n\t            if(this.impurities[0][column].indexOf(solvent)>=0){\n\t                break;\n\t            }\n\t        }\n\t        //console.log(\"labelPeaks \"+column);\n\t        var nImpurities = this.impurities.length-1;\n\t        var nPeaks = peakList.length;\n\t        //Scores matrix\n\t        //console.log(nImpurities);\n\t        var scores = new Array(nImpurities);\n\t        var max = 0, diff=0, score=0;\n\t        var gamma = 0.2;//ppm\n\t        var impurityID=-1;\n\t        var prevImp = \"\";\n\t        var maxIntensity = 0,i;\n\t        for(var j=nPeaks-1;j>=0;j--){\n\t            if(peakList[j][1]>maxIntensity)\n\t                maxIntensity = peakList[j][1];\n\t        }\n\t\n\t        for(i=nImpurities-1;i>=0;i--){\n\t            if(this.impurities[i+1][0]!=prevImp){\n\t                impurityID++;\n\t                prevImp=this.impurities[i+1][0];\n\t            }\n\t\n\t            //impID, max, maxIndex, average\n\t            scores[i]=[impurityID,this.impurities[i+1][2],\n\t                this.impurities[i+1][3],0,[],0];\n\t            max = 0;\n\t            for(var j=nPeaks-1;j>=0;j--){\n\t                diff = 10000;//Big numnber\n\t                if(this.impurities[i+1][column]>0)\n\t                    diff = Math.abs(peakList[j][0]-this.impurities[i+1][column]);\n\t                if(diff<gamma*3){\n\t                    score=this.score(diff,gamma);\n\t                    if(score>max){\n\t                        max=score;\n\t                        scores[i][3]=max;\n\t                        scores[i][4]=[j];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        //Calculate the average score for each impurity set of signals\n\t        var prevIndex = -1, sum=0, count = 0;\n\t        var candidates=[];\n\t        var impuritiesPeaks = [];\n\t        var i=nImpurities-1;\n\t        while(i>=-1){\n\t            if(i==-1||scores[i][0]!=prevIndex&&prevIndex!=-1){\n\t                if(prevIndex!=-1){\n\t                    scores[i+1][5]=sum/count;\n\t                    //Now, lets chech the multiplicities\n\t                    if(scores[i+1][5]>0.9){\n\t                        //console.log(scores[i+1][0]+\" SS \");\n\t                        score=this.updateScore(candidates, peakList, maxIntensity, frequency);\n\t                        if(score>0.9){\n\t                            //console.log(candidates);\n\t                            //TODO: Remove peaks and add it do impuritiesPeaks\n\t                            for(var j=0;j<candidates.length;j++){\n\t                                for(var k=candidates[j][4].length-1;k>=0;k--){\n\t                                    impuritiesPeaks.push(peakList[candidates[j][4][k]]);\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t                if(i>=0){\n\t                    prevIndex=scores[i][0];\n\t                    sum=scores[i][3];\n\t                    count=1;\n\t                    candidates=[scores[i]];\n\t                }\n\t\n\t            }else{\n\t                prevIndex=scores[i][0];\n\t                candidates.push(scores[i]);\n\t                sum+=scores[i][3];\n\t                count++;\n\t            }\n\t            i--;\n\t        }\n\t        //console.log(impuritiesPeaks.length);\n\t\n\t        return impuritiesPeaks;\n\t    },\n\t    /**\n\t     Updates the score that a given impurity is present in the current spectrum. In this part I would expect\n\t     to have into account the multiplicity of the signal. Also the relative intensity of the signals.\n\t     THIS IS the KEY part of the algorithm!!!!!!!!!\n\t     */\n\t    updateScore:function(candidates, peakList, maxIntensity, frequency){\n\t        //You may do it to avoid this part.\n\t        //return 1;\n\t\n\t        //Check the multiplicity\n\t        var mul = \"\";\n\t        var j = 0,index, k, maxJppm=this.maxJ/frequency;\n\t        var min=0, indexMin=0, score=0;\n\t        for(var i=candidates.length-1;i>=0;i--){\n\t            mul = candidates[i][1];\n\t            j = candidates[i][2];\n\t            //console.log(candidates[i][4]);\n\t            index = candidates[i][4][0];\n\t            //console.log(peakList[index][0]+\" \"+mul+\" \"+j+\" \"+index);\n\t            //I guess we should try to identify the pattern in the nearby.\n\t            if(mul.indexOf(\"sep\")>=0){\n\t                if(peakList[index][1]>maxIntensity*0.33){\n\t                    candidates.splice(i,1);//Not a candidate anymore.\n\t                }\n\t            }else{\n\t                if(mul.indexOf(\"s\")>=0||mul.indexOf(\"X\")>=0){\n\t                    k=index-1;\n\t                    min=peakList[index][1];\n\t                    indexMin=index;\n\t                    while(k>=0&&Math.abs(peakList[index][0]-peakList[k][0])<0.025){\n\t                        if(peakList[k][1]<min){\n\t                            min=peakList[k][1];\n\t                            indexMin=k;\n\t                        }\n\t                        k--;\n\t                    }\n\t                    k=index+1;\n\t                    while(k<peakList.length&&Math.abs(peakList[index][0]-peakList[k][0])<0.025){\n\t                        if(peakList[k][1]<min){\n\t                            min=peakList[k][1];\n\t                            indexMin=k;\n\t                        }\n\t                        k++;\n\t                    }\n\t                    candidates[i][4][0]=indexMin;\n\t                    score+=1;\n\t                }\n\t            }\n\t            if(mul.indexOf(\"d\")>=0){\n\t                if(index>0&&index<peakList.length-1){\n\t                    var thisJ1 = Math.abs(Math.abs(peakList[index-1][0]-peakList[index][0])*frequency-j);\n\t                    var thisJ2 = Math.abs(Math.abs(peakList[index+1][0]-peakList[index][0])*frequency-j);\n\t                    var thisJ3 = Math.abs(Math.abs(peakList[index+1][0]-peakList[index-1][0])*frequency-j);\n\t                    if(thisJ1<2||thisJ2<2||thisJ3<2){\n\t                        if(thisJ1<thisJ2){\n\t                            if(thisJ1<thisJ3){\n\t                                candidates[i][4]=[index-1,index];\n\t                                score+=1;\n\t                            }\n\t                            else{\n\t                                candidates[i][4]=[index-1,index+1];\n\t                                score+=1;\n\t                            }\n\t                        }\n\t                        else{\n\t                            if(thisJ2<thisJ3){\n\t                                candidates[i][4]=[index,index+1];\n\t                                score+=1;\n\t                            }\n\t                            else{\n\t                                candidates[i][4]=[index-1,index+1];\n\t                                score+=1;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            if(mul.indexOf(\"t\")>=0){\n\t                //console.log(\"here\");\n\t                if(index>0&&index<peakList.length-1){\n\t                    var thisJ1 = Math.abs(Math.abs(peakList[index-1][0]-peakList[index][0])*frequency-j);\n\t                    var thisJ2 = Math.abs(Math.abs(peakList[index+1][0]-peakList[index][0])*frequency-j);\n\t                    var thisJ4 = Math.abs(Math.abs(peakList[index+1][0]-peakList[index+2][0])*frequency-j);\n\t                    //console.log(\"XX \"+thisJ1+\" \"+thisJ2);\n\t                    if(thisJ1<2){\n\t                        candidates[i][4]=[index-1, index];\n\t                        score+=0.5;\n\t                    }\n\t                    if(thisJ2<2){\n\t                        candidates[i][4].push(index+1);\n\t                        score+=0.5;\n\t                    }\n\t                    if(thisJ3<2){\n\t                        candidates[i][4].push(index+2);\n\t                        score+=0.5;\n\t                    }\n\t\n\t                }\n\t            }\n\t            if(mul.indexOf(\"q\")>=0){\n\t                if(index>1&&index<peakList.length-2){\n\t                    var thisJ1 = Math.abs(Math.abs(peakList[index-2][0]-peakList[index-1][0])*frequency-j);\n\t                    var thisJ2 = Math.abs(Math.abs(peakList[index-1][0]-peakList[index][0])*frequency-j);\n\t                    var thisJ3 = Math.abs(Math.abs(peakList[index+1][0]-peakList[index][0])*frequency-j);\n\t                    var thisJ4= Math.abs(Math.abs(peakList[index+2][0]-peakList[index+1][0])*frequency-j);\n\t                    if(thisJ1<2){\n\t                        candidates[i][4].push(index-2);\n\t                        score+=0.25;\n\t                    }\n\t                    if(thisJ2<2){\n\t                        candidates[i][4].push(index-1);\n\t                        score+=0.25;\n\t                    }\n\t                    if(thisJ3<2){\n\t                        candidates[i][4].push(index+1);\n\t                        score+=0.25;\n\t                    }\n\t                    if(thisJ4<2){\n\t                        candidates[i][4].push(index+2);\n\t                        score+=0.25;\n\t                    }\n\t                }\n\t            }\n\t\n\t\n\t        }\n\t\n\t        //console.log(score/candidates.length+ \" -> \"+candidates);\n\t        //Lets remove the candidates to be impurities.\n\t        //It would be equivalent to mark the peaks as valid again\n\t        if(score/candidates.length < 0.5){\n\t            for(var i=candidates.length-1;i>=0;i--){\n\t                candidates.splice(i,1);\n\t            }\n\t            return 0;\n\t        }\n\t        //Check the relative intensity\n\t        return 1;\n\t    },\n\t\n\t    score:function(value, gamma){\n\t        return Math.exp(-Math.pow(value/gamma,2)/2.0);\n\t    },\n\t    /**\n\t     This function joint all the nearby peaks into single signals. We may try to\n\t     determine the J-couplings and the multiplicity here.\n\t     */\n\t    createSignals:function(){\n\t\n\t    },\n\t    /**\n\t     Determine the peaks of the spectrum by applying a global spectrum deconvolution.\n\t     */\n\t    GSD:function(spectrum, noiseLevel){\n\t        var data= spectrum.getXYData();\n\t        var y = new Array(data[1].length);\n\t        var x = data[0];\n\t        var frequencyX = spectrum.observeFrequencyX();\n\t        var rangeX = 16/frequency;//Peaks withing this range are considered to belongs to the same signal1D\n\t        //Lets remove the noise for better performance\n\t        for(var i=y.length-1;i>=0;i--){\n\t            y[i]=data[1][i];\n\t            if(Math.abs(y[i])<noiseLevel)\n\t                y[i]=0;\n\t        }\n\t\n\t        var dx = x[1]-x[0];\n\t        // fill convolution frequency axis\n\t        var X = [];//x[2:(x.length-2)];\n\t\n\t        // fill Savitzky-Golay polynomes\n\t        var Y = new Array();\n\t        var dY = new Array();\n\t        var ddY = new Array();\n\t        for (var j = 2; j < x.length -2; j++){\n\t            Y.push((1/35.0)*(-3*y[j-2] + 12*y[j-1] + 17*y[j] + 12*y[j+1] - 3*y[j+2]));\n\t            X.push(x[j]);\n\t            dY.push((1/(12*dx))*(y[j-2] - 8*y[j-1] + 8*y[j+1] - y[j+2]));\n\t            ddY.push((1/(7*dx*dx))*(2*y[j-2] - y[j-1] - 2*y[j] - y[j+1] + 2*y[j+2]));\n\t        }\n\t        // pushs max and min points in convolution functions\n\t        var stackInt = new Array();\n\t        var intervals = new Array();\n\t        var minddY = new Array();\n\t        var maxDdy=0;\n\t        //console.log(Y.length);\n\t        for (var i = 0; i < Y.length ; i++){\n\t            if(Math.abs(ddY[i])>maxDdy){\n\t                maxDdy = Math.abs(ddY[i]);\n\t            }\n\t        }\n\t        //console.log(maxY+\"x\"+maxDy+\"x\"+maxDdy);\n\t        var broadMask = new Array();\n\t        for (var i = 1; i < Y.length -1 ; i++){\n\t            if ((dY[i] < dY[i-1]) && (dY[i] <= dY[i+1])||\n\t                (dY[i] <= dY[i-1]) && (dY[i] < dY[i+1])) {\n\t                stackInt.push(X[i]);\n\t            }\n\t\n\t            if ((dY[i] >= dY[i-1]) && (dY[i] > dY[i+1])||\n\t                (dY[i] > dY[i-1]) && (dY[i] >= dY[i+1])) {\n\t                try{\n\t                    intervals.push( [X[i] , stackInt.pop()] );\n\t                }\n\t                catch(e){\n\t                    console.log(\"Error I don't know why \"+e);\n\t                }\n\t            }\n\t            if ((ddY[i] < ddY[i-1]) && (ddY[i] < ddY[i+1])) {\n\t                minddY.push( [X[i], Y[i], i] );\n\t                if(Math.abs(ddY[i])>0.0025*maxDdy){\n\t                    broadMask.push(false);\n\t                }\n\t                else{\n\t                    broadMask.push(true);\n\t                }\n\t            }\n\t        }\n\t        // creates a list with (frecuency, linewith, height)\n\t        dx = Math.abs(dx);\n\t        //var signalsS = new Array();\n\t        var signals = new Array();\n\t        var broadLines=[[[Number.MAX_VALUE,0,0]]];\n\t        Y.sort(function(a, b){return a-b});\n\t        for (var j = 0; j < minddY.length; j++){\n\t            var f = minddY[j];\n\t            var frequency = f[0];\n\t            var possible = new Array();\n\t            for (var k=0;k<intervals.length;k++){\n\t                var i = intervals[k];\n\t                if (frequency > i[0] && frequency < i[1])\n\t                    possible.push(i);\n\t            }\n\t            //console.log(\"possible \"+possible.length);\n\t            if (possible.length > 0)\n\t                if (possible.length == 1)\n\t                {\n\t                    var inter = possible[0];\n\t                    var linewidth = Math.abs(inter[1] - inter[0]);\n\t                    var height = f[1];\n\t                    if (Math.abs(height) > 0.00025*Y[0]){\n\t                        if(!broadMask[j]){\n\t                            signals.push([frequency, height, linewidth]);\n\t                            //signalsS.push([frequency, height]);\n\t                        }\n\t                        else{\n\t                            broadLines.push([frequency, height, linewidth]);\n\t                        }\n\t                    }\n\t                }\n\t                else\n\t                {\n\t                    //TODO: nested peaks\n\t                    console.log(\"Nested \"+possible);\n\t                }\n\t        }\n\t        //console.log(signalsS);\n\t        //Optimize the possible broad lines\n\t        var max=0, maxI=0,count=0;\n\t        var candidates = [],broadLinesS=[];\n\t        var isPartOf = false;\n\t        var rangeX = 16/frequencyX;\n\t        for(var i=broadLines.length-1;i>0;i--){\n\t            //console.log(broadLines[i][0]+\" \"+rangeX+\" \"+Math.abs(broadLines[i-1][0]-broadLines[i][0]));\n\t            if(Math.abs(broadLines[i-1][0]-broadLines[i][0])<rangeX){\n\t\n\t                candidates.push(broadLines[i]);\n\t                if(broadLines[i][1]>max){\n\t                    max = broadLines[i][1];\n\t                    maxI = i;\n\t                }\n\t                count++;\n\t            }\n\t            else{\n\t                isPartOf = true;\n\t                if(count>30){\n\t                    isPartOf = false;\n\t                    /*for(var j=0;j<signals.length;j++){\n\t                        if(Math.abs(broadLines[maxI][0]-signals[j][0])<rangeX)\n\t                            isPartOf = true;\n\t                    }\n\t                    console.log(\"Was part of \"+isPartOf);*/\n\t                }\n\t                if(isPartOf){\n\t                    for(var j=0;j<candidates.length;j++){\n\t                        signals.push([candidates[j][0], candidates[j][1], dx]);\n\t                    }\n\t                }\n\t                else{\n\t                    var fitted =  this.optimizeLorentzian(candidates);\n\t                    //console.log(fitted);\n\t                    signals.push(fitted);\n\t                    //signalsS.push([fitted[0], fitted[1]]);\n\t                    //console.log(fitted[0]+\" \"+fitted[2]+\" \"+fitted[1]);\n\t                    //broadLinesS.push([fitted[0], fitted[1]]);\n\t\n\t                }\n\t                candidates = [];\n\t                max = 0;\n\t                maxI = 0;\n\t                count = 0;\n\t            }\n\t        }\n\t        signals.sort(function (a, b) {\n\t            return a[0] - b[0];\n\t        });\n\t\n\t        return signals;\n\t        //jexport(\"peakPicking\",signalsS);\n\t    },\n\t\n\t    optimizeLorentzian:function(data){\n\t\n\t        var lm_func = function(t,p,c){\n\t            var factor = p[2][0]*Math.pow(p[1][0],2);\n\t            var rows = t.rows;\n\t            var result = new Matrix(t.rows, t.columns);\n\t            // var tmp = math.add(math.dotPow(math.subtract(t,p[0][0]),2),Math.pow(p[1][0],2));\n\t            for(var i=0;i<rows;i++){\n\t                result[i][0]=p[3][0]+factor/(Math.pow(t[i][0]-p[0][0],2)+Math.pow(p[1][0],2));\n\t            }\n\t\n\t            return result;\n\t        };\n\t\n\t\n\t        var nbPoints = data.length;\n\t        var t = new Matrix(nbPoints,1);\n\t\n\t        var y_data = new Matrix(nbPoints,1);\n\t        var sum = 0;\n\t        var maxY = 0;\n\t        for(var i=0;i<nbPoints;i++){\n\t            t[i][0]=data[i][0];\n\t            y_data[i][0]=data[i][1];\n\t            if(data[i][1]>maxY)\n\t                maxY = data[i][1];\n\t        }\n\t        //console.log(JSON.stringify(t));\n\t        //console.log(nbPoints);\n\t        for(var i=0;i<nbPoints;i++){\n\t            y_data[i][0]/=maxY\n\t        }\n\t        var weight = [nbPoints / math.sqrt(y_data.dot(y_data))];\n\t        //console.log(\"weight: \"+weight);\n\t        var opts = [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ];\n\t        var consts = [ ];                         // optional vector of constants\n\t\n\t        var p_init = new Matrix([[(t[0][0]+t[nbPoints-1][0])/2],[Math.abs(t[0][0]-t[nbPoints-1][0])/2],[1],[0]]);\n\t        var p_min = new Matrix([[t[0][0]],[0.0],[0],[0]]);\n\t        var p_max = new Matrix([[t[nbPoints-1][0]],[Math.abs(t[0][0]-t[nbPoints-1][0])],[1.5],[0.5]]);\n\t\n\t        var p_fit = LM.optimize(lm_func,p_init,t,y_data,weight,-0.01,p_min,p_max,consts,opts);\n\t\n\t        return [p_fit[0][0],p_fit[2][0]*maxY,p_fit[1][0]*2];\n\t    }\n\t}\n\t\n\tmodule.exports = PeakPicking;\n\t\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/**\n\t * This library implements the J analyser described by Cobas et al in the paper:\n\t * A two-stage approach to automatic determination of 1H NMR coupling constants\n\t * Created by acastillo on 4/5/15.\n\t */\n\tvar JAnalyzer = {\n\t    pascalTriangle : [[0],[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]],\n\t    patterns: [\"s\",\"d\",\"t\",\"q\",\"quint\",\"h\",\"sept\",\"o\",\"n\"],\n\t    symRatio : 1.5,\n\t    maxErrorIter1 : 2.5,//Hz\n\t    maxErrorIter2 : 1,//Hz\n\t    DEBUG : false,\n\t\n\t    /**\n\t     * The compilation process implements at the first stage a normalization procedure described by Golotvin et al.\n\t     * embedding in peak-component-counting method described by Hoyes et al.\n\t     * @param signal\n\t     */\n\t    compilePattern : function(signal){\n\t        if(this.DEBUG)console.log(\"Debugin...\");\n\t\n\t        signal.multiplicity=\"m\";//By default the multiplicity is massive\n\t        // 1.1 symmetrize\n\t        // It will add a set of peaks(signal.peaksComp) to the signal that will be used during\n\t        // the compilation process. The unit of those peaks will be in Hz\n\t        signal.symRank = this.symmetrizeChoiseBest(signal,this.maxErrorIter1,1);\n\t        signal.asymmetric = true;\n\t       // console.log(signal.delta1+\" \"+signal.symRank);\n\t        //Is the signal symmetric?\n\t        if(signal.symRank>=0.95&&signal.peaksComp.length<32){\n\t            if(this.DEBUG)console.log(signal.delta1+ \" nbPeaks \"+signal.peaksComp.length);\n\t            signal.asymmetric = false;\n\t            var i,j,min,max,k=1,P1,Jc=[],n2,maxFlagged;\n\t            //Loop over the possible number of coupling contributing to the multiplet\n\t            for(var n=0;n<9;n++){\n\t                if(this.DEBUG)console.log(\"Trying \"+n+\" couplings\");\n\t                //1.2 Normalize. It makes a deep copy of the peaks before to modify them.\n\t                peaks = this.normalize(signal,n);\n\t                //signal.peaksCompX = peaks;\n\t                var validPattern = false;//It will change to true, when we find the good patter\n\t                //Lets check if the signal could be a singulet.\n\t                if(peaks.length == 1 && n === 0){\n\t                    validPattern=true;\n\t                }\n\t                else{\n\t                    if(peaks.length <= 1){\n\t                        continue;\n\t                    }\n\t                }\n\t                // 1.3 Establish a range for the Heights Hi [peaks.intensity*0.85,peaks.intensity*1.15];\n\t                var ranges = this.getRanges(peaks);\n\t                n2 = Math.pow(2,n);\n\t\n\t                if(this.DEBUG){\n\t                    console.log(\"ranges: \"+JSON.stringify(ranges));\n\t                    console.log(\"Target sum: \"+n2);\n\t                }\n\t\n\t                // 1.4 Find a combination of integer heights Hi, one from each Si, that sums to 2^n.\n\t                var heights = null;\n\t                while(!validPattern&&(heights = this.getNextCombination(ranges, n2))!==null){\n\t\n\t                    if(this.DEBUG){\n\t                        console.log(\"Possible pattern found with \"+n+\" couplings!!!\");\n\t                        console.log(heights);\n\t                    }\n\t                    // 2.1 Number the components of the multiplet consecutively from 1 to 2n,\n\t                    //starting at peak 1\n\t                    var numbering = new Array(heights.length);\n\t                    k=1;\n\t                    for(i=0;i<heights.length;i++){\n\t                        numbering[i]=new Array(heights[i]);\n\t                        for(j=0;j<heights[i];j++){\n\t                            numbering[i][j]=k++;\n\t                        }\n\t                    }\n\t                    if(this.DEBUG){\n\t                        console.log(\"Numbering: \"+JSON.stringify(numbering));\n\t                    }\n\t                    Jc = []; //The array to store the detected j-coupling\n\t                    // 2.2 Set j = 1; J1 = P2 - P1. Flag components 1 and 2 as accounted for.\n\t                    j=1;\n\t                    Jc.push(peaks[1].x-peaks[0].x);\n\t                    P1 = peaks[0].x;\n\t                    numbering[0].splice(0,1);//Flagged\n\t                    numbering[1].splice(0,1);//Flagged\n\t                    k=1;\n\t                    var nFlagged = 2;\n\t                    maxFlagged = Math.pow(2,n)-1;\n\t                    while(Jc.length<n&&nFlagged<maxFlagged&&k<peaks.length){\n\t                        if(this.DEBUG){\n\t                            console.log(\"New Jc\"+JSON.stringify(Jc));\n\t                            console.log(\"Aval. numbering \"+JSON.stringify(numbering));\n\t                        }\n\t                        // 4.1. Increment j. Set k to the number of the first unflagged component.\n\t                        j++;\n\t                        while(k<peaks.length&&numbering[k].length===0){\n\t                            k++;\n\t                        }\n\t                        if(k<peaks.length){\n\t                            // 4.2 Jj = Pk - P1.\n\t                            Jc.push(peaks[k].x-peaks[0].x);\n\t                            //Flag component k and, for each sum of the...\n\t                            numbering[k].splice(0,1);//Flageed\n\t                            nFlagged++;\n\t                            //Flag the other components of the multiplet\n\t                            for(var u=2;u<=j;u++){\n\t                                //TODO improve those loops\n\t                                var jSum = 0;\n\t                                for(i=0;i<u;i++){\n\t                                    jSum+=Jc[i];\n\t                                }\n\t                                for(i=1;i<numbering.length;i++){\n\t                                    //Maybe 0.25 Hz is too much?\n\t                                    if(Math.abs(peaks[i].x-(P1+jSum))<0.25){\n\t                                        numbering[i].splice(0,1);//Flageed\n\t                                        nFlagged++;\n\t                                        break;\n\t                                    }\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t                    //Calculate the ideal patter by using the extracted j-couplings\n\t                    var pattern = this.idealPattern(Jc);\n\t                    //Compare the ideal pattern with the proposed intensities.\n\t                    // All the intensities have to match to accept the multiplet\n\t                    validPattern = true;\n\t                    for(i=0;i<pattern.length;i++){\n\t                        if(pattern[i].intensity != heights[i])\n\t                            validPattern = false;\n\t                    }\n\t                    //More verbosity of the process\n\t                    if(this.DEBUG){\n\t                        console.log(\"Jc \"+JSON.stringify(Jc));\n\t                        console.log(\"Heights \"+JSON.stringify(heights));\n\t                        console.log(\"pattern \"+JSON.stringify(pattern));\n\t                        console.log(\"Valid? \"+validPattern);\n\t                    }\n\t                }\n\t                //If we found a valid pattern we should inform about the pattern.\n\t                if(validPattern){\n\t                    this.updateSignal(signal,Jc);\n\t                }\n\t            }\n\t        }\n\t\n\t        //Before to return, change the units of peaksComp from Hz to PPM again\n\t        for(i=0;i<signal.peaksComp.length;i++){\n\t            signal.peaksComp[i].x/=signal.observe;\n\t        }\n\t    },\n\t\n\t    updateSignal : function(signal, Jc){\n\t        //Update the limits of the signal\n\t        var peaks = signal.peaksComp;//Always in Hz\n\t        var nbPeaks = peaks.length;\n\t        signal.startX=peaks[0].x/signal.observe+peaks[0].width;\n\t        signal.stopX=peaks[nbPeaks-1].x/signal.observe-peaks[nbPeaks-1].width;\n\t        signal.integralData.to=peaks[0].x/signal.observe+peaks[0].width*3;\n\t        signal.integralData.from=peaks[nbPeaks-1].x/signal.observe-peaks[nbPeaks-1].width*3;\n\t\n\t        //Compile the pattern and format the constant couplings\n\t        signal.maskPattern = signal.mask2;\n\t        signal.multiplicity = this.abstractPattern(signal,Jc);\n\t        signal.pattern=signal.multiplicity;//Our library depends on this parameter, but it is old\n\t        //console.log(signal);\n\t        if(this.DEBUG)\n\t            console.log(\"Final j-couplings: \"+JSON.stringify(Jc));\n\t    },\n\t\n\t    /**\n\t     * Returns the multiplet in the compact format\n\t     */\n\t    abstractPattern : function(signal,Jc){\n\t        var tol = 0.05,i, pattern = \"\", cont = 1;\n\t        var newNmrJs = [];\n\t        if(Jc&&Jc.length>0){\n\t            Jc.sort(function(a,b){\n\t                return a-b;\n\t            });\n\t            for(i=0;i<Jc.length-1;i++){\n\t                if(Math.abs(Jc[i]-Jc[i+1])<tol){\n\t                    cont++;\n\t                }\n\t                else{\n\t                    newNmrJs.push({\"coupling\":Math.abs(Jc[i]),\"multiplicity\":this.patterns[cont]});\n\t                    pattern+=this.patterns[cont];\n\t                    cont=1;\n\t                }\n\t            }\n\t            newNmrJs.push({\"coupling\":Math.abs(Jc[i]),\"multiplicity\":this.patterns[cont]});\n\t            pattern+=this.patterns[cont];\n\t            signal.nmrJs =  newNmrJs;\n\t        }\n\t        else{\n\t            pattern=\"s\";\n\t            if(Math.abs(signal.startX-signal.stopX)*signal.observe>16){\n\t                pattern=\"bs\"\n\t            }\n\t        }\n\t        return pattern;\n\t    },\n\t\n\t    /**\n\t     *This function creates an ideal pattern from the given J-couplings\n\t     */\n\t    idealPattern : function(Jc){\n\t        var hsum = Math.pow(2,Jc.length),i,j;\n\t        var pattern = [{x:0,intensity:hsum}];\n\t        //To split the initial height\n\t        for(i=0;i<Jc.length;i++){\n\t            for(j=pattern.length-1;j>=0;j--){\n\t                pattern.push({x:pattern[j].x+Jc[i]/2,\n\t                    intensity:pattern[j].intensity/2});\n\t                pattern[j].x = pattern[j].x-Jc[i]/2;\n\t                pattern[j].intensity = pattern[j].intensity/2;\n\t            }\n\t        }\n\t        //To sum the heights in the same positions\n\t        pattern.sort(function compare(a,b) { return a.x-b.x});\n\t        for(j=pattern.length-2;j>=0;j--){\n\t            if(Math.abs(pattern[j].x-pattern[j+1].x)<0.1){\n\t                pattern[j].intensity+= pattern[j+1].intensity\n\t                pattern.splice(j+1,1);\n\t            }\n\t        }\n\t        return pattern;\n\t    },\n\t\n\t    /**\n\t     * Find a combination of integer heights Hi, one from each Si, that sums to 2n.\n\t     */\n\t    getNextCombination : function(ranges, value){\n\t        var half = Math.ceil(ranges.values.length/2), lng = ranges.values.length;\n\t        var sum = 0,i;\n\t        while(sum!=value){\n\t            //Update the indexes to point at the next possible combination\n\t            ok = false;\n\t            var leftIndex = 0;\n\t            while(!ok){\n\t                ok = true;\n\t                ranges.currentIndex[ranges.active]++;\n\t                if(ranges.currentIndex[ranges.active]>=ranges.values[ranges.active].length){\n\t                    //In this case, there is no more possible combinations\n\t                    if(ranges.active+1==half){\n\t                        return null;\n\t                    }\n\t                    else{\n\t                        //If this happens we need to try the next active peak\n\t                        ranges.currentIndex[ranges.active]=0;\n\t                        ok=false;\n\t                        ranges.active++;\n\t                    }\n\t                }\n\t                else{\n\t                    ranges.active=0;\n\t                }\n\t            }\n\t            // Sum the heights for this combination\n\t            sum=0;\n\t            for(i=0;i<half;i++){\n\t                sum+= ranges.values[i][ranges.currentIndex[i]]*2;\n\t            }\n\t            if(ranges.values.length%2!==0){\n\t                sum-= ranges.values[half-1][ranges.currentIndex[half-1]];\n\t            }\n\t            if(this.DEBUG){\n\t                console.log(ranges.currentIndex);\n\t                console.log(sum+\" \"+value);\n\t            }\n\t        }\n\t        //If the sum is equal to the expected value, fill the array to return\n\t        if(sum==value){\n\t            var heights = new Array(lng);\n\t            for(i=0;i<half;i++){\n\t                heights[i] = ranges.values[i][ranges.currentIndex[i]];\n\t                heights[lng-i-1] = ranges.values[i][ranges.currentIndex[i]];\n\t            }\n\t            return heights;\n\t        }\n\t        return null;\n\t    },\n\t\n\t    /**\n\t     * This function generates the possible values that each peak can contribute\n\t     * to the multiplet.\n\t     * @param peaks\n\t     * @returns {{values: Array, currentIndex: Array, active: number}}\n\t     */\n\t    getRanges : function(peaks){\n\t        var ranges = new Array(peaks.length);\n\t        var currentIndex = new Array(peaks.length);\n\t        var min,max;\n\t        ranges[0] = [1];\n\t        ranges[peaks.length-1] = [1];\n\t        currentIndex[0]=-1;\n\t        currentIndex[peaks.length-1] = 0;\n\t        for(var i=1;i<peaks.length-1;i++){\n\t            min = Math.round(peaks[i].intensity*0.85);\n\t            max = Math.round(peaks[i].intensity*1.15);\n\t            ranges[i] =[];\n\t            for(var j=min;j<=max;j++){\n\t                ranges[i].push(j);\n\t            }\n\t            currentIndex[i]=0;\n\t        }\n\t        return {values:ranges, currentIndex:currentIndex, active:0};\n\t    },\n\t    /**\n\t     * Performs a symmetrization of the signal by using different aproximations to the center.\n\t     * It will return the result of the symmetrization that removes less peaks from the signal\n\t     * @param signal\n\t     * @param maxError\n\t     * @param iteration\n\t     * @returns {*}\n\t     */\n\t    symmetrizeChoiseBest : function(signal,maxError,iteration){\n\t        var symRank1 = this.symmetrize(signal,maxError,iteration);\n\t        var tmpPeaks = signal.peaksComp;\n\t        var tmpMask = signal.mask;\n\t        var cs = signal.delta1;\n\t        signal.delta1 = (signal.peaks[0].x+signal.peaks[signal.peaks.length-1].x)/2;\n\t        var symRank2 = this.symmetrize(signal,maxError,iteration);\n\t        if(signal.peaksComp.length>tmpPeaks.length)\n\t            return symRank2;\n\t        else{\n\t            signal.delta1 = cs;\n\t            signal.peaksComp = tmpPeaks;\n\t            signal.mask = tmpMask;\n\t            return symRank1;\n\t        }\n\t\n\t    },\n\t    /**\n\t     * This function will return a set of symmetric peaks that will\n\t     * be the enter point for the patter compilation process.\n\t     */\n\t    symmetrize : function(signal, maxError, iteration){\n\t        //Before to symmetrize we need to keep only the peaks that possibly conforms the multiplete\n\t        var max, min, avg, ratio, avgWidth;\n\t        var peaks = new Array(signal.peaks.length);\n\t        //Make a deep copy of the peaks and convert PPM ot HZ\n\t        for(j=0;j<peaks.length;j++){\n\t            peaks[j]= {x:signal.peaks[j].x*signal.observe,\n\t                intensity:signal.peaks[j].intensity,\n\t                width:signal.peaks[j].width};\n\t        }\n\t        //Join the peaks that are closer than 0.25 Hz\n\t        for(j=peaks.length-2;j>=0;j--){\n\t            if(Math.abs(peaks[j].x-peaks[j+1].x)<0.25){\n\t                peaks[j].x = (peaks[j].x*peaks[j].intensity+peaks[j+1].x*peaks[j+1].intensity);\n\t                peaks[j].intensity = peaks[j].intensity+peaks[j+1].intensity;\n\t                peaks[j].x/=peaks[j].intensity;\n\t                peaks[j].intensity/=2;\n\t                peaks[j].width+=peaks[j+1].width;\n\t                peaks.splice(j+1,1);\n\t            }\n\t        }\n\t        signal.peaksComp = peaks;\n\t        var nbPeaks = peaks.length;\n\t        var mask = new Array(nbPeaks);\n\t        signal.mask = mask;\n\t        var left=0, right=peaks.length-1, cs = signal.delta1*signal.observe, middle = [(peaks[0].x+peaks[nbPeaks-1].x)/2,1];\n\t        maxError = this.error(Math.abs(cs-middle[0]));\n\t        var heightSum = 0;\n\t        //We try to symmetrize the extreme peaks. We consider as candidates for symmetricing those which have\n\t        //ratio smaller than 3\n\t        for(var i=0;i<nbPeaks;i++){\n\t            mask[i]= true;\n\t            heightSum+=signal.peaks[i].intensity;\n\t        }\n\t\n\t        while(left<=right){\n\t            mask[left] = true;\n\t            mask[right] = true;\n\t            if(left==right){\n\t                if(nbPeaks>2&&Math.abs(peaks[left].x-cs)>maxError){\n\t                    mask[left] = false;\n\t                }\n\t            }\n\t            else{\n\t                max = Math.max(peaks[left].intensity,peaks[right].intensity);\n\t                min = Math.min(peaks[left].intensity,peaks[right].intensity);\n\t                ratio = max/min;\n\t                if(ratio>this.symRatio){\n\t                    if(peaks[left].intensity==min){\n\t                        mask[left] = false;\n\t                        right++;\n\t                    }\n\t                    else{\n\t                        mask[right] = false;\n\t                        left--;\n\t                    }\n\t                }\n\t                else{\n\t                    var diffL = Math.abs(peaks[left].x-cs);\n\t                    var diffR = Math.abs(peaks[right].x-cs);\n\t\n\t                    if(Math.abs(diffL-diffR)<maxError){\n\t                        //avg = (peaks[left].intensity+peaks[right].intensity)/2;\n\t                        avg = Math.min(peaks[left].intensity,peaks[right].intensity);\n\t                        avgWidth = Math.min(peaks[left].width,peaks[right].width);\n\t                        peaks[left].intensity=peaks[right].intensity=avg;\n\t                        peaks[left].width=peaks[right].width=avgWidth;\n\t                        middle=[middle[0]+((peaks[right].x+peaks[left].x)/2), middle[1]+1];\n\t                    }\n\t                    else{\n\t                        if(Math.max(diffL,diffR)==diffR){\n\t                            mask[right] = false;\n\t                            left--;\n\t                        }\n\t                        else{\n\t                            mask[left] = false;\n\t                            right++;\n\t                        }\n\t                    }\n\t                    if(this.DEBUG){\n\t                        console.log(\"MaxError: \"+maxError+\" \"+middle[0]+\" \"+middle[1]);\n\t                        console.log(iteration+\" CS: \"+cs+\" Hz \"+cs/signal.observe+\" PPM\");\n\t                        console.log(\"Middle: \"+(middle[0]/middle[1])+\" Hz \"+(middle[0]/middle[1])/signal.observe+\" PPM\");\n\t                        console.log(diffL+ \" \"+diffR);\n\t                        console.log(Math.abs(diffL-diffR));\n\t                        console.log(JSON.stringify(peaks));\n\t                        console.log(JSON.stringify(mask));\n\t                    }\n\t                }\n\t            }\n\t            left++;\n\t            right--;\n\t            //Only alter cs if it is the first iteration of the sym process.\n\t            if(iteration==1){\n\t                cs = this.chemicalShift(peaks, mask);\n\t                //There is not more available peaks\n\t                if(isNaN(cs)){ return 0;}\n\t            }\n\t            maxError = this.error(Math.abs(cs-middle[0]/middle[1]));\n\t        }\n\t        //To remove the weak peaks and recalculate the cs\n\t        for(i=nbPeaks-1;i>=0;i--){\n\t            if(mask[i]===false){\n\t                peaks.splice(i,1);\n\t            }\n\t        }\n\t        cs = this.chemicalShift(peaks);\n\t        if(isNaN(cs)){ return 0;}\n\t        signal.delta1 = cs/signal.observe;\n\t        //Now, the peak should be symmetric in heights, but we need to know if it is symmetric in x\n\t        var symFactor = 0,weight = 0;\n\t        if(peaks.length>1){\n\t            for(i=Math.ceil(peaks.length/2)-1;i>=0;i--){\n\t                symFactor+=(3+Math.min(Math.abs(peaks[i].x-cs),Math.abs(peaks[peaks.length-1-i].x-cs)))\n\t                /(3+Math.max(Math.abs(peaks[i].x-cs),Math.abs(peaks[peaks.length-1-i].x-cs)))*peaks[i].intensity;\n\t                weight+=peaks[i].intensity;\n\t            }\n\t            symFactor/=weight;\n\t        }\n\t        else{\n\t            if(peaks.length==1)\n\t                symFactor=1;\n\t        }\n\t        var newSumHeights = 0;\n\t        for(i=0;i<peaks.length;i++){\n\t            newSumHeights+=peaks[i].intensity;\n\t        }\n\t        symFactor-=(heightSum-newSumHeights)/heightSum*0.12; //Removed peaks penalty\n\t        if(this.DEBUG){\n\t            console.log(\"Penalty \"+(heightSum-newSumHeights)/heightSum*0.12);\n\t            console.log(\"cs: \"+(cs/signal.observe)+\" symFactor: \"+symFactor);\n\t        }\n\t        //Sometimes we need a second opinion after the first symmetrization.\n\t        if(symFactor>0.8&&symFactor<0.97&&iteration<2){\n\t            return this.symmetrize(signal, this.maxErrorIter2, 2);\n\t        }{\n\t            //Center the given pattern at cs and symmetrize x\n\t            if(peaks.length>1) {\n\t                var weight = 0, dxi;\n\t                for (i = Math.ceil(peaks.length / 2) - 1; i >= 0; i--) {\n\t                    dxi = (peaks[i].x - peaks[peaks.length - 1 - i].x)/2.0;\n\t                    peaks[i].x =cs+dxi;\n\t                    peaks[peaks.length - 1 - i].x=cs-dxi;\n\t                }\n\t            }\n\t        }\n\t        return symFactor;\n\t    },\n\t\n\t    error : function(value){\n\t        var maxError = value*2.5;\n\t        if(maxError<0.75)\n\t            maxError = 0.75;\n\t        if(maxError > 3)\n\t            maxError = 3;\n\t        return maxError;\n\t    },\n\t    /**\n\t     * 2 stages normalizarion of the peaks heights to Math.pow(2,n).\n\t     * Creates a new mask with the peaks that could contribute to the multiplete\n\t     * @param signal\n\t     * @param n\n\t     * @returns {*}\n\t     */\n\t    normalize : function(signal, n){\n\t        //Perhaps this is slow\n\t        var peaks = JSON.parse(JSON.stringify(signal.peaksComp));\n\t        var norm = 0,norm2=0,i;//Math.pow(2,n);\n\t        for(i=0;i<peaks.length;i++){\n\t            norm+= peaks[i].intensity;\n\t        }\n\t        norm=Math.pow(2,n)/norm;\n\t        signal.mask2 = JSON.parse(JSON.stringify(signal.mask));\n\t        //console.log(\"Mask0 \"+JSON.stringify(signal.mask2));\n\t        var index=signal.mask2.length-1;\n\t        for(i=peaks.length-1;i>=0;i--){\n\t            peaks[i].intensity*= norm;\n\t            while(index>=0&&signal.mask2[index]===false)\n\t                index--;\n\t            if(peaks[i].intensity<0.75){\n\t                if(this.DEBUG)\n\t                    console.log(\"Peak \"+i+\" does not seem to belong to this multiplet \"+peaks[i].intensity);\n\t                peaks.splice(i,1);\n\t                signal.mask2[index]=false;\n\t            }\n\t            else{\n\t                norm2+= peaks[i].intensity;\n\t            }\n\t            index--;\n\t        }\n\t        norm2=Math.pow(2,n)/norm2;\n\t        for(i=peaks.length-1;i>=0;i--){\n\t            peaks[i].intensity*= norm2;\n\t        }\n\t        //console.log(\"Mask1 \"+JSON.stringify(signal.mask2));\n\t        if(this.DEBUG) console.log(JSON.stringify(peaks));\n\t        return peaks;\n\t    },\n\t\n\t    /**\n\t     * Calculates the chemical shift as the weighted sum of the peaks\n\t     * @param peaks\n\t     * @param mask\n\t     * @returns {number}\n\t     */\n\t    chemicalShift : function(peaks, mask){\n\t        var sum=0,cs= 0, i, area;\n\t        if(mask){\n\t            for(i=0;i<peaks.length;i++){\n\t                //console.log(mask[i]);\n\t                if(mask[i]===true){\n\t                    area = this.area(peaks[i]);\n\t                    sum+=area;\n\t                    cs+=area*peaks[i].x;\n\t                }\n\t            }\n\t        }\n\t        else{\n\t            for(i=0;i<peaks.length;i++){\n\t                area = this.area(peaks[i]);\n\t                sum+=area;\n\t                cs+=area*peaks[i].x;\n\t            }\n\t        }\n\t        return cs/sum;\n\t    },\n\t\n\t    area: function(peak){\n\t        return Math.abs(peak.intensity*peak.width*1.57)//1.772453851);\n\t    }\n\t}\n\t\n\tmodule.exports = JAnalyzer;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(8);\n\tmodule.exports.Matrix = __webpack_require__(9);\n\tmodule.exports.Matrix.algebra = __webpack_require__(18);\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Created by acastillo on 8/5/15.\n\t */\n\tvar Matrix = __webpack_require__(9);\n\tvar math = __webpack_require__(18);\n\t\n\tvar DEBUG = false;\n\t/** Levenberg Marquardt curve-fitting: minimize sum of weighted squared residuals\n\t ----------  INPUT  VARIABLES  -----------\n\t func   = function of n independent variables, 't', and m parameters, 'p',\n\t returning the simulated model: y_hat = func(t,p,c)\n\t p      = n-vector of initial guess of parameter values\n\t t      = m-vectors or matrix of independent variables (used as arg to func)\n\t y_dat  = m-vectors or matrix of data to be fit by func(t,p)\n\t weight = weighting vector for least squares fit ( weight >= 0 ) ...\n\t inverse of the standard measurement errors\n\t Default:  sqrt(d.o.f. / ( y_dat' * y_dat ))\n\t dp     = fractional increment of 'p' for numerical derivatives\n\t dp(j)>0 central differences calculated\n\t dp(j)<0 one sided 'backwards' differences calculated\n\t dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n\t Default:  0.001;\n\t p_min  = n-vector of lower bounds for parameter values\n\t p_max  = n-vector of upper bounds for parameter values\n\t c      = an optional matrix of values passed to func(t,p,c)\n\t opts   = vector of algorithmic parameters\n\t parameter    defaults    meaning\n\t opts(1)  =  prnt            3        >1 intermediate results; >2 plots\n\t opts(2)  =  MaxIter      10*Npar     maximum number of iterations\n\t opts(3)  =  epsilon_1       1e-3     convergence tolerance for gradient\n\t opts(4)  =  epsilon_2       1e-3     convergence tolerance for parameters\n\t opts(5)  =  epsilon_3       1e-3     convergence tolerance for Chi-square\n\t opts(6)  =  epsilon_4       1e-2     determines acceptance of a L-M step\n\t opts(7)  =  lambda_0        1e-2     initial value of L-M paramter\n\t opts(8)  =  lambda_UP_fac   11       factor for increasing lambda\n\t opts(9)  =  lambda_DN_fac    9       factor for decreasing lambda\n\t opts(10) =  Update_Type      1       1: Levenberg-Marquardt lambda update\n\t 2: Quadratic update\n\t 3: Nielsen's lambda update equations\n\t\n\t ----------  OUTPUT  VARIABLES  -----------\n\t p       = least-squares optimal estimate of the parameter values\n\t X2      = Chi squared criteria\n\t sigma_p = asymptotic standard error of the parameters\n\t sigma_y = asymptotic standard error of the curve-fit\n\t corr    = correlation matrix of the parameters\n\t R_sq    = R-squared cofficient of multiple determination\n\t cvg_hst = convergence history\n\t\n\t Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. 22 Sep 2013\n\t modified from: http://octave.sourceforge.net/optim/function/leasqr.html\n\t using references by\n\t Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\t Sam Roweis       http://www.cs.toronto.edu/~roweis/notes/lm.pdf\n\t Manolis Lourakis http://www.ics.forth.gr/~lourakis/levmar/levmar.pdf\n\t Hans Nielson     http://www2.imm.dtu.dk/~hbn/publ/TR9905.ps\n\t Mathworks        optimization toolbox reference manual\n\t K. Madsen, H.B., Nielsen, and O. Tingleff\n\t http://www2.imm.dtu.dk/pubdb/views/edoc_download.php/3215/pdf/imm3215.pdf\n\t */\n\tvar LM = {\n\t\n\t    optimize: function(func,p,t,y_dat,weight,dp,p_min,p_max,c,opts){\n\t\n\t        var tensor_parameter = 0;\t\t\t// set to 1 of parameter is a tensor\n\t\n\t        var iteration  = 0;\t\t\t// iteration counter\n\t        //func_calls = 0;\t\t\t// running count of function evaluations\n\t\n\t        if((typeof p[0])!=\"object\"){\n\t            for(var i=0;i< p.length;i++){\n\t                p[i]=[p[i]];\n\t            }\n\t\n\t        }\n\t        //p = p(:); y_dat = y_dat(:);\t\t// make column vectors\n\t\n\t        var eps = 2^-52;\n\t        var Npar   = p.length;//length(p); \t\t\t// number of parameters\n\t        var Npnt   = y_dat.length;//length(y_dat);\t\t// number of data points\n\t        var p_old  = new Matrix.zeros(Npar,1);\t\t// previous set of parameters\n\t        var y_old  = new Matrix.zeros(Npnt,1);\t\t// previous model, y_old = y_hat(t;p_old)\n\t        var X2     = 1e-2/eps;\t\t\t// a really big initial Chi-sq value\n\t        var X2_old = 1e-2/eps;\t\t\t// a really big initial Chi-sq value\n\t        var J = new Matrix.zeros(Npnt,Npar);\n\t        /*var J      = new Array(Npnt);//zeros(Npnt,Npar);\t\t// Jacobian matrix\n\t         for(var  i=0;i<Npnt;i++){\n\t         J[i] = new Array(Npar);\n\t         }*/\n\t\n\t        if (t.length != y_dat.length) {\n\t            console.log('lm.m error: the length of t must equal the length of y_dat');\n\t\n\t            length_t = t.length;\n\t            length_y_dat = y_dat.length;\n\t            var X2 = 0, corr = 0, sigma_p = 0, sigma_y = 0, R_sq = 0, cvg_hist = 0;\n\t            if (!tensor_parameter) {\n\t                return;\n\t            }\n\t        }\n\t\n\t        weight = weight||Math.sqrt((Npnt-Npar+1)/(math.multiply(math.transpose(y_dat),y_dat)));\n\t        dp = dp || 0.001;\n\t        p_min   = p_min || math.multiply(Math.abs(p),-100);\n\t        p_max   = p_max || math.multiply(Math.abs(p),100);\n\t        c = c || 1;\n\t        // Algorithmic Paramters\n\t        //prnt MaxIter  eps1  eps2  epx3  eps4  lam0  lamUP lamDN UpdateType\n\t        opts = opts ||[  3,10*Npar, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2, 11, 9, 1 ];\n\t\n\t        var prnt          = opts[0];\t// >1 intermediate results; >2 plots\n\t        var MaxIter       = opts[1];\t// maximum number of iterations\n\t        var epsilon_1     = opts[2];\t// convergence tolerance for gradient\n\t        var epsilon_2     = opts[3];\t// convergence tolerance for parameter\n\t        var epsilon_3     = opts[4];\t// convergence tolerance for Chi-square\n\t        var epsilon_4     = opts[5];\t// determines acceptance of a L-M step\n\t        var lambda_0      = opts[6];\t// initial value of damping paramter, lambda\n\t        var lambda_UP_fac = opts[7];\t// factor for increasing lambda\n\t        var lambda_DN_fac = opts[8];\t// factor for decreasing lambda\n\t        var Update_Type   = opts[9];\t// 1: Levenberg-Marquardt lambda update\n\t        // 2: Quadratic update\n\t        // 3: Nielsen's lambda update equations\n\t\n\t        if ( tensor_parameter && prnt == 3 ) prnt = 2;\n\t\n\t        //plotcmd='figure(11); plot(t(:,1),y_dat,''og'',t(:,1),y_hat,''-b''); axis tight; drawnow ';\n\t\n\t        //p_min=p_min(:); p_max=p_max(:); \t// make column vectors\n\t\n\t        if(!dp.length || dp.length == 1){\n\t            var dp_array = new Array(Npar);\n\t            for(var i=0;i<Npar;i++)\n\t                dp_array[i]=[dp];\n\t            dp=dp_array;\n\t        }\n\t\n\t        // indices of the parameters to be fit\n\t        var idx   = [];\n\t        for(var i=0;i<dp.length;i++){\n\t            if(dp[i]!=0){\n\t                idx.push(i);\n\t            }\n\t        }\n\t\n\t        var Nfit = idx.length;\t\t\t// number of parameters to fit\n\t        var stop = false;\t\t\t\t// termination flag\n\t\n\t        var weight_sq = null;\n\t        //console.log(weight);\n\t        if ( !weight.length || weight.length < Npnt )\t{\n\t            // squared weighting vector\n\t            //weight_sq = ( weight(1)*ones(Npnt,1) ).^2;\n\t            //console.log(\"weight[0] \"+typeof weight[0]);\n\t            var tmp = math.multiply(new Matrix.ones(Npnt,1),weight[0]);\n\t            weight_sq = math.dotMultiply(tmp,tmp);\n\t        }\n\t        else{\n\t            //weight_sq = (weight(:)).^2;\n\t            weight_sq = math.dotMultiply(weight,weight);\n\t        }\n\t\n\t\n\t        // initialize Jacobian with finite difference calculation\n\t        //console.log(\"J \"+weight_sq);\n\t        var result = this.lm_matx(func,t,p_old,y_old,1,J,p,y_dat,weight_sq,dp,c);\n\t        var JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n\t        //[JtWJ,JtWdy,X2,y_hat,J] = this.lm_matx(func,t,p_old,y_old,1,J,p,y_dat,weight_sq,dp,c);\n\t        //console.log(JtWJ);\n\t\n\t        if ( Math.max(Math.abs(JtWdy)) < epsilon_1 ){\n\t            console.log(' *** Your Initial Guess is Extremely Close to Optimal ***')\n\t            console.log(' *** epsilon_1 = ', epsilon_1);\n\t            stop = true;\n\t        }\n\t\n\t\n\t        switch(Update_Type){\n\t            case 1: // Marquardt: init'l lambda\n\t                lambda  = lambda_0;\n\t                break;\n\t            default:    // Quadratic and Nielsen\n\t                lambda  = lambda_0 * Math.max(math.diag(JtWJ));\n\t                nu=2;\n\t        }\n\t        //console.log(X2);\n\t        X2_old = X2; // previous value of X2\n\t        //console.log(MaxIter+\" \"+Npar);\n\t        var cvg_hst = new Matrix.ones(MaxIter,Npar+3);\t\t// initialize convergence history\n\t        var h = null;\n\t        while ( !stop && iteration <= MaxIter ) {\t\t// --- Main Loop\n\t            iteration = iteration + 1;\n\t            // incremental change in parameters\n\t            switch(Update_Type){\n\t                case 1:\t\t\t\t\t// Marquardt\n\t                    //h = ( JtWJ + lambda * math.diag(math.diag(JtWJ)) ) \\ JtWdy;\n\t                    //h = math.multiply(math.inv(JtWdy),math.add(JtWJ,math.multiply(lambda,math.diag(math.diag(Npar)))));\n\t                    h = math.solve(math.add(JtWJ,math.multiply(math.diag(math.diag(JtWJ)),lambda)),JtWdy);\n\t                    break;\n\t                default:\t\t\t\t\t// Quadratic and Nielsen\n\t                    //h = ( JtWJ + lambda * math.eye(Npar) ) \\ JtWdy;\n\t\n\t                    h = math.solve(math.add(JtWJ,math.multiply(new Matrix.eye(Npar),lambda)),JtWdy);\n\t            }\n\t\n\t            /*for(var k=0;k< h.length;k++){\n\t                h[k]=[h[k]];\n\t            }*/\n\t            //console.log(\"h \"+h);\n\t            //h=math.matrix(h);\n\t            //  big = max(abs(h./p)) > 2;\n\t            //this is a big step\n\t            // --- Are parameters [p+h] much better than [p] ?\n\t            var hidx = new Array(idx.length);\n\t            for(var k=0;k<idx.length;k++){\n\t                hidx[k]=h[idx[k]];\n\t            }\n\t            var p_try = math.add(p, hidx);// update the [idx] elements\n\t\n\t            for(var k=0;k<p_try.length;k++){\n\t                p_try[k][0]=Math.min(Math.max(p_min[k][0],p_try[k][0]),p_max[k][0]);\n\t            }\n\t            // p_try = Math.min(Math.max(p_min,p_try),p_max);           // apply constraints\n\t\n\t            var delta_y = math.subtract(y_dat, func(t,p_try,c));       // residual error using p_try\n\t            //func_calls = func_calls + 1;\n\t            //X2_try = delta_y' * ( delta_y .* weight_sq );  // Chi-squared error criteria\n\t\n\t            var X2_try = math.multiply(math.transpose(delta_y),math.dotMultiply(delta_y,weight_sq));\n\t\n\t            if ( Update_Type == 2 ){  \t\t\t  // Quadratic\n\t                //    One step of quadratic line update in the h direction for minimum X2\n\t                //var alpha =  JtWdy'*h / ( (X2_try - X2)/2 + 2*JtWdy'*h ) ;\n\t                var JtWdy_th = math.multiply(math.transpose(JtWdy),h);\n\t                var alpha =  math.multiply(JtWdy_th,math.inv(math.add(math.multiply(math.subtract(X2_try - X2),1/2)),math.multiply(JtWdy_th,2)));//JtWdy'*h / ( (X2_try - X2)/2 + 2*JtWdy'*h ) ;\n\t\n\t                h = math.multiply(alpha, h);\n\t                for(var k=0;k<idx.length;k++){\n\t                    hidx[k]=h[idx[k]];\n\t                }\n\t\n\t                p_try = math.add(p ,hidx);                     // update only [idx] elements\n\t                p_try = math.min(math.max(p_min,p_try),p_max);          // apply constraints\n\t\n\t                delta_y = math.subtract(y_dat, func(t,p_try,c));      // residual error using p_try\n\t                // func_calls = func_calls + 1;\n\t                //X2_try = delta_y' * ( delta_y .* weight_sq ); // Chi-squared error criteria\n\t                X2_try = math.multiply(math.transpose(delta_y), mat.dotMultiply(delta_y, weight_sq));\n\t            }\n\t\n\t            //rho = (X2 - X2_try) / ( 2*h' * (lambda * h + JtWdy) ); // Nielsen\n\t            var rho = (X2-X2_try)/math.multiply(math.multiply(math.transpose(h),2),math.add(math.multiply(lambda, h),JtWdy));\n\t            //console.log(\"rho \"+rho);\n\t            if ( rho > epsilon_4 ) {\t\t// it IS significantly better\n\t                //console.log(\"Here\");\n\t                dX2 = X2 - X2_old;\n\t                X2_old = X2;\n\t                p_old = p;\n\t                y_old = y_hat;\n\t                p = p_try;\t\t\t// accept p_try\n\t\n\t                result = this.lm_matx(func, t, p_old, y_old, dX2, J, p, y_dat, weight_sq, dp, c);\n\t                JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n\t                // decrease lambda ==> Gauss-Newton method\n\t\n\t                switch (Update_Type) {\n\t                    case 1:\t\t\t\t\t\t\t// Levenberg\n\t                        lambda = Math.max(lambda / lambda_DN_fac, 1.e-7);\n\t                        break;\n\t                    case 2:\t\t\t\t\t\t\t// Quadratic\n\t                        lambda = Math.max(lambda / (1 + alpha), 1.e-7);\n\t                        break;\n\t                    case 3:\t\t\t\t\t\t\t// Nielsen\n\t                        lambda = math.multiply(Math.max(1 / 3, 1 - (2 * rho - 1) ^ 3),lambda);\n\t                        nu = 2;\n\t                        break;\n\t                }\n\t            }\n\t            else {\t\t\t\t\t// it IS NOT better\n\t                X2 = X2_old;\t\t\t// do not accept p_try\n\t                if (iteration%(2 * Npar)==0) {\t// rank-1 update of Jacobian\n\t                    result = this.lm_matx(func, t, p_old, y_old, -1, J, p, y_dat, weight_sq, dp, c);\n\t                    JtWJ = result.JtWJ,JtWdy=result.JtWdy,dX2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n\t                }\n\t\n\t                // increase lambda  ==> gradient descent method\n\t                switch (Update_Type) {\n\t                    case 1:\t\t\t\t\t\t\t// Levenberg\n\t                        lambda = Math.min(lambda * lambda_UP_fac, 1.e7);\n\t                        break;\n\t                    case 2:\t\t\t\t\t\t\t// Quadratic\n\t                        lambda = lambda + Math.abs((X2_try - X2) / 2 / alpha);\n\t                        break;\n\t                    case 3:\t\t\t\t\t\t// Nielsen\n\t                        lambda = lambda * nu;\n\t                        nu = 2 * nu;\n\t                        break;\n\t                }\n\t                if (DEBUG) {\n\t                    /*fprintf('>//3d://3d | chi_sq=//10.3e | lambda=//8.1e \\n', iteration,func_calls,X2,lambda );\n\t                     fprintf('    param:  ');\n\t                     for pn=1:Npar\n\t                     fprintf(' //10.3e', p(pn) );\n\t                     end\n\t                     fprintf('\\n');\n\t                     fprintf('    dp/p :  ');\n\t                     for pn=1:Npar\n\t                     fprintf(' //10.3e', h(pn) / p(pn) );\n\t                     end\n\t                     fprintf('\\n');\n\t                     end\n\t\n\t\n\t                     cvg_hst(iteration,:) = [ func_calls  p'  X2/2  lambda ];\t// update convergence history\n\t\n\t\n\t                     if ( max(abs(JtWdy)) < epsilon_1  &  iteration > 2 )\n\t                     fprintf(' **** Convergence in r.h.s. (\"JtWdy\")  **** \\n')\n\t                     fprintf(' **** epsilon_1 = //e\\n', epsilon_1);\n\t                     stop = 1;\n\t                     end\n\t                     if ( max(abs(h./p)) < epsilon_2  &  iteration > 2 )\n\t                     fprintf(' **** Convergence in Parameters **** \\n')\n\t                     fprintf(' **** epsilon_2 = //e\\n', epsilon_2);\n\t                     stop = 1;\n\t                     end\n\t                     if ( X2/(Npnt-Npar+1) < epsilon_3  &  iteration > 2 )\n\t                     fprintf(' **** Convergence in Chi-square  **** \\n')\n\t                     fprintf(' **** epsilon_3 = //e\\n', epsilon_3);\n\t                     stop = 1;\n\t                     end\n\t                     if ( iteration == MaxIter )\n\t                     disp(' !! Maximum Number of Iterations Reached Without Convergence !!')\n\t                     stop = 1;\n\t                     end*/\n\t                }\n\t            }\n\t        }// --- End of Main Loop\n\t\n\t        // --- convergence achieved, find covariance and confidence intervals\n\t\n\t        // equal weights for paramter error analysis\n\t        weight_sq = math.multiply(math.multiply(math.transpose(delta_y),delta_y), new Matrix.ones(Npnt,1));\n\t\n\t        //console.log(\"XX \"+(Npnt-Nfit+1));\n\t        //console.log(delta_y);\n\t\n\t        weight_sq.apply(function(i,j){\n\t            weight_sq[i][j] = (Npnt-Nfit+1)/weight_sq[i][j];\n\t        });\n\t        //console.log(weight_sq);\n\t        result = this.lm_matx(func,t,p_old,y_old,-1,J,p,y_dat,weight_sq,dp,c);\n\t        JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n\t\n\t        /*if nargout > 2\t\t\t\t// standard error of parameters\n\t         covar = inv(JtWJ);\n\t         sigma_p = sqrt(diag(covar));\n\t         end\n\t\n\t         if nargout > 3\t\t\t\t// standard error of the fit\n\t         //  sigma_y = sqrt(diag(J * covar * J'));\t// slower version of below\n\t         sigma_y = zeros(Npnt,1);\n\t         for i=1:Npnt\n\t         sigma_y(i) = J(i,:) * covar * J(i,:)';\n\t         end\n\t         sigma_y = sqrt(sigma_y);\n\t         end\n\t\n\t         if nargout > 4\t\t\t\t// parameter correlation matrix\n\t         corr = covar ./ [sigma_p*sigma_p'];\n\t         end\n\t\n\t         if nargout > 5\t\t\t\t// coefficient of multiple determination\n\t         R_sq = corrcoef([y_dat y_hat]);\n\t         R_sq = R_sq(1,2).^2;\n\t         end\n\t\n\t         if nargout > 6\t\t\t\t// convergence history\n\t         cvg_hst = cvg_hst(1:iteration,:);\n\t         end*/\n\t\n\t        // endfunction  # ---------------------------------------------------------- LM\n\t\n\t        return p;\n\t    },\n\t\n\t    lm_FD_J:function(func,t,p,y,dp,c) {\n\t        // J = lm_FD_J(func,t,p,y,{dp},{c})\n\t        //\n\t        // partial derivatives (Jacobian) dy/dp for use with lm.m\n\t        // computed via Finite Differences\n\t        // Requires n or 2n function evaluations, n = number of nonzero values of dp\n\t        // -------- INPUT VARIABLES ---------\n\t        // func = function of independent variables, 't', and parameters, 'p',\n\t        //        returning the simulated model: y_hat = func(t,p,c)\n\t        // t  = m-vector of independent variables (used as arg to func)\n\t        // p  = n-vector of current parameter values\n\t        // y  = func(t,p,c) n-vector initialised by user before each call to lm_FD_J\n\t        // dp = fractional increment of p for numerical derivatives\n\t        //      dp(j)>0 central differences calculated\n\t        //      dp(j)<0 one sided differences calculated\n\t        //      dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n\t        //      Default:  0.001;\n\t        // c  = optional vector of constants passed to y_hat = func(t,p,c)\n\t        //---------- OUTPUT VARIABLES -------\n\t        // J  = Jacobian Matrix J(i,j)=dy(i)/dp(j)\ti=1:n; j=1:m\n\t\n\t        //   Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. November 2005\n\t        //   modified from: ftp://fly.cnuce.cnr.it/pub/software/octave/leasqr/\n\t        //   Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\t\n\t        var m = y.length;\t\t\t// number of data points\n\t        var n = p.length;\t\t\t// number of parameters\n\t\n\t        dp = dp || math.multiply(new Matrix.ones(1, n), 0.001);\n\t\n\t        var ps = p.clone();//JSON.parse(JSON.stringify(p));\n\t        //var ps = $.extend(true, [], p);\n\t        var J = new Matrix(m,n), del =new Array(n);         // initialize Jacobian to Zero\n\t\n\t        for (var j = 0;j < n; j++) {\n\t            //console.log(j+\" \"+dp[j]+\" \"+p[j]+\" \"+ps[j]+\" \"+del[j]);\n\t            del[j] = dp[j]*(1+Math.abs(p[j][0]));  // parameter perturbation\n\t            p[j] = [ps[j][0]+del[j]];\t      // perturb parameter p(j)\n\t            //console.log(j+\" \"+dp[j]+\" \"+p[j]+\" \"+ps[j]+\" \"+del[j]);\n\t\n\t            if (del[j] != 0){\n\t                y1 = func(t, p, c);\n\t                //func_calls = func_calls + 1;\n\t                if (dp[j][0] < 0) {\t\t// backwards difference\n\t                    //J(:,j) = math.dotDivide(math.subtract(y1, y),del[j]);//. / del[j];\n\t                    //console.log(del[j]);\n\t                    //console.log(y);\n\t                    var column = math.dotDivide(math.subtract(y1, y),del[j]);\n\t                    for(var k=0;k< m;k++){\n\t                        J[k][j]=column[k][0];\n\t                    }\n\t                    //console.log(column);\n\t                }\n\t                else{\n\t                    p[j][0] = ps[j][0] - del[j];\n\t                    //J(:,j) = (y1 - feval(func, t, p, c)). / (2. * del[j]);\n\t                    var column = math.dotDivide(math.subtract(y1,func(t,p,c)),2*del[j]);\n\t                    for(var k=0;k< m;k++){\n\t                        J[k][j]=column[k][0];\n\t                    }\n\t\n\t                }\t\t\t// central difference, additional func call\n\t            }\n\t\n\t            p[j] = ps[j];\t\t// restore p(j)\n\t\n\t        }\n\t        //console.log(\"lm_FD_J: \"+ JSON.stringify(J));\n\t        return J;\n\t\n\t    },\n\t\n\t    // endfunction # -------------------------------------------------- LM_FD_J\n\t    lm_Broyden_J: function(p_old,y_old,J,p,y){\n\t        // J = lm_Broyden_J(p_old,y_old,J,p,y)\n\t        // carry out a rank-1 update to the Jacobian matrix using Broyden's equation\n\t        //---------- INPUT VARIABLES -------\n\t        // p_old = previous set of parameters\n\t        // y_old = model evaluation at previous set of parameters, y_hat(t;p_old)\n\t        // J  = current version of the Jacobian matrix\n\t        // p     = current  set of parameters\n\t        // y     = model evaluation at current  set of parameters, y_hat(t;p)\n\t        //---------- OUTPUT VARIABLES -------\n\t        // J = rank-1 update to Jacobian Matrix J(i,j)=dy(i)/dp(j)\ti=1:n; j=1:m\n\t        //console.log(p+\" X \"+ p_old)\n\t        var h  = math.subtract(p, p_old);\n\t\n\t        //console.log(\"hhh \"+h);\n\t        var h_t = math.transpose(h);\n\t        h_t.div(math.multiply(h_t,h));\n\t\n\t        //console.log(h_t);\n\t        //J = J + ( y - y_old - J*h )*h' / (h'*h);\t// Broyden rank-1 update eq'n\n\t        J = math.add(J, math.multiply(math.subtract(y, math.add(y_old,math.multiply(J,h))),h_t));\n\t        return J;\n\t        // endfunction # ---------------------------------------------- LM_Broyden_J\n\t    },\n\t\n\t    lm_matx : function (func,t,p_old,y_old,dX2,J,p,y_dat,weight_sq,dp,c,iteration){\n\t        // [JtWJ,JtWdy,Chi_sq,y_hat,J] = this.lm_matx(func,t,p_old,y_old,dX2,J,p,y_dat,weight_sq,{da},{c})\n\t        //\n\t        // Evaluate the linearized fitting matrix, JtWJ, and vector JtWdy,\n\t        // and calculate the Chi-squared error function, Chi_sq\n\t        // Used by Levenberg-Marquard algorithm, lm.m\n\t        // -------- INPUT VARIABLES ---------\n\t        // func   = function ofpn independent variables, p, and m parameters, p,\n\t        //         returning the simulated model: y_hat = func(t,p,c)\n\t        // t      = m-vectors or matrix of independent variables (used as arg to func)\n\t        // p_old  = n-vector of previous parameter values\n\t        // y_old  = m-vector of previous model ... y_old = y_hat(t;p_old);\n\t        // dX2    = previous change in Chi-squared criteria\n\t        // J   = m-by-n Jacobian of model, y_hat, with respect to parameters, p\n\t        // p      = n-vector of current  parameter values\n\t        // y_dat  = n-vector of data to be fit by func(t,p,c)\n\t        // weight_sq = square of the weighting vector for least squares fit ...\n\t        //\t    inverse of the standard measurement errors\n\t        // dp     = fractional increment of 'p' for numerical derivatives\n\t        //          dp(j)>0 central differences calculated\n\t        //          dp(j)<0 one sided differences calculated\n\t        //          dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n\t        //          Default:  0.001;\n\t        // c      = optional vector of constants passed to y_hat = func(t,p,c)\n\t        //---------- OUTPUT VARIABLES -------\n\t        // JtWJ\t = linearized Hessian matrix (inverse of covariance matrix)\n\t        // JtWdy   = linearized fitting vector\n\t        // Chi_sq = Chi-squared criteria: weighted sum of the squared residuals WSSR\n\t        // y_hat  = model evaluated with parameters 'p'\n\t        // J   = m-by-n Jacobian of model, y_hat, with respect to parameters, p\n\t\n\t        //   Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. November 2005\n\t        //   modified from: ftp://fly.cnuce.cnr.it/pub/software/octave/leasqr/\n\t        //   Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\t\n\t\n\t        var Npnt = y_dat.length;\t\t// number of data points\n\t        var Npar = p.length;\t\t// number of parameters\n\t\n\t        dp = dp || 0.001;\n\t\n\t\n\t        //var JtWJ = new Matrix.zeros(Npar);\n\t        //var JtWdy  = new Matrix.zeros(Npar,1);\n\t\n\t        var y_hat = func(t,p,c);\t// evaluate model using parameters 'p'\n\t        //func_calls = func_calls + 1;\n\t        //console.log(J);\n\t        if ( (iteration%(2*Npar))==0 || dX2 > 0 ) {\n\t            //console.log(\"Par\");\n\t            J = this.lm_FD_J(func, t, p, y_hat, dp, c);\t\t// finite difference\n\t        }\n\t        else{\n\t            //console.log(\"ImPar\");\n\t            J = this.lm_Broyden_J(p_old, y_old, J, p, y_hat); // rank-1 update\n\t        }\n\t        var delta_y = math.subtract(y_dat, y_hat);\t// residual error between model and data\n\t        //console.log(delta_y[0][0]);\n\t        //console.log(delta_y.rows+\" \"+delta_y.columns+\" \"+JSON.stringify(weight_sq));\n\t        //var Chi_sq = delta_y' * ( delta_y .* weight_sq ); \t// Chi-squared error criteria\n\t        var Chi_sq = math.multiply(math.transpose(delta_y),math.dotMultiply(delta_y,weight_sq));\n\t        //JtWJ  = J' * ( J .* ( weight_sq * ones(1,Npar) ) );\n\t        var Jt = math.transpose(J);\n\t\n\t        //console.log(weight_sq);\n\t\n\t        var JtWJ = math.multiply(Jt, math.dotMultiply(J,math.multiply(weight_sq,new Matrix.ones(1,Npar))));\n\t\n\t        //JtWdy = J' * ( weight_sq .* delta_y );\n\t        var JtWdy = math.multiply(Jt, math.dotMultiply(weight_sq,delta_y));\n\t\n\t\n\t        return {JtWJ:JtWJ,JtWdy:JtWdy,Chi_sq:Chi_sq,y_hat:y_hat,J:J};\n\t        // endfunction  # ------------------------------------------------------ LM_MATX\n\t    }\n\t\n\t\n\t\n\t};\n\t\n\tmodule.exports = LM;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(10);\n\tmodule.exports.Decompositions = module.exports.DC = __webpack_require__(11);\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar Asplice = Array.prototype.splice,\n\t    Aconcat = Array.prototype.concat;\n\t\n\t// For performance : http://jsperf.com/clone-array-slice-vs-while-vs-for\n\tfunction slice(arr) {\n\t    var i = 0,\n\t        ii = arr.length,\n\t        result = new Array(ii);\n\t    for (; i < ii; i++) {\n\t        result[i] = arr[i];\n\t    }\n\t    return result;\n\t}\n\t\n\t/**\n\t * Real matrix.\n\t * @constructor\n\t * @param {number|Array} nRows - Number of rows of the new matrix or a 2D array containing the data.\n\t * @param {number|boolean} [nColumns] - Number of columns of the new matrix or a boolean specifying if the input array should be cloned\n\t */\n\tfunction Matrix(nRows, nColumns) {\n\t    var i = 0, rows, columns, matrix, newInstance;\n\t    if (Array.isArray(nRows)) {\n\t        newInstance = nColumns;\n\t        matrix = newInstance ? slice(nRows) : nRows;\n\t        nRows = matrix.length;\n\t        nColumns = matrix[0].length;\n\t        if (typeof nColumns === 'undefined') {\n\t            throw new TypeError('Data must be a 2D array');\n\t        }\n\t        if (nRows > 0 && nColumns > 0) {\n\t            for (; i < nRows; i++) {\n\t                if (matrix[i].length !== nColumns) {\n\t                    throw new RangeError('Inconsistent array dimensions');\n\t                } else if (newInstance) {\n\t                    matrix[i] = slice(matrix[i]);\n\t                }\n\t            }\n\t        } else {\n\t            throw new RangeError('Invalid dimensions: ' + nRows + 'x' + nColumns);\n\t        }\n\t    } else if (typeof nRows === 'number') { // Create empty matrix\n\t        if (nRows > 0 && nColumns > 0) {\n\t            matrix = new Array(nRows);\n\t            for (; i < nRows; i++) {\n\t                matrix[i] = new Array(nColumns);\n\t            }\n\t        } else {\n\t            throw new RangeError('Invalid dimensions: ' + nRows + 'x' + nColumns);\n\t        }\n\t    } else {\n\t        throw new TypeError('Invalid arguments');\n\t    }\n\t\n\t    Object.defineProperty(matrix, 'rows', {writable: true, value: nRows});\n\t    Object.defineProperty(matrix, 'columns', {writable: true, value: nColumns});\n\t\n\t    matrix.__proto__ = Matrix.prototype;\n\t\n\t    return matrix;\n\t}\n\t\n\t/**\n\t * Constructs a Matrix with the chosen dimensions from a 1D array.\n\t * @param {number} newRows - Number of rows\n\t * @param {number} newColumns - Number of columns\n\t * @param {Array} newData - A 1D array containing data for the matrix\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.from1DArray = function from1DArray(newRows, newColumns, newData) {\n\t    var length, data, i = 0;\n\t\n\t    length = newRows * newColumns;\n\t    if (length !== newData.length)\n\t        throw new RangeError('Data length does not match given dimensions');\n\t\n\t    data = new Array(newRows);\n\t    for (; i < newRows; i++) {\n\t        data[i] = newData.slice(i * newColumns, (i + 1) * newColumns);\n\t    }\n\t    return new Matrix(data);\n\t};\n\t\n\t/**\n\t * Creates a row vector, a matrix with only one row.\n\t * @param {Array} newData - A 1D array containing data for the vector\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.rowVector = function rowVector(newData) {\n\t    return new Matrix([newData]);\n\t};\n\t\n\t/**\n\t * Creates a column vector, a matrix with only one column.\n\t * @param {Array} newData - A 1D array containing data for the vector\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.columnVector = function columnVector(newData) {\n\t    var l = newData.length, vector = new Array(l);\n\t    for (var i = 0; i < l; i++)\n\t        vector[i] = [newData[i]];\n\t    return new Matrix(vector);\n\t};\n\t\n\t/**\n\t * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).\n\t * @param {number} rows - Number of rows\n\t * @param {number} columns - Number of columns\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.empty = function empty(rows, columns) {\n\t    return new Matrix(rows, columns);\n\t};\n\t\n\t/**\n\t * Creates a matrix with the given dimensions. Values will be set to zero.\n\t * @param {number} rows - Number of rows\n\t * @param {number} columns - Number of columns\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.zeros = function zeros(rows, columns) {\n\t    return Matrix.empty(rows, columns).fill(0);\n\t};\n\t\n\t/**\n\t * Creates a matrix with the given dimensions. Values will be set to one.\n\t * @param {number} rows - Number of rows\n\t * @param {number} columns - Number of columns\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.ones = function ones(rows, columns) {\n\t    return Matrix.empty(rows, columns).fill(1);\n\t};\n\t\n\t/**\n\t * Creates a matrix with the given dimensions. Values will be randomly set using Math.random().\n\t * @param {number} rows - Number of rows\n\t * @param {number} columns - Number of columns\n\t * @returns {Matrix} The new matrix\n\t */\n\tMatrix.rand = function rand(rows, columns) {\n\t    var matrix = Matrix.empty(rows, columns);\n\t    for (var i = 0, ii = matrix.rows; i < ii; i++) {\n\t        for (var j = 0, jj = matrix.columns; j < jj; j++) {\n\t            matrix[i][j] = Math.random();\n\t        }\n\t    }\n\t    return matrix;\n\t};\n\t\n\t/**\n\t * Creates an identity matrix with the given dimension. Values of the diagonal will be 1 and other will be 0.\n\t * @param {number} n - Number of rows and columns\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.eye = function eye(n) {\n\t    var matrix = Matrix.zeros(n, n), l = matrix.rows;\n\t    for (var i = 0; i < l; i++) {\n\t        matrix[i][i] = 1;\n\t    }\n\t    return matrix;\n\t};\n\t\n\t/**\n\t * Creates a diagonal matrix based on the given array.\n\t * @param {Array} data - Array containing the data for the diagonal\n\t * @returns {Matrix} - The new matrix\n\t */\n\tMatrix.diag = function diag(data) {\n\t    var l = data.length, matrix = Matrix.zeros(l, l);\n\t    for (var i = 0; i < l; i++) {\n\t        matrix[i][i] = data[i];\n\t    }\n\t    return matrix;\n\t};\n\t\n\t/**\n\t * Creates an array of indices between two values\n\t * @param {number} from\n\t * @param {number} to\n\t * @returns {Array}\n\t */\n\tMatrix.indices = function indices(from, to) {\n\t    var vector = new Array(to - from);\n\t    for (var i = 0; i < vector.length; i++)\n\t        vector[i] = from++;\n\t    return vector;\n\t};\n\t\n\t// TODO DOC\n\tMatrix.stack = function stack(arg1) {\n\t    var i, j, k;\n\t    if (Matrix.isMatrix(arg1)) {\n\t        var rows = 0,\n\t            cols = 0;\n\t        for (i = 0; i < arguments.length; i++) {\n\t            rows += arguments[i].rows;\n\t            if (arguments[i].columns > cols)\n\t                cols = arguments[i].columns;\n\t        }\n\t\n\t        var r = Matrix.zeros(rows, cols);\n\t        var c = 0;\n\t        for (i = 0; i < arguments.length; i++) {\n\t            var current = arguments[i];\n\t            for (j = 0; j < current.rows; j++) {\n\t                for (k = 0; k < current.columns; k++)\n\t                    r[c][k] = current[j][k];\n\t                c++;\n\t            }\n\t        }\n\t        return r;\n\t    }\n\t    else if (Array.isArray(arg1)) {\n\t        var matrix = Matrix.empty(arguments.length, arg1.length);\n\t        for (i = 0; i < arguments.length; i++)\n\t            matrix.setRow(i, arguments[i]);\n\t        return matrix;\n\t    }\n\t};\n\t\n\t// TODO DOC\n\tMatrix.expand = function expand(base, count) {\n\t    var expansion = [];\n\t    for (var i = 0; i < count.length; i++)\n\t        for (var j = 0; j < count[i]; j++)\n\t            expansion.push(base[i]);\n\t    return new Matrix(expansion);\n\t};\n\t\n\t/**\n\t * Check that the provided value is a Matrix and tries to instantiate one if not\n\t * @param value - The value to check\n\t * @returns {Matrix}\n\t * @throws {TypeError}\n\t */\n\tMatrix.checkMatrix = function checkMatrix(value) {\n\t    if (!value) {\n\t        throw new TypeError('Argument has to be a matrix');\n\t    }\n\t    if (value.klass !== 'Matrix') {\n\t        value = new Matrix(value);\n\t    }\n\t    return value;\n\t};\n\t\n\t/**\n\t * Returns true if the argument is a Matrix, false otherwise\n\t * @param value - The value to check\n\t * @returns {boolean}\n\t */\n\tMatrix.isMatrix = function isMatrix(value) {\n\t    return value ? value.klass === 'Matrix' : false;\n\t};\n\t\n\t/**\n\t * @property {string} - The name of this class.\n\t */\n\tObject.defineProperty(Matrix.prototype, 'klass', {\n\t    get: function klass() {\n\t        return 'Matrix';\n\t    }\n\t});\n\t\n\t/**\n\t * @property {number} - The number of elements in the matrix.\n\t */\n\tObject.defineProperty(Matrix.prototype, 'size', {\n\t    get: function size() {\n\t        return this.rows * this.columns;\n\t    }\n\t});\n\t\n\t/**\n\t * @private\n\t * Internal check that a row index is not out of bounds\n\t * @param {number} index\n\t */\n\tMatrix.prototype.checkRowIndex = function checkRowIndex(index) {\n\t    if (index < 0 || index > this.rows - 1)\n\t        throw new RangeError('Row index out of range.');\n\t};\n\t\n\t/**\n\t * @private\n\t * Internal check that a column index is not out of bounds\n\t * @param {number} index\n\t */\n\tMatrix.prototype.checkColumnIndex = function checkColumnIndex(index) {\n\t    if (index < 0 || index > this.columns - 1)\n\t        throw new RangeError('Column index out of range.');\n\t};\n\t\n\t/**\n\t * @private\n\t * Internal check that two matrices have the same dimensions\n\t * @param {Matrix} otherMatrix\n\t */\n\tMatrix.prototype.checkDimensions = function checkDimensions(otherMatrix) {\n\t    if ((this.rows !== otherMatrix.rows) || (this.columns !== otherMatrix.columns))\n\t        throw new RangeError('Matrices dimensions must be equal.');\n\t};\n\t\n\t/**\n\t * Applies a callback for each element of the matrix. The function is called in the matrix (this) context.\n\t * @param {function} callback - Function that will be called with two parameters : i (row) and j (column)\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.apply = function apply(callback) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            callback.call(this, i, j);\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Creates an exact and independent copy of the matrix\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.clone = function clone() {\n\t    return new Matrix(this.to2DArray());\n\t};\n\t\n\t/**\n\t * Returns a new 1D array filled row by row with the matrix values\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.to1DArray = function to1DArray() {\n\t    return Aconcat.apply([], this);\n\t};\n\t\n\t/**\n\t * Returns a 2D array containing a copy of the data\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.to2DArray = function to2DArray() {\n\t    var l = this.rows, copy = new Array(l);\n\t    for (var i = 0; i < l; i++) {\n\t        copy[i] = slice(this[i]);\n\t    }\n\t    return copy;\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix has one row\n\t */\n\tMatrix.prototype.isRowVector = function isRowVector() {\n\t    return this.rows === 1;\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix has one column\n\t */\n\tMatrix.prototype.isColumnVector = function isColumnVector() {\n\t    return this.columns === 1;\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix has one row or one column\n\t */\n\tMatrix.prototype.isVector = function isVector() {\n\t    return (this.rows === 1) || (this.columns === 1);\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix has the same number of rows and columns\n\t */\n\tMatrix.prototype.isSquare = function isSquare() {\n\t    return this.rows === this.columns;\n\t};\n\t\n\t/**\n\t * @returns {boolean} true if the matrix is square and has the same values on both sides of the diagonal\n\t */\n\tMatrix.prototype.isSymmetric = function isSymmetric() {\n\t    if (this.isSquare()) {\n\t        var l = this.rows;\n\t        for (var i = 0; i < l; i++) {\n\t            for (var j = 0; j <= i; j++) {\n\t                if (this[i][j] !== this[j][i]) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    return false;\n\t};\n\t\n\t/**\n\t * Sets a given element of the matrix. mat.set(3,4,1) is equivalent to mat[3][4]=1\n\t * @param {number} rowIndex - Index of the row\n\t * @param {number} columnIndex - Index of the column\n\t * @param {number} value - The new value for the element\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.set = function set(rowIndex, columnIndex, value) {\n\t    this[rowIndex][columnIndex] = value;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Returns the given element of the matrix. mat.get(3,4) is equivalent to matrix[3][4]\n\t * @param {number} rowIndex - Index of the row\n\t * @param {number} columnIndex - Index of the column\n\t * @returns {number}\n\t */\n\tMatrix.prototype.get = function get(rowIndex, columnIndex) {\n\t    return this[rowIndex][columnIndex];\n\t};\n\t\n\t/**\n\t * Fills the matrix with a given value. All elements will be set to this value.\n\t * @param {number} value - New value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.fill = function fill(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] = value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Negates the matrix. All elements will be multiplied by (-1)\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.neg = function neg() {\n\t    return this.mulS(-1);\n\t};\n\t\n\t/**\n\t * Adds a scalar or values from another matrix (in place)\n\t * @param {number|Matrix} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.add = function add(value) {\n\t    if (typeof value === 'number')\n\t        return this.addS(value);\n\t    value = Matrix.checkMatrix(value);\n\t        return this.addM(value);\n\t};\n\t\n\t/**\n\t * Adds a scalar to each element of the matrix\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addS = function addS(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] += value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Adds the value of each element of matrix to the corresponding element of this\n\t * @param {Matrix} matrix\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addM = function addM(matrix) {\n\t    this.checkDimensions(matrix);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] += matrix[i][j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Subtracts a scalar or values from another matrix (in place)\n\t * @param {number|Matrix} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.sub = function sub(value) {\n\t    if (typeof value === 'number')\n\t        return this.subS(value);\n\t    value = Matrix.checkMatrix(value);\n\t        return this.subM(value);\n\t};\n\t\n\t/**\n\t * Subtracts a scalar from each element of the matrix\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.subS = function subS(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] -= value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Subtracts the value of each element of matrix from the corresponding element of this\n\t * @param {Matrix} matrix\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.subM = function subM(matrix) {\n\t    this.checkDimensions(matrix);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] -= matrix[i][j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies a scalar or values from another matrix (in place)\n\t * @param {number|Matrix} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mul = function mul(value) {\n\t    if (typeof value === 'number')\n\t        return this.mulS(value);\n\t    value = Matrix.checkMatrix(value);\n\t        return this.mulM(value);\n\t};\n\t\n\t/**\n\t * Multiplies a scalar with each element of the matrix\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulS = function mulS(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] *= value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the value of each element of matrix with the corresponding element of this\n\t * @param {Matrix} matrix\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulM = function mulM(matrix) {\n\t    this.checkDimensions(matrix);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] *= matrix[i][j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Divides by a scalar or values from another matrix (in place)\n\t * @param {number|Matrix} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.div = function div(value) {\n\t    if (typeof value === 'number')\n\t        return this.divS(value);\n\t    value = Matrix.checkMatrix(value);\n\t        return this.divM(value);\n\t};\n\t\n\t/**\n\t * Divides each element of the matrix by a scalar\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.divS = function divS(value) {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] /= value;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Divides each element of this by the corresponding element of matrix\n\t * @param {Matrix} matrix\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.divM = function divM(matrix) {\n\t    this.checkDimensions(matrix);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] /= matrix[i][j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Returns a new array from the given row index\n\t * @param {number} index - Row index\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.getRow = function getRow(index) {\n\t    this.checkRowIndex(index);\n\t    return slice(this[index]);\n\t};\n\t\n\t/**\n\t * Returns a new row vector from the given row index\n\t * @param {number} index - Row index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.getRowVector = function getRowVector(index) {\n\t    return Matrix.rowVector(this.getRow(index));\n\t};\n\t\n\t/**\n\t * Sets a row at the given index\n\t * @param {number} index - Row index\n\t * @param {Array|Matrix} array - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.setRow = function setRow(index, array) {\n\t    this.checkRowIndex(index);\n\t    if (Matrix.isMatrix(array)) array = array.to1DArray();\n\t    if (array.length !== this.columns)\n\t        throw new RangeError('Invalid row size');\n\t    this[index] = slice(array);\n\t    return this;\n\t};\n\t\n\t/**\n\t * Removes a row from the given index\n\t * @param {number} index - Row index\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.removeRow = function removeRow(index) {\n\t    this.checkRowIndex(index);\n\t    if (this.rows === 1)\n\t        throw new RangeError('A matrix cannot have less than one row');\n\t    Asplice.call(this, index, 1);\n\t    this.rows -= 1;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Adds a row at the given index\n\t * @param {number} [index = this.rows] - Row index\n\t * @param {Array|Matrix} array - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addRow = function addRow(index, array) {\n\t    if (typeof array === 'undefined') {\n\t        array = index;\n\t        index = this.rows;\n\t    }\n\t    if (index < 0 || index > this.rows)\n\t        throw new RangeError('Row index out of range.');\n\t    if (Matrix.isMatrix(array)) array = array.to1DArray();\n\t    if (array.length !== this.columns)\n\t        throw new RangeError('Invalid row size');\n\t    Asplice.call(this, index, 0, slice(array));\n\t    this.rows += 1;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Swaps two rows\n\t * @param {number} row1 - First row index\n\t * @param {number} row2 - Second row index\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.swapRows = function swapRows(row1, row2) {\n\t    this.checkRowIndex(row1);\n\t    this.checkRowIndex(row2);\n\t    var temp = this[row1];\n\t    this[row1] = this[row2];\n\t    this[row2] = temp;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Returns a new array from the given column index\n\t * @param {number} index - Column index\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.getColumn = function getColumn(index) {\n\t    this.checkColumnIndex(index);\n\t    var l = this.rows, column = new Array(l);\n\t    for (var i = 0; i < l; i++) {\n\t        column[i] = this[i][index];\n\t    }\n\t    return column;\n\t};\n\t\n\t/**\n\t * Returns a new column vector from the given column index\n\t * @param {number} index - Column index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.getColumnVector = function getColumnVector(index) {\n\t    return Matrix.columnVector(this.getColumn(index));\n\t};\n\t\n\t/**\n\t * Sets a column at the given index\n\t * @param {number} index - Column index\n\t * @param {Array|Matrix} array - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.setColumn = function setColumn(index, array) {\n\t    this.checkColumnIndex(index);\n\t    if (Matrix.isMatrix(array)) array = array.to1DArray();\n\t    var l = this.rows;\n\t    if (array.length !== l)\n\t        throw new RangeError('Invalid column size');\n\t    for (var i = 0; i < l; i++) {\n\t        this[i][index] = array[i];\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Removes a column from the given index\n\t * @param {number} index - Column index\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.removeColumn = function removeColumn(index) {\n\t    this.checkColumnIndex(index);\n\t    if (this.columns === 1)\n\t        throw new RangeError('A matrix cannot have less than one column');\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        this[i].splice(index, 1);\n\t    }\n\t    this.columns -= 1;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Adds a column at the given index\n\t * @param {number} [index = this.columns] - Column index\n\t * @param {Array|Matrix} array - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addColumn = function addColumn(index, array) {\n\t    if (typeof array === 'undefined') {\n\t        array = index;\n\t        index = this.columns;\n\t    }\n\t    if (index < 0 || index > this.columns)\n\t        throw new RangeError('Column index out of range.');\n\t    if (Matrix.isMatrix(array)) array = array.to1DArray();\n\t    var l = this.rows;\n\t    if (array.length !== l)\n\t        throw new RangeError('Invalid column size');\n\t    for (var i = 0; i < l; i++) {\n\t        this[i].splice(index, 0, array[i]);\n\t    }\n\t    this.columns += 1;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Swaps two columns\n\t * @param {number} column1 - First column index\n\t * @param {number} column2 - Second column index\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.swapColumns = function swapColumns(column1, column2) {\n\t    this.checkRowIndex(column1);\n\t    this.checkRowIndex(column2);\n\t    var l = this.rows, temp, row;\n\t    for (var i = 0; i < l; i++) {\n\t        row = this[i];\n\t        temp = row[column1];\n\t        row[column1] = row[column2];\n\t        row[column2] = temp;\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * @private\n\t * Internal check that the provided vector is an array with the right length\n\t * @param {Array|Matrix} vector\n\t * @returns {Array}\n\t * @throws {RangeError}\n\t */\n\tMatrix.prototype.checkRowVector = function checkRowVector(vector) {\n\t    if (Matrix.isMatrix(vector))\n\t        vector = vector.to1DArray();\n\t    if (vector.length !== this.columns)\n\t        throw new RangeError('vector size must be the same as the number of columns');\n\t    return vector;\n\t};\n\t\n\t/**\n\t * @private\n\t * Internal check that the provided vector is an array with the right length\n\t * @param {Array|Matrix} vector\n\t * @returns {Array}\n\t * @throws {RangeError}\n\t */\n\tMatrix.prototype.checkColumnVector = function checkColumnVector(vector) {\n\t    if (Matrix.isMatrix(vector))\n\t        vector = vector.to1DArray();\n\t    if (vector.length !== this.rows)\n\t        throw new RangeError('vector size must be the same as the number of rows');\n\t    return vector;\n\t};\n\t\n\t/**\n\t * Adds the values of a vector to each row\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addRowVector = function addRowVector(vector) {\n\t    vector = this.checkRowVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] += vector[j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Subtracts the values of a vector from each row\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.subRowVector = function subRowVector(vector) {\n\t    vector = this.checkRowVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] -= vector[j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the values of a vector with each row\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulRowVector = function mulRowVector(vector) {\n\t    vector = this.checkRowVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] *= vector[j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Divides the values of each row by those of a vector\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.divRowVector = function divRowVector(vector) {\n\t    vector = this.checkRowVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] /= vector[j];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Adds the values of a vector to each column\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.addColumnVector = function addColumnVector(vector) {\n\t    vector = this.checkColumnVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] += vector[i];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Subtracts the values of a vector from each column\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.subColumnVector = function subColumnVector(vector) {\n\t    vector = this.checkColumnVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] -= vector[i];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the values of a vector with each column\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulColumnVector = function mulColumnVector(vector) {\n\t    vector = this.checkColumnVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] *= vector[i];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Divides the values of each column by those of a vector\n\t * @param {Array|Matrix} vector - Array or vector\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.divColumnVector = function divColumnVector(vector) {\n\t    vector = this.checkColumnVector(vector);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] /= vector[i];\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the values of a row with a scalar\n\t * @param {number} index - Row index\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulRow = function mulRow(index, value) {\n\t    this.checkRowIndex(index);\n\t    var i = 0, l = this.columns;\n\t    for (; i < l; i++) {\n\t        this[index][i] *= value;\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Multiplies the values of a column with a scalar\n\t * @param {number} index - Column index\n\t * @param {number} value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.mulColumn = function mulColumn(index, value) {\n\t    this.checkColumnIndex(index);\n\t    var i = 0, l = this.rows;\n\t    for (; i < l; i++) {\n\t        this[i][index] *= value;\n\t    }\n\t};\n\t\n\t/**\n\t * A matrix index\n\t * @typedef {Object} MatrixIndex\n\t * @property {number} row\n\t * @property {number} column\n\t */\n\t\n\t/**\n\t * Returns the maximum value of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.max = function max() {\n\t    var v = -Infinity;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (this[i][j] > v) {\n\t                v = this[i][j];\n\t            }\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the maximum value\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.maxIndex = function maxIndex() {\n\t    var v = -Infinity;\n\t    var idx = {};\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (this[i][j] > v) {\n\t                v = this[i][j];\n\t                idx.row = i;\n\t                idx.column = j;\n\t            }\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the minimum value of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.min = function min() {\n\t    var v = Infinity;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (this[i][j] < v) {\n\t                v = this[i][j];\n\t            }\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the minimum value\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.minIndex = function minIndex() {\n\t    var v = Infinity;\n\t    var idx = {};\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (this[i][j] < v) {\n\t                v = this[i][j];\n\t                idx.row = i;\n\t                idx.column = j;\n\t            }\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the maximum value of one row\n\t * @param {number} index - Row index\n\t * @returns {number}\n\t */\n\tMatrix.prototype.maxRow = function maxRow(index) {\n\t    this.checkRowIndex(index);\n\t    var v = -Infinity;\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        if (this[index][i] > v) {\n\t            v = this[index][i];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the maximum value of one row\n\t * @param {number} index - Row index\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.maxRowIndex = function maxRowIndex(index) {\n\t    this.checkRowIndex(index);\n\t    var v = -Infinity;\n\t    var idx = {\n\t            row: index\n\t        };\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        if (this[index][i] > v) {\n\t            v = this[index][i];\n\t            idx.column = i;\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the minimum value of one row\n\t * @param {number} index - Row index\n\t * @returns {number}\n\t */\n\tMatrix.prototype.minRow = function minRow(index) {\n\t    this.checkRowIndex(index);\n\t    var v = Infinity;\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        if (this[index][i] < v) {\n\t            v = this[index][i];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the maximum value of one row\n\t * @param {number} index - Row index\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.minRowIndex = function minRowIndex(index) {\n\t    this.checkRowIndex(index);\n\t    var v = Infinity;\n\t    var idx = {\n\t        row: index,\n\t        column: 0\n\t    };\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        if (this[index][i] < v) {\n\t            v = this[index][i];\n\t            idx.column = i;\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the maximum value of one column\n\t * @param {number} index - Column index\n\t * @returns {number}\n\t */\n\tMatrix.prototype.maxColumn = function maxColumn(index) {\n\t    this.checkColumnIndex(index);\n\t    var v = -Infinity;\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        if (this[i][index] > v) {\n\t            v = this[i][index];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the maximum value of one column\n\t * @param {number} index - Column index\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.maxColumnIndex = function maxColumnIndex(index) {\n\t    this.checkColumnIndex(index);\n\t    var v = -Infinity;\n\t    var idx = {\n\t        row: 0,\n\t        column: index\n\t    };\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        if (this[i][index] > v) {\n\t            v = this[i][index];\n\t            idx.row = i;\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns the minimum value of one column\n\t * @param {number} index - Column index\n\t * @returns {number}\n\t */\n\tMatrix.prototype.minColumn = function minColumn(index) {\n\t    this.checkColumnIndex(index);\n\t    var v = Infinity;\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        if (this[i][index] < v) {\n\t            v = this[i][index];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the index of the minimum value of one column\n\t * @param {number} index - Column index\n\t * @returns {MatrixIndex}\n\t */\n\tMatrix.prototype.minColumnIndex = function minColumnIndex(index) {\n\t    this.checkColumnIndex(index);\n\t    var v = Infinity;\n\t    var idx = {\n\t        row: 0,\n\t        column: index\n\t    };\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        if (this[i][index] < v) {\n\t            v = this[i][index];\n\t            idx.row = i;\n\t        }\n\t    }\n\t    return idx;\n\t};\n\t\n\t/**\n\t * Returns an array containing the diagonal values of the matrix\n\t * @returns {Array}\n\t */\n\tMatrix.prototype.diag = function diag() {\n\t    if (!this.isSquare())\n\t        throw new TypeError('Only square matrices have a diagonal.');\n\t    var diag = new Array(this.rows);\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        diag[i] = this[i][i];\n\t    }\n\t    return diag;\n\t};\n\t\n\t/**\n\t * Returns the sum of all elements of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.sum = function sum() {\n\t    var v = 0;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            v += this[i][j];\n\t        }\n\t    }\n\t    return v;\n\t};\n\t\n\t/**\n\t * Returns the mean of all elements of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.mean = function mean() {\n\t    return this.sum() / this.size;\n\t};\n\t\n\t/**\n\t * Returns the product of all elements of the matrix\n\t * @returns {number}\n\t */\n\tMatrix.prototype.prod = function prod() {\n\t    var prod = 1;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            prod *= this[i][j];\n\t        }\n\t    }\n\t    return prod;\n\t};\n\t\n\t/**\n\t * Computes the cumulative sum of the matrix elements (in place, row by row)\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.cumulativeSum = function cumulativeSum() {\n\t    var sum = 0;\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            sum += this[i][j];\n\t            this[i][j] = sum;\n\t        }\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Computes the dot (scalar) product between the matrix and another\n\t * @param {Matrix} other vector\n\t * @returns {number}\n\t */\n\tMatrix.prototype.dot = function dot(other) {\n\t    if (this.size !== other.size)\n\t        throw new RangeError('vectors do not have the same size');\n\t    var vector1 = this.to1DArray();\n\t    var vector2 = other.to1DArray();\n\t    var dot = 0, l = vector1.length;\n\t    for (var i = 0; i < l; i++) {\n\t        dot += vector1[i] * vector2[i];\n\t    }\n\t    return dot;\n\t};\n\t\n\t/**\n\t * Returns the matrix product between this and other\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.mmul = function mmul(other) {\n\t    if (!Matrix.isMatrix(other))\n\t        throw new TypeError('parameter \"other\" must be a matrix');\n\t    if (this.columns !== other.rows)\n\t        console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');\n\t\n\t    var m = this.rows, n = this.columns, p = other.columns;\n\t    var result = new Matrix(m, p);\n\t\n\t    var Bcolj = new Array(n);\n\t    var i, j, k;\n\t    for (j = 0; j < p; j++) {\n\t        for (k = 0; k < n; k++)\n\t            Bcolj[k] = other[k][j];\n\t\n\t        for (i = 0; i < m; i++) {\n\t            var Arowi = this[i];\n\t\n\t            var s = 0;\n\t            for (k = 0; k < n; k++)\n\t                s += Arowi[k] * Bcolj[k];\n\t\n\t            result[i][j] = s;\n\t        }\n\t    }\n\t    return result;\n\t};\n\t\n\t/**\n\t * Sorts the rows (in place)\n\t * @param {function} compareFunction - usual Array.prototype.sort comparison function\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.sortRows = function sortRows(compareFunction) {\n\t    for (var i = 0, ii = this.rows; i < ii; i++) {\n\t        this[i].sort(compareFunction);\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Sorts the columns (in place)\n\t * @param {function} compareFunction - usual Array.prototype.sort comparison function\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.sortColumns = function sortColumns(compareFunction) {\n\t    for (var i = 0, ii = this.columns; i < ii; i++) {\n\t        this.setColumn(i, this.getColumn(i).sort(compareFunction));\n\t    }\n\t    return this;\n\t};\n\t\n\t/**\n\t * Transposes the matrix and returns a new one containing the result\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.transpose = function transpose() {\n\t    var result = new Matrix(this.columns, this.rows);\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            result[j][i] = this[i][j];\n\t        }\n\t    }\n\t    return result;\n\t};\n\t\n\t/**\n\t * Returns a subset of the matrix\n\t * @param {number} startRow - First row index\n\t * @param {number} endRow - Last row index\n\t * @param {number} startColumn - First column index\n\t * @param {number} endColumn - Last column index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.subMatrix = function subMatrix(startRow, endRow, startColumn, endColumn) {\n\t    if ((startRow > endRow) || (startColumn > endColumn) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns))\n\t        throw new RangeError('Argument out of range');\n\t    var newMatrix = new Matrix(endRow - startRow + 1, endColumn - startColumn + 1);\n\t    for (var i = startRow; i <= endRow; i++) {\n\t        for (var j = startColumn; j <= endColumn; j++) {\n\t            newMatrix[i - startRow][j - startColumn] = this[i][j];\n\t        }\n\t    }\n\t    return newMatrix;\n\t};\n\t\n\t/**\n\t * Returns a subset of the matrix based on an array of row indices\n\t * @param {Array} indices - Array containing the row indices\n\t * @param {number} [startColumn = 0] - First column index\n\t * @param {number} [endColumn = this.columns-1] - Last column index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.subMatrixRow = function subMatrixRow(indices, startColumn, endColumn) {\n\t    if (typeof startColumn === 'undefined') {\n\t        startColumn = 0;\n\t        endColumn = this.columns - 1;\n\t    } else if (typeof endColumn === 'undefined') {\n\t        endColumn = this.columns - 1;\n\t    }\n\t    if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns))\n\t        throw new RangeError('Argument out of range.');\n\t    var l = indices.length, rows = this.rows,\n\t        X = new Matrix(l, endColumn - startColumn + 1);\n\t    for (var i = 0; i < l; i++) {\n\t        for (var j = startColumn; j <= endColumn; j++) {\n\t            if ((indices[i] < 0) || (indices[i] >= rows))\n\t                throw new RangeError('Argument out of range.');\n\t            X[i][j - startColumn] = this[indices[i]][j];\n\t        }\n\t    }\n\t    return X;\n\t};\n\t\n\t/**\n\t * Returns a subset of the matrix based on an array of column indices\n\t * @param {Array} indices - Array containing the column indices\n\t * @param {number} [startRow = 0] - First row index\n\t * @param {number} [endRow = this.rows-1] - Last row index\n\t * @returns {Matrix}\n\t */\n\tMatrix.prototype.subMatrixColumn = function subMatrixColumn(indices, startRow, endRow) {\n\t    if (typeof startRow === 'undefined') {\n\t        startRow = 0;\n\t        endRow = this.rows - 1;\n\t    } else if (typeof endRow === 'undefined') {\n\t        endRow = this.rows - 1;\n\t    }\n\t    if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows))\n\t        throw new RangeError('Argument out of range.');\n\t    var l = indices.length, columns = this.columns,\n\t        X = new Matrix(endRow - startRow + 1, l);\n\t    for (var i = 0; i < l; i++) {\n\t        for (var j = startRow; j <= endRow; j++) {\n\t            if ((indices[i] < 0) || (indices[i] >= columns))\n\t                throw new RangeError('Argument out of range.');\n\t            X[j - startRow][i] = this[j][indices[i]];\n\t        }\n\t    }\n\t    return X;\n\t};\n\t\n\t/**\n\t * Returns the trace of the matrix (sum of the diagonal elements)\n\t * @returns {number}\n\t */\n\tMatrix.prototype.trace = function trace() {\n\t    if (!this.isSquare())\n\t        throw new TypeError('The matrix is not square');\n\t    var trace = 0, i = 0, l = this.rows;\n\t    for (; i < l; i++) {\n\t        trace += this[i][i];\n\t    }\n\t    return trace;\n\t};\n\t\n\t/**\n\t * Sets each element of the matrix to its absolute value\n\t * @returns {Matrix} this\n\t */\n\tMatrix.prototype.abs = function abs() {\n\t    var ii = this.rows, jj = this.columns;\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            this[i][j] = Math.abs(this[i][j]);\n\t        }\n\t    }\n\t};\n\t\n\tmodule.exports = Matrix;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(10);\n\t\n\tvar SingularValueDecomposition = __webpack_require__(12);\n\tvar EigenvalueDecomposition = __webpack_require__(14);\n\tvar LuDecomposition = __webpack_require__(15);\n\tvar QrDecomposition = __webpack_require__(16);\n\tvar CholeskyDecomposition = __webpack_require__(17);\n\t\n\tfunction inverse(matrix) {\n\t    return solve(matrix, Matrix.eye(matrix.rows));\n\t}\n\t\n\tMatrix.prototype.inverse = function () {\n\t    return inverse(this);\n\t};\n\t\n\tfunction solve(leftHandSide, rightHandSide) {\n\t    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).solve(rightHandSide);\n\t}\n\t\n\tMatrix.prototype.solve = function (other) {\n\t    return solve(this, other);\n\t};\n\t\n\tmodule.exports = {\n\t    SingularValueDecomposition: SingularValueDecomposition,\n\t    SVD: SingularValueDecomposition,\n\t    EigenvalueDecomposition: EigenvalueDecomposition,\n\t    EVD: EigenvalueDecomposition,\n\t    LuDecomposition: LuDecomposition,\n\t    LU: LuDecomposition,\n\t    QrDecomposition: QrDecomposition,\n\t    QR: QrDecomposition,\n\t    CholeskyDecomposition: CholeskyDecomposition,\n\t    CHO: CholeskyDecomposition,\n\t    inverse: inverse,\n\t    solve: solve\n\t};\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(10);\n\tvar hypotenuse = __webpack_require__(13).hypotenuse;\n\t\n\t// https://github.com/lutzroeder/Mapack/blob/master/Source/SingularValueDecomposition.cs\n\tfunction SingularValueDecomposition(value, options) {\n\t    if (!(this instanceof SingularValueDecomposition)) {\n\t        return new SingularValueDecomposition(value, options);\n\t    }\n\t    value = Matrix.checkMatrix(value);\n\t\n\t    options = options || {};\n\t\n\t    var a = value.clone(),\n\t        m = value.rows,\n\t        n = value.columns,\n\t        nu = Math.min(m, n);\n\t\n\t    var wantu = true, wantv = true;\n\t    if (options.computeLeftSingularVectors === false)\n\t        wantu = false;\n\t    if (options.computeRightSingularVectors === false)\n\t        wantv = false;\n\t    var autoTranspose = options.autoTranspose === true;\n\t\n\t    var swapped = false;\n\t    if (m < n) {\n\t        if (!autoTranspose) {\n\t            console.warn('Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose');\n\t        } else {\n\t            a = a.transpose();\n\t            m = a.rows;\n\t            n = a.columns;\n\t            swapped = true;\n\t            var aux = wantu;\n\t            wantu = wantv;\n\t            wantv = aux;\n\t        }\n\t    }\n\t\n\t    var s = new Array(Math.min(m + 1, n)),\n\t        U = Matrix.zeros(m, nu),\n\t        V = Matrix.zeros(n, n),\n\t        e = new Array(n),\n\t        work = new Array(m);\n\t\n\t    var nct = Math.min(m - 1, n);\n\t    var nrt = Math.max(0, Math.min(n - 2, m));\n\t\n\t    var i, j, k, p, t, ks, f, cs, sn, max, kase,\n\t        scale, sp, spm1, epm1, sk, ek, b, c, shift, g;\n\t\n\t    for (k = 0, max = Math.max(nct, nrt); k < max; k++) {\n\t        if (k < nct) {\n\t            s[k] = 0;\n\t            for (i = k; i < m; i++) {\n\t                s[k] = hypotenuse(s[k], a[i][k]);\n\t            }\n\t            if (s[k] !== 0) {\n\t                if (a[k][k] < 0) {\n\t                    s[k] = -s[k];\n\t                }\n\t                for (i = k; i < m; i++) {\n\t                    a[i][k] /= s[k];\n\t                }\n\t                a[k][k] += 1;\n\t            }\n\t            s[k] = -s[k];\n\t        }\n\t\n\t        for (j = k + 1; j < n; j++) {\n\t            if ((k < nct) && (s[k] !== 0)) {\n\t                t = 0;\n\t                for (i = k; i < m; i++) {\n\t                    t += a[i][k] * a[i][j];\n\t                }\n\t                t = -t / a[k][k];\n\t                for (i = k; i < m; i++) {\n\t                    a[i][j] += t * a[i][k];\n\t                }\n\t            }\n\t            e[j] = a[k][j];\n\t        }\n\t\n\t        if (wantu && (k < nct)) {\n\t            for (i = k; i < m; i++) {\n\t                U[i][k] = a[i][k];\n\t            }\n\t        }\n\t\n\t        if (k < nrt) {\n\t            e[k] = 0;\n\t            for (i = k + 1; i < n; i++) {\n\t                e[k] = hypotenuse(e[k], e[i]);\n\t            }\n\t            if (e[k] !== 0) {\n\t                if (e[k + 1] < 0)\n\t                    e[k] = -e[k];\n\t                for (i = k + 1; i < n; i++) {\n\t                    e[i] /= e[k];\n\t                }\n\t                e[k + 1] += 1;\n\t            }\n\t            e[k] = -e[k];\n\t            if ((k + 1 < m) && (e[k] !== 0)) {\n\t                for (i = k + 1; i < m; i++) {\n\t                    work[i] = 0;\n\t                }\n\t                for (j = k + 1; j < n; j++) {\n\t                    for (i = k + 1; i < m; i++) {\n\t                        work[i] += e[j] * a[i][j];\n\t                    }\n\t                }\n\t                for (j = k + 1; j < n; j++) {\n\t                    t = -e[j] / e[k + 1];\n\t                    for (i = k + 1; i < m; i++) {\n\t                        a[i][j] += t * work[i];\n\t                    }\n\t                }\n\t            }\n\t            if (wantv) {\n\t                for (i = k + 1; i < n; i++) {\n\t                    V[i][k] = e[i];\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    p = Math.min(n, m + 1);\n\t    if (nct < n) {\n\t        s[nct] = a[nct][nct];\n\t    }\n\t    if (m < p) {\n\t        s[p - 1] = 0;\n\t    }\n\t    if (nrt + 1 < p) {\n\t        e[nrt] = a[nrt][p - 1];\n\t    }\n\t    e[p - 1] = 0;\n\t\n\t    if (wantu) {\n\t        for (j = nct; j < nu; j++) {\n\t            for (i = 0; i < m; i++) {\n\t                U[i][j] = 0;\n\t            }\n\t            U[j][j] = 1;\n\t        }\n\t        for (k = nct - 1; k >= 0; k--) {\n\t            if (s[k] !== 0) {\n\t                for (j = k + 1; j < nu; j++) {\n\t                    t = 0;\n\t                    for (i = k; i < m; i++) {\n\t                        t += U[i][k] * U[i][j];\n\t                    }\n\t                    t = -t / U[k][k];\n\t                    for (i = k; i < m; i++) {\n\t                        U[i][j] += t * U[i][k];\n\t                    }\n\t                }\n\t                for (i = k; i < m; i++) {\n\t                    U[i][k] = -U[i][k];\n\t                }\n\t                U[k][k] = 1 + U[k][k];\n\t                for (i = 0; i < k - 1; i++) {\n\t                    U[i][k] = 0;\n\t                }\n\t            } else {\n\t                for (i = 0; i < m; i++) {\n\t                    U[i][k] = 0;\n\t                }\n\t                U[k][k] = 1;\n\t            }\n\t        }\n\t    }\n\t\n\t    if (wantv) {\n\t        for (k = n - 1; k >= 0; k--) {\n\t            if ((k < nrt) && (e[k] !== 0)) {\n\t                for (j = k + 1; j < n; j++) {\n\t                    t = 0;\n\t                    for (i = k + 1; i < n; i++) {\n\t                        t += V[i][k] * V[i][j];\n\t                    }\n\t                    t = -t / V[k + 1][k];\n\t                    for (i = k + 1; i < n; i++) {\n\t                        V[i][j] += t * V[i][k];\n\t                    }\n\t                }\n\t            }\n\t            for (i = 0; i < n; i++) {\n\t                V[i][k] = 0;\n\t            }\n\t            V[k][k] = 1;\n\t        }\n\t    }\n\t\n\t    var pp = p - 1,\n\t        iter = 0,\n\t        eps = Math.pow(2, -52);\n\t    while (p > 0) {\n\t        for (k = p - 2; k >= -1; k--) {\n\t            if (k === -1) {\n\t                break;\n\t            }\n\t            if (Math.abs(e[k]) <= eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {\n\t                e[k] = 0;\n\t                break;\n\t            }\n\t        }\n\t        if (k === p - 2) {\n\t            kase = 4;\n\t        } else {\n\t            for (ks = p - 1; ks >= k; ks--) {\n\t                if (ks === k) {\n\t                    break;\n\t                }\n\t                t = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);\n\t                if (Math.abs(s[ks]) <= eps * t) {\n\t                    s[ks] = 0;\n\t                    break;\n\t                }\n\t            }\n\t            if (ks === k) {\n\t                kase = 3;\n\t            } else if (ks === p - 1) {\n\t                kase = 1;\n\t            } else {\n\t                kase = 2;\n\t                k = ks;\n\t            }\n\t        }\n\t\n\t        k++;\n\t\n\t        switch (kase) {\n\t            case 1: {\n\t                f = e[p - 2];\n\t                e[p - 2] = 0;\n\t                for (j = p - 2; j >= k; j--) {\n\t                    t = hypotenuse(s[j], f);\n\t                    cs = s[j] / t;\n\t                    sn = f / t;\n\t                    s[j] = t;\n\t                    if (j !== k) {\n\t                        f = -sn * e[j - 1];\n\t                        e[j - 1] = cs * e[j - 1];\n\t                    }\n\t                    if (wantv) {\n\t                        for (i = 0; i < n; i++) {\n\t                            t = cs * V[i][j] + sn * V[i][p - 1];\n\t                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n\t                            V[i][j] = t;\n\t                        }\n\t                    }\n\t                }\n\t                break;\n\t            }\n\t            case 2 : {\n\t                f = e[k - 1];\n\t                e[k - 1] = 0;\n\t                for (j = k; j < p; j++) {\n\t                    t = hypotenuse(s[j], f);\n\t                    cs = s[j] / t;\n\t                    sn = f / t;\n\t                    s[j] = t;\n\t                    f = -sn * e[j];\n\t                    e[j] = cs * e[j];\n\t                    if (wantu) {\n\t                        for (i = 0; i < m; i++) {\n\t                            t = cs * U[i][j] + sn * U[i][k - 1];\n\t                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n\t                            U[i][j] = t;\n\t                        }\n\t                    }\n\t                }\n\t                break;\n\t            }\n\t            case 3 : {\n\t                scale = Math.max(Math.max(Math.max(Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2])), Math.abs(e[p - 2])), Math.abs(s[k])), Math.abs(e[k]));\n\t                sp = s[p - 1] / scale;\n\t                spm1 = s[p - 2] / scale;\n\t                epm1 = e[p - 2] / scale;\n\t                sk = s[k] / scale;\n\t                ek = e[k] / scale;\n\t                b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;\n\t                c = (sp * epm1) * (sp * epm1);\n\t                shift = 0;\n\t                if ((b !== 0) || (c !== 0)) {\n\t                    shift = Math.sqrt(b * b + c);\n\t                    if (b < 0) {\n\t                        shift = -shift;\n\t                    }\n\t                    shift = c / (b + shift);\n\t                }\n\t                f = (sk + sp) * (sk - sp) + shift;\n\t                g = sk * ek;\n\t                for (j = k; j < p - 1; j++) {\n\t                    t = hypotenuse(f, g);\n\t                    cs = f / t;\n\t                    sn = g / t;\n\t                    if (j !== k) {\n\t                        e[j - 1] = t;\n\t                    }\n\t                    f = cs * s[j] + sn * e[j];\n\t                    e[j] = cs * e[j] - sn * s[j];\n\t                    g = sn * s[j + 1];\n\t                    s[j + 1] = cs * s[j + 1];\n\t                    if (wantv) {\n\t                        for (i = 0; i < n; i++) {\n\t                            t = cs * V[i][j] + sn * V[i][j + 1];\n\t                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n\t                            V[i][j] = t;\n\t                        }\n\t                    }\n\t                    t = hypotenuse(f, g);\n\t                    cs = f / t;\n\t                    sn = g / t;\n\t                    s[j] = t;\n\t                    f = cs * e[j] + sn * s[j + 1];\n\t                    s[j + 1] = -sn * e[j] + cs * s[j + 1];\n\t                    g = sn * e[j + 1];\n\t                    e[j + 1] = cs * e[j + 1];\n\t                    if (wantu && (j < m - 1)) {\n\t                        for (i = 0; i < m; i++) {\n\t                            t = cs * U[i][j] + sn * U[i][j + 1];\n\t                            U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n\t                            U[i][j] = t;\n\t                        }\n\t                    }\n\t                }\n\t                e[p - 2] = f;\n\t                iter = iter + 1;\n\t                break;\n\t            }\n\t            case 4: {\n\t                if (s[k] <= 0) {\n\t                    s[k] = (s[k] < 0 ? -s[k] : 0);\n\t                    if (wantv) {\n\t                        for (i = 0; i <= pp; i++) {\n\t                            V[i][k] = -V[i][k];\n\t                        }\n\t                    }\n\t                }\n\t                while (k < pp) {\n\t                    if (s[k] >= s[k + 1]) {\n\t                        break;\n\t                    }\n\t                    t = s[k];\n\t                    s[k] = s[k + 1];\n\t                    s[k + 1] = t;\n\t                    if (wantv && (k < n - 1)) {\n\t                        for (i = 0; i < n; i++) {\n\t                            t = V[i][k + 1];\n\t                            V[i][k + 1] = V[i][k];\n\t                            V[i][k] = t;\n\t                        }\n\t                    }\n\t                    if (wantu && (k < m - 1)) {\n\t                        for (i = 0; i < m; i++) {\n\t                            t = U[i][k + 1];\n\t                            U[i][k + 1] = U[i][k];\n\t                            U[i][k] = t;\n\t                        }\n\t                    }\n\t                    k++;\n\t                }\n\t                iter = 0;\n\t                p--;\n\t                break;\n\t            }\n\t        }\n\t    }\n\t\n\t    if (swapped) {\n\t        var tmp = V;\n\t        V = U;\n\t        U = tmp;\n\t    }\n\t\n\t    this.m = m;\n\t    this.n = n;\n\t    this.s = s;\n\t    this.U = U;\n\t    this.V = V;\n\t}\n\t\n\tSingularValueDecomposition.prototype = {\n\t    get condition() {\n\t        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];\n\t    },\n\t    get norm2() {\n\t        return this.s[0];\n\t    },\n\t    get rank() {\n\t        var eps = Math.pow(2, -52),\n\t            tol = Math.max(this.m, this.n) * this.s[0] * eps,\n\t            r = 0,\n\t            s = this.s;\n\t        for (var i = 0, ii = s.length; i < ii; i++) {\n\t            if (s[i] > tol) {\n\t                r++;\n\t            }\n\t        }\n\t        return r;\n\t    },\n\t    get diagonal() {\n\t        return this.s;\n\t    },\n\t    // https://github.com/accord-net/framework/blob/development/Sources/Accord.Math/Decompositions/SingularValueDecomposition.cs\n\t    get threshold() {\n\t        return (Math.pow(2, -52) / 2) * Math.max(this.m, this.n) * this.s[0];\n\t    },\n\t    get leftSingularVectors() {\n\t        return this.U;\n\t    },\n\t    get rightSingularVectors() {\n\t        return this.V;\n\t    },\n\t    get diagonalMatrix() {\n\t        return Matrix.diag(this.s);\n\t    },\n\t    solve: function (value) {\n\t\n\t        var Y = value,\n\t            e = this.threshold,\n\t            scols = this.s.length,\n\t            Ls = Matrix.zeros(scols, scols),\n\t            i;\n\t\n\t        for (i = 0; i < scols; i++) {\n\t            if (Math.abs(this.s[i]) <= e) {\n\t                Ls[i][i] = 0;\n\t            } else {\n\t                Ls[i][i] = 1 / this.s[i];\n\t            }\n\t        }\n\t\n\t\n\t        var VL = this.V.mmul(Ls),\n\t            vrows = this.V.rows,\n\t            urows = this.U.rows,\n\t            VLU = Matrix.zeros(vrows, urows),\n\t            j, k, sum;\n\t\n\t        for (i = 0; i < vrows; i++) {\n\t            for (j = 0; j < urows; j++) {\n\t                sum = 0;\n\t                for (k = 0; k < scols; k++) {\n\t                    sum += VL[i][k] * this.U[j][k];\n\t                }\n\t                VLU[i][j] = sum;\n\t            }\n\t        }\n\t\n\t        return VLU.mmul(Y);\n\t    },\n\t    solveForDiagonal: function (value) {\n\t        return this.solve(Matrix.diag(value));\n\t    },\n\t    inverse: function () {\n\t        var e = this.threshold,\n\t            vrows = this.V.rows,\n\t            vcols = this.V.columns,\n\t            X = new Matrix(vrows, this.s.length),\n\t            i, j;\n\t\n\t        for (i = 0; i < vrows; i++) {\n\t            for (j = 0; j < vcols; j++) {\n\t                if (Math.abs(this.s[j]) > e) {\n\t                    X[i][j] = this.V[i][j] / this.s[j];\n\t                } else {\n\t                    X[i][j] = 0;\n\t                }\n\t            }\n\t        }\n\t\n\t        var urows = this.U.rows,\n\t            ucols = this.U.columns,\n\t            Y = new Matrix(vrows, urows),\n\t            k, sum;\n\t\n\t        for (i = 0; i < vrows; i++) {\n\t            for (j = 0; j < urows; j++) {\n\t                sum = 0;\n\t                for (k = 0; k < ucols; k++) {\n\t                    sum += X[i][k] * this.U[j][k];\n\t                }\n\t                Y[i][j] = sum;\n\t            }\n\t        }\n\t\n\t        return Y;\n\t    }\n\t};\n\t\n\tmodule.exports = SingularValueDecomposition;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.hypotenuse = function hypotenuse(a, b) {\n\t    var r;\n\t    if (Math.abs(a) > Math.abs(b)) {\n\t        r = b / a;\n\t        return Math.abs(a) * Math.sqrt(1 + r * r);\n\t    }\n\t    if (b !== 0) {\n\t        r = a / b;\n\t        return Math.abs(b) * Math.sqrt(1 + r * r);\n\t    }\n\t    return 0;\n\t};\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(10);\n\tvar hypotenuse = __webpack_require__(13).hypotenuse;\n\t\n\t// https://github.com/lutzroeder/Mapack/blob/master/Source/EigenvalueDecomposition.cs\n\tfunction EigenvalueDecomposition(matrix) {\n\t    if (!(this instanceof EigenvalueDecomposition)) {\n\t        return new EigenvalueDecomposition(matrix);\n\t    }\n\t    matrix = Matrix.checkMatrix(matrix);\n\t    if (!matrix.isSquare()) {\n\t        throw new Error('Matrix is not a square matrix');\n\t    }\n\t\n\t    var n = matrix.columns,\n\t        V = Matrix.zeros(n, n),\n\t        d = new Array(n),\n\t        e = new Array(n),\n\t        value = matrix,\n\t        i, j;\n\t\n\t    if (matrix.isSymmetric()) {\n\t        for (i = 0; i < n; i++) {\n\t            for (j = 0; j < n; j++) {\n\t                V[i][j] = value[i][j];\n\t            }\n\t        }\n\t        tred2(n, e, d, V);\n\t        tql2(n, e, d, V);\n\t    }\n\t    else {\n\t        var H = Matrix.zeros(n, n),\n\t            ort = new Array(n);\n\t        for (j = 0; j < n; j++) {\n\t            for (i = 0; i < n; i++) {\n\t                H[i][j] = value[i][j];\n\t            }\n\t        }\n\t        orthes(n, H, ort, V);\n\t        hqr2(n, e, d, V, H);\n\t    }\n\t\n\t    this.n = n;\n\t    this.e = e;\n\t    this.d = d;\n\t    this.V = V;\n\t}\n\t\n\tEigenvalueDecomposition.prototype = {\n\t    get realEigenvalues() {\n\t        return this.d;\n\t    },\n\t    get imaginaryEigenvalues() {\n\t        return this.e;\n\t    },\n\t    get eigenvectorMatrix() {\n\t        return this.V;\n\t    },\n\t    get diagonalMatrix() {\n\t        var n = this.n,\n\t            e = this.e,\n\t            d = this.d,\n\t            X = new Matrix(n, n),\n\t            i, j;\n\t        for (i = 0; i < n; i++) {\n\t            for (j = 0; j < n; j++) {\n\t                X[i][j] = 0;\n\t            }\n\t            X[i][i] = d[i];\n\t            if (e[i] > 0) {\n\t                X[i][i + 1] = e[i];\n\t            }\n\t            else if (e[i] < 0) {\n\t                X[i][i - 1] = e[i];\n\t            }\n\t        }\n\t        return X;\n\t    }\n\t};\n\t\n\tfunction tred2(n, e, d, V) {\n\t\n\t    var f, g, h, i, j, k,\n\t        hh, scale;\n\t\n\t    for (j = 0; j < n; j++) {\n\t        d[j] = V[n - 1][j];\n\t    }\n\t\n\t    for (i = n - 1; i > 0; i--) {\n\t        scale = 0;\n\t        h = 0;\n\t        for (k = 0; k < i; k++) {\n\t            scale = scale + Math.abs(d[k]);\n\t        }\n\t\n\t        if (scale === 0) {\n\t            e[i] = d[i - 1];\n\t            for (j = 0; j < i; j++) {\n\t                d[j] = V[i - 1][j];\n\t                V[i][j] = 0;\n\t                V[j][i] = 0;\n\t            }\n\t        } else {\n\t            for (k = 0; k < i; k++) {\n\t                d[k] /= scale;\n\t                h += d[k] * d[k];\n\t            }\n\t\n\t            f = d[i - 1];\n\t            g = Math.sqrt(h);\n\t            if (f > 0) {\n\t                g = -g;\n\t            }\n\t\n\t            e[i] = scale * g;\n\t            h = h - f * g;\n\t            d[i - 1] = f - g;\n\t            for (j = 0; j < i; j++) {\n\t                e[j] = 0;\n\t            }\n\t\n\t            for (j = 0; j < i; j++) {\n\t                f = d[j];\n\t                V[j][i] = f;\n\t                g = e[j] + V[j][j] * f;\n\t                for (k = j + 1; k <= i - 1; k++) {\n\t                    g += V[k][j] * d[k];\n\t                    e[k] += V[k][j] * f;\n\t                }\n\t                e[j] = g;\n\t            }\n\t\n\t            f = 0;\n\t            for (j = 0; j < i; j++) {\n\t                e[j] /= h;\n\t                f += e[j] * d[j];\n\t            }\n\t\n\t            hh = f / (h + h);\n\t            for (j = 0; j < i; j++) {\n\t                e[j] -= hh * d[j];\n\t            }\n\t\n\t            for (j = 0; j < i; j++) {\n\t                f = d[j];\n\t                g = e[j];\n\t                for (k = j; k <= i - 1; k++) {\n\t                    V[k][j] -= (f * e[k] + g * d[k]);\n\t                }\n\t                d[j] = V[i - 1][j];\n\t                V[i][j] = 0;\n\t            }\n\t        }\n\t        d[i] = h;\n\t    }\n\t\n\t    for (i = 0; i < n - 1; i++) {\n\t        V[n - 1][i] = V[i][i];\n\t        V[i][i] = 1;\n\t        h = d[i + 1];\n\t        if (h !== 0) {\n\t            for (k = 0; k <= i; k++) {\n\t                d[k] = V[k][i + 1] / h;\n\t            }\n\t\n\t            for (j = 0; j <= i; j++) {\n\t                g = 0;\n\t                for (k = 0; k <= i; k++) {\n\t                    g += V[k][i + 1] * V[k][j];\n\t                }\n\t                for (k = 0; k <= i; k++) {\n\t                    V[k][j] -= g * d[k];\n\t                }\n\t            }\n\t        }\n\t\n\t        for (k = 0; k <= i; k++) {\n\t            V[k][i + 1] = 0;\n\t        }\n\t    }\n\t\n\t    for (j = 0; j < n; j++) {\n\t        d[j] = V[n - 1][j];\n\t        V[n - 1][j] = 0;\n\t    }\n\t\n\t    V[n - 1][n - 1] = 1;\n\t    e[0] = 0;\n\t}\n\t\n\tfunction tql2(n, e, d, V) {\n\t\n\t    var g, h, i, j, k, l, m, p, r,\n\t        dl1, c, c2, c3, el1, s, s2,\n\t        iter;\n\t\n\t    for (i = 1; i < n; i++) {\n\t        e[i - 1] = e[i];\n\t    }\n\t\n\t    e[n - 1] = 0;\n\t\n\t    var f = 0,\n\t        tst1 = 0,\n\t        eps = Math.pow(2, -52);\n\t\n\t    for (l = 0; l < n; l++) {\n\t        tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));\n\t        m = l;\n\t        while (m < n) {\n\t            if (Math.abs(e[m]) <= eps * tst1) {\n\t                break;\n\t            }\n\t            m++;\n\t        }\n\t\n\t        if (m > l) {\n\t            iter = 0;\n\t            do {\n\t                iter = iter + 1;\n\t\n\t                g = d[l];\n\t                p = (d[l + 1] - g) / (2 * e[l]);\n\t                r = hypotenuse(p, 1);\n\t                if (p < 0) {\n\t                    r = -r;\n\t                }\n\t\n\t                d[l] = e[l] / (p + r);\n\t                d[l + 1] = e[l] * (p + r);\n\t                dl1 = d[l + 1];\n\t                h = g - d[l];\n\t                for (i = l + 2; i < n; i++) {\n\t                    d[i] -= h;\n\t                }\n\t\n\t                f = f + h;\n\t\n\t                p = d[m];\n\t                c = 1;\n\t                c2 = c;\n\t                c3 = c;\n\t                el1 = e[l + 1];\n\t                s = 0;\n\t                s2 = 0;\n\t                for (i = m - 1; i >= l; i--) {\n\t                    c3 = c2;\n\t                    c2 = c;\n\t                    s2 = s;\n\t                    g = c * e[i];\n\t                    h = c * p;\n\t                    r = hypotenuse(p, e[i]);\n\t                    e[i + 1] = s * r;\n\t                    s = e[i] / r;\n\t                    c = p / r;\n\t                    p = c * d[i] - s * g;\n\t                    d[i + 1] = h + s * (c * g + s * d[i]);\n\t\n\t                    for (k = 0; k < n; k++) {\n\t                        h = V[k][i + 1];\n\t                        V[k][i + 1] = s * V[k][i] + c * h;\n\t                        V[k][i] = c * V[k][i] - s * h;\n\t                    }\n\t                }\n\t\n\t                p = -s * s2 * c3 * el1 * e[l] / dl1;\n\t                e[l] = s * p;\n\t                d[l] = c * p;\n\t\n\t            }\n\t            while (Math.abs(e[l]) > eps * tst1);\n\t        }\n\t        d[l] = d[l] + f;\n\t        e[l] = 0;\n\t    }\n\t\n\t    for (i = 0; i < n - 1; i++) {\n\t        k = i;\n\t        p = d[i];\n\t        for (j = i + 1; j < n; j++) {\n\t            if (d[j] < p) {\n\t                k = j;\n\t                p = d[j];\n\t            }\n\t        }\n\t\n\t        if (k !== i) {\n\t            d[k] = d[i];\n\t            d[i] = p;\n\t            for (j = 0; j < n; j++) {\n\t                p = V[j][i];\n\t                V[j][i] = V[j][k];\n\t                V[j][k] = p;\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction orthes(n, H, ort, V) {\n\t\n\t    var low = 0,\n\t        high = n - 1,\n\t        f, g, h, i, j, m,\n\t        scale;\n\t\n\t    for (m = low + 1; m <= high - 1; m++) {\n\t        scale = 0;\n\t        for (i = m; i <= high; i++) {\n\t            scale = scale + Math.abs(H[i][m - 1]);\n\t        }\n\t\n\t        if (scale !== 0) {\n\t            h = 0;\n\t            for (i = high; i >= m; i--) {\n\t                ort[i] = H[i][m - 1] / scale;\n\t                h += ort[i] * ort[i];\n\t            }\n\t\n\t            g = Math.sqrt(h);\n\t            if (ort[m] > 0) {\n\t                g = -g;\n\t            }\n\t\n\t            h = h - ort[m] * g;\n\t            ort[m] = ort[m] - g;\n\t\n\t            for (j = m; j < n; j++) {\n\t                f = 0;\n\t                for (i = high; i >= m; i--) {\n\t                    f += ort[i] * H[i][j];\n\t                }\n\t\n\t                f = f / h;\n\t                for (i = m; i <= high; i++) {\n\t                    H[i][j] -= f * ort[i];\n\t                }\n\t            }\n\t\n\t            for (i = 0; i <= high; i++) {\n\t                f = 0;\n\t                for (j = high; j >= m; j--) {\n\t                    f += ort[j] * H[i][j];\n\t                }\n\t\n\t                f = f / h;\n\t                for (j = m; j <= high; j++) {\n\t                    H[i][j] -= f * ort[j];\n\t                }\n\t            }\n\t\n\t            ort[m] = scale * ort[m];\n\t            H[m][m - 1] = scale * g;\n\t        }\n\t    }\n\t\n\t    for (i = 0; i < n; i++) {\n\t        for (j = 0; j < n; j++) {\n\t            V[i][j] = (i === j ? 1 : 0);\n\t        }\n\t    }\n\t\n\t    for (m = high - 1; m >= low + 1; m--) {\n\t        if (H[m][m - 1] !== 0) {\n\t            for (i = m + 1; i <= high; i++) {\n\t                ort[i] = H[i][m - 1];\n\t            }\n\t\n\t            for (j = m; j <= high; j++) {\n\t                g = 0;\n\t                for (i = m; i <= high; i++) {\n\t                    g += ort[i] * V[i][j];\n\t                }\n\t\n\t                g = (g / ort[m]) / H[m][m - 1];\n\t                for (i = m; i <= high; i++) {\n\t                    V[i][j] += g * ort[i];\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction hqr2(nn, e, d, V, H) {\n\t    var n = nn - 1,\n\t        low = 0,\n\t        high = nn - 1,\n\t        eps = Math.pow(2, -52),\n\t        exshift = 0,\n\t        norm = 0,\n\t        p = 0,\n\t        q = 0,\n\t        r = 0,\n\t        s = 0,\n\t        z = 0,\n\t        iter = 0,\n\t        i, j, k, l, m, t, w, x, y,\n\t        ra, sa, vr, vi,\n\t        notlast, cdivres;\n\t\n\t    for (i = 0; i < nn; i++) {\n\t        if (i < low || i > high) {\n\t            d[i] = H[i][i];\n\t            e[i] = 0;\n\t        }\n\t\n\t        for (j = Math.max(i - 1, 0); j < nn; j++) {\n\t            norm = norm + Math.abs(H[i][j]);\n\t        }\n\t    }\n\t\n\t    while (n >= low) {\n\t        l = n;\n\t        while (l > low) {\n\t            s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);\n\t            if (s === 0) {\n\t                s = norm;\n\t            }\n\t            if (Math.abs(H[l][l - 1]) < eps * s) {\n\t                break;\n\t            }\n\t            l--;\n\t        }\n\t\n\t        if (l === n) {\n\t            H[n][n] = H[n][n] + exshift;\n\t            d[n] = H[n][n];\n\t            e[n] = 0;\n\t            n--;\n\t            iter = 0;\n\t        } else if (l === n - 1) {\n\t            w = H[n][n - 1] * H[n - 1][n];\n\t            p = (H[n - 1][n - 1] - H[n][n]) / 2;\n\t            q = p * p + w;\n\t            z = Math.sqrt(Math.abs(q));\n\t            H[n][n] = H[n][n] + exshift;\n\t            H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;\n\t            x = H[n][n];\n\t\n\t            if (q >= 0) {\n\t                z = (p >= 0) ? (p + z) : (p - z);\n\t                d[n - 1] = x + z;\n\t                d[n] = d[n - 1];\n\t                if (z !== 0) {\n\t                    d[n] = x - w / z;\n\t                }\n\t                e[n - 1] = 0;\n\t                e[n] = 0;\n\t                x = H[n][n - 1];\n\t                s = Math.abs(x) + Math.abs(z);\n\t                p = x / s;\n\t                q = z / s;\n\t                r = Math.sqrt(p * p + q * q);\n\t                p = p / r;\n\t                q = q / r;\n\t\n\t                for (j = n - 1; j < nn; j++) {\n\t                    z = H[n - 1][j];\n\t                    H[n - 1][j] = q * z + p * H[n][j];\n\t                    H[n][j] = q * H[n][j] - p * z;\n\t                }\n\t\n\t                for (i = 0; i <= n; i++) {\n\t                    z = H[i][n - 1];\n\t                    H[i][n - 1] = q * z + p * H[i][n];\n\t                    H[i][n] = q * H[i][n] - p * z;\n\t                }\n\t\n\t                for (i = low; i <= high; i++) {\n\t                    z = V[i][n - 1];\n\t                    V[i][n - 1] = q * z + p * V[i][n];\n\t                    V[i][n] = q * V[i][n] - p * z;\n\t                }\n\t            } else {\n\t                d[n - 1] = x + p;\n\t                d[n] = x + p;\n\t                e[n - 1] = z;\n\t                e[n] = -z;\n\t            }\n\t\n\t            n = n - 2;\n\t            iter = 0;\n\t        } else {\n\t            x = H[n][n];\n\t            y = 0;\n\t            w = 0;\n\t            if (l < n) {\n\t                y = H[n - 1][n - 1];\n\t                w = H[n][n - 1] * H[n - 1][n];\n\t            }\n\t\n\t            if (iter === 10) {\n\t                exshift += x;\n\t                for (i = low; i <= n; i++) {\n\t                    H[i][i] -= x;\n\t                }\n\t                s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);\n\t                x = y = 0.75 * s;\n\t                w = -0.4375 * s * s;\n\t            }\n\t\n\t            if (iter === 30) {\n\t                s = (y - x) / 2;\n\t                s = s * s + w;\n\t                if (s > 0) {\n\t                    s = Math.sqrt(s);\n\t                    if (y < x) {\n\t                        s = -s;\n\t                    }\n\t                    s = x - w / ((y - x) / 2 + s);\n\t                    for (i = low; i <= n; i++) {\n\t                        H[i][i] -= s;\n\t                    }\n\t                    exshift += s;\n\t                    x = y = w = 0.964;\n\t                }\n\t            }\n\t\n\t            iter = iter + 1;\n\t\n\t            m = n - 2;\n\t            while (m >= l) {\n\t                z = H[m][m];\n\t                r = x - z;\n\t                s = y - z;\n\t                p = (r * s - w) / H[m + 1][m] + H[m][m + 1];\n\t                q = H[m + 1][m + 1] - z - r - s;\n\t                r = H[m + 2][m + 1];\n\t                s = Math.abs(p) + Math.abs(q) + Math.abs(r);\n\t                p = p / s;\n\t                q = q / s;\n\t                r = r / s;\n\t                if (m === l) {\n\t                    break;\n\t                }\n\t                if (Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) < eps * (Math.abs(p) * (Math.abs(H[m - 1][m - 1]) + Math.abs(z) + Math.abs(H[m + 1][m + 1])))) {\n\t                    break;\n\t                }\n\t                m--;\n\t            }\n\t\n\t            for (i = m + 2; i <= n; i++) {\n\t                H[i][i - 2] = 0;\n\t                if (i > m + 2) {\n\t                    H[i][i - 3] = 0;\n\t                }\n\t            }\n\t\n\t            for (k = m; k <= n - 1; k++) {\n\t                notlast = (k !== n - 1);\n\t                if (k !== m) {\n\t                    p = H[k][k - 1];\n\t                    q = H[k + 1][k - 1];\n\t                    r = (notlast ? H[k + 2][k - 1] : 0);\n\t                    x = Math.abs(p) + Math.abs(q) + Math.abs(r);\n\t                    if (x !== 0) {\n\t                        p = p / x;\n\t                        q = q / x;\n\t                        r = r / x;\n\t                    }\n\t                }\n\t\n\t                if (x === 0) {\n\t                    break;\n\t                }\n\t\n\t                s = Math.sqrt(p * p + q * q + r * r);\n\t                if (p < 0) {\n\t                    s = -s;\n\t                }\n\t\n\t                if (s !== 0) {\n\t                    if (k !== m) {\n\t                        H[k][k - 1] = -s * x;\n\t                    } else if (l !== m) {\n\t                        H[k][k - 1] = -H[k][k - 1];\n\t                    }\n\t\n\t                    p = p + s;\n\t                    x = p / s;\n\t                    y = q / s;\n\t                    z = r / s;\n\t                    q = q / p;\n\t                    r = r / p;\n\t\n\t                    for (j = k; j < nn; j++) {\n\t                        p = H[k][j] + q * H[k + 1][j];\n\t                        if (notlast) {\n\t                            p = p + r * H[k + 2][j];\n\t                            H[k + 2][j] = H[k + 2][j] - p * z;\n\t                        }\n\t\n\t                        H[k][j] = H[k][j] - p * x;\n\t                        H[k + 1][j] = H[k + 1][j] - p * y;\n\t                    }\n\t\n\t                    for (i = 0; i <= Math.min(n, k + 3); i++) {\n\t                        p = x * H[i][k] + y * H[i][k + 1];\n\t                        if (notlast) {\n\t                            p = p + z * H[i][k + 2];\n\t                            H[i][k + 2] = H[i][k + 2] - p * r;\n\t                        }\n\t\n\t                        H[i][k] = H[i][k] - p;\n\t                        H[i][k + 1] = H[i][k + 1] - p * q;\n\t                    }\n\t\n\t                    for (i = low; i <= high; i++) {\n\t                        p = x * V[i][k] + y * V[i][k + 1];\n\t                        if (notlast) {\n\t                            p = p + z * V[i][k + 2];\n\t                            V[i][k + 2] = V[i][k + 2] - p * r;\n\t                        }\n\t\n\t                        V[i][k] = V[i][k] - p;\n\t                        V[i][k + 1] = V[i][k + 1] - p * q;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    if (norm === 0) {\n\t        return;\n\t    }\n\t\n\t    for (n = nn - 1; n >= 0; n--) {\n\t        p = d[n];\n\t        q = e[n];\n\t\n\t        if (q === 0) {\n\t            l = n;\n\t            H[n][n] = 1;\n\t            for (i = n - 1; i >= 0; i--) {\n\t                w = H[i][i] - p;\n\t                r = 0;\n\t                for (j = l; j <= n; j++) {\n\t                    r = r + H[i][j] * H[j][n];\n\t                }\n\t\n\t                if (e[i] < 0) {\n\t                    z = w;\n\t                    s = r;\n\t                } else {\n\t                    l = i;\n\t                    if (e[i] === 0) {\n\t                        H[i][n] = (w !== 0) ? (-r / w) : (-r / (eps * norm));\n\t                    } else {\n\t                        x = H[i][i + 1];\n\t                        y = H[i + 1][i];\n\t                        q = (d[i] - p) * (d[i] - p) + e[i] * e[i];\n\t                        t = (x * s - z * r) / q;\n\t                        H[i][n] = t;\n\t                        H[i + 1][n] = (Math.abs(x) > Math.abs(z)) ? ((-r - w * t) / x) : ((-s - y * t) / z);\n\t                    }\n\t\n\t                    t = Math.abs(H[i][n]);\n\t                    if ((eps * t) * t > 1) {\n\t                        for (j = i; j <= n; j++) {\n\t                            H[j][n] = H[j][n] / t;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        } else if (q < 0) {\n\t            l = n - 1;\n\t\n\t            if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {\n\t                H[n - 1][n - 1] = q / H[n][n - 1];\n\t                H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];\n\t            } else {\n\t                cdivres = cdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);\n\t                H[n - 1][n - 1] = cdivres[0];\n\t                H[n - 1][n] = cdivres[1];\n\t            }\n\t\n\t            H[n][n - 1] = 0;\n\t            H[n][n] = 1;\n\t            for (i = n - 2; i >= 0; i--) {\n\t                ra = 0;\n\t                sa = 0;\n\t                for (j = l; j <= n; j++) {\n\t                    ra = ra + H[i][j] * H[j][n - 1];\n\t                    sa = sa + H[i][j] * H[j][n];\n\t                }\n\t\n\t                w = H[i][i] - p;\n\t\n\t                if (e[i] < 0) {\n\t                    z = w;\n\t                    r = ra;\n\t                    s = sa;\n\t                } else {\n\t                    l = i;\n\t                    if (e[i] === 0) {\n\t                        cdivres = cdiv(-ra, -sa, w, q);\n\t                        H[i][n - 1] = cdivres[0];\n\t                        H[i][n] = cdivres[1];\n\t                    } else {\n\t                        x = H[i][i + 1];\n\t                        y = H[i + 1][i];\n\t                        vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;\n\t                        vi = (d[i] - p) * 2 * q;\n\t                        if (vr === 0 && vi === 0) {\n\t                            vr = eps * norm * (Math.abs(w) + Math.abs(q) + Math.abs(x) + Math.abs(y) + Math.abs(z));\n\t                        }\n\t                        cdivres = cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);\n\t                        H[i][n - 1] = cdivres[0];\n\t                        H[i][n] = cdivres[1];\n\t                        if (Math.abs(x) > (Math.abs(z) + Math.abs(q))) {\n\t                            H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;\n\t                            H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;\n\t                        } else {\n\t                            cdivres = cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);\n\t                            H[i + 1][n - 1] = cdivres[0];\n\t                            H[i + 1][n] = cdivres[1];\n\t                        }\n\t                    }\n\t\n\t                    t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));\n\t                    if ((eps * t) * t > 1) {\n\t                        for (j = i; j <= n; j++) {\n\t                            H[j][n - 1] = H[j][n - 1] / t;\n\t                            H[j][n] = H[j][n] / t;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    for (i = 0; i < nn; i++) {\n\t        if (i < low || i > high) {\n\t            for (j = i; j < nn; j++) {\n\t                V[i][j] = H[i][j];\n\t            }\n\t        }\n\t    }\n\t\n\t    for (j = nn - 1; j >= low; j--) {\n\t        for (i = low; i <= high; i++) {\n\t            z = 0;\n\t            for (k = low; k <= Math.min(j, high); k++) {\n\t                z = z + V[i][k] * H[k][j];\n\t            }\n\t            V[i][j] = z;\n\t        }\n\t    }\n\t}\n\t\n\tfunction cdiv(xr, xi, yr, yi) {\n\t    var r, d;\n\t    if (Math.abs(yr) > Math.abs(yi)) {\n\t        r = yi / yr;\n\t        d = yr + r * yi;\n\t        return [(xr + r * xi) / d, (xi - r * xr) / d];\n\t    }\n\t    else {\n\t        r = yr / yi;\n\t        d = yi + r * yr;\n\t        return [(r * xr + xi) / d, (r * xi - xr) / d];\n\t    }\n\t}\n\t\n\tmodule.exports = EigenvalueDecomposition;\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(10);\n\t\n\t// https://github.com/lutzroeder/Mapack/blob/master/Source/LuDecomposition.cs\n\tfunction LuDecomposition(matrix) {\n\t    if (!(this instanceof LuDecomposition)) {\n\t        return new LuDecomposition(matrix);\n\t    }\n\t    matrix = Matrix.checkMatrix(matrix);\n\t\n\t    var lu = matrix.clone(),\n\t        rows = lu.rows,\n\t        columns = lu.columns,\n\t        pivotVector = new Array(rows),\n\t        pivotSign = 1,\n\t        i, j, k, p, s, t, v,\n\t        LUrowi, LUcolj, kmax;\n\t\n\t    for (i = 0; i < rows; i++) {\n\t        pivotVector[i] = i;\n\t    }\n\t\n\t    LUcolj = new Array(rows);\n\t\n\t    for (j = 0; j < columns; j++) {\n\t\n\t        for (i = 0; i < rows; i++) {\n\t            LUcolj[i] = lu[i][j];\n\t        }\n\t\n\t        for (i = 0; i < rows; i++) {\n\t            LUrowi = lu[i];\n\t            kmax = Math.min(i, j);\n\t            s = 0;\n\t            for (k = 0; k < kmax; k++) {\n\t                s += LUrowi[k] * LUcolj[k];\n\t            }\n\t            LUrowi[j] = LUcolj[i] -= s;\n\t        }\n\t\n\t        p = j;\n\t        for (i = j + 1; i < rows; i++) {\n\t            if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {\n\t                p = i;\n\t            }\n\t        }\n\t\n\t        if (p !== j) {\n\t            for (k = 0; k < columns; k++) {\n\t                t = lu[p][k];\n\t                lu[p][k] = lu[j][k];\n\t                lu[j][k] = t;\n\t            }\n\t\n\t            v = pivotVector[p];\n\t            pivotVector[p] = pivotVector[j];\n\t            pivotVector[j] = v;\n\t\n\t            pivotSign = -pivotSign;\n\t        }\n\t\n\t        if (j < rows && lu[j][j] !== 0) {\n\t            for (i = j + 1; i < rows; i++) {\n\t                lu[i][j] /= lu[j][j];\n\t            }\n\t        }\n\t    }\n\t\n\t    this.LU = lu;\n\t    this.pivotVector = pivotVector;\n\t    this.pivotSign = pivotSign;\n\t}\n\t\n\tLuDecomposition.prototype = {\n\t    isSingular: function () {\n\t        var data = this.LU,\n\t            col = data.columns;\n\t        for (var j = 0; j < col; j++) {\n\t            if (data[j][j] === 0) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t    get determinant() {\n\t        var data = this.LU;\n\t        if (!data.isSquare())\n\t            throw new Error('Matrix must be square');\n\t        var determinant = this.pivotSign, col = data.columns;\n\t        for (var j = 0; j < col; j++)\n\t            determinant *= data[j][j];\n\t        return determinant;\n\t    },\n\t    get lowerTriangularFactor() {\n\t        var data = this.LU,\n\t            rows = data.rows,\n\t            columns = data.columns,\n\t            X = new Matrix(rows, columns);\n\t        for (var i = 0; i < rows; i++) {\n\t            for (var j = 0; j < columns; j++) {\n\t                if (i > j) {\n\t                    X[i][j] = data[i][j];\n\t                } else if (i === j) {\n\t                    X[i][j] = 1;\n\t                } else {\n\t                    X[i][j] = 0;\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    },\n\t    get upperTriangularFactor() {\n\t        var data = this.LU,\n\t            rows = data.rows,\n\t            columns = data.columns,\n\t            X = new Matrix(rows, columns);\n\t        for (var i = 0; i < rows; i++) {\n\t            for (var j = 0; j < columns; j++) {\n\t                if (i <= j) {\n\t                    X[i][j] = data[i][j];\n\t                } else {\n\t                    X[i][j] = 0;\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    },\n\t    get pivotPermutationVector() {\n\t        return this.pivotVector.slice();\n\t    },\n\t    solve: function (value) {\n\t        value = Matrix.checkMatrix(value);\n\t\n\t        var lu = this.LU,\n\t            rows = lu.rows;\n\t\n\t        if (rows !== value.rows)\n\t            throw new Error('Invalid matrix dimensions');\n\t        if (this.isSingular())\n\t            throw new Error('LU matrix is singular');\n\t\n\t        var count = value.columns,\n\t            X = value.subMatrixRow(this.pivotVector, 0, count - 1),\n\t            columns = lu.columns,\n\t            i, j, k;\n\t\n\t        for (k = 0; k < columns; k++) {\n\t            for (i = k + 1; i < columns; i++) {\n\t                for (j = 0; j < count; j++) {\n\t                    X[i][j] -= X[k][j] * lu[i][k];\n\t                }\n\t            }\n\t        }\n\t        for (k = columns - 1; k >= 0; k--) {\n\t            for (j = 0; j < count; j++) {\n\t                X[k][j] /= lu[k][k];\n\t            }\n\t            for (i = 0; i < k; i++) {\n\t                for (j = 0; j < count; j++) {\n\t                    X[i][j] -= X[k][j] * lu[i][k];\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    }\n\t};\n\t\n\tmodule.exports = LuDecomposition;\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(10);\n\tvar hypotenuse = __webpack_require__(13).hypotenuse;\n\t\n\t//https://github.com/lutzroeder/Mapack/blob/master/Source/QrDecomposition.cs\n\tfunction QrDecomposition(value) {\n\t    if (!(this instanceof QrDecomposition)) {\n\t        return new QrDecomposition(value);\n\t    }\n\t    value = Matrix.checkMatrix(value);\n\t\n\t    var qr = value.clone(),\n\t        m = value.rows,\n\t        n = value.columns,\n\t        rdiag = new Array(n),\n\t        i, j, k, s;\n\t\n\t    for (k = 0; k < n; k++) {\n\t        var nrm = 0;\n\t        for (i = k; i < m; i++) {\n\t            nrm = hypotenuse(nrm, qr[i][k]);\n\t        }\n\t        if (nrm !== 0) {\n\t            if (qr[k][k] < 0) {\n\t                nrm = -nrm;\n\t            }\n\t            for (i = k; i < m; i++) {\n\t                qr[i][k] /= nrm;\n\t            }\n\t            qr[k][k] += 1;\n\t            for (j = k + 1; j < n; j++) {\n\t                s = 0;\n\t                for (i = k; i < m; i++) {\n\t                    s += qr[i][k] * qr[i][j];\n\t                }\n\t                s = -s / qr[k][k];\n\t                for (i = k; i < m; i++) {\n\t                    qr[i][j] += s * qr[i][k];\n\t                }\n\t            }\n\t        }\n\t        rdiag[k] = -nrm;\n\t    }\n\t\n\t    this.QR = qr;\n\t    this.Rdiag = rdiag;\n\t}\n\t\n\tQrDecomposition.prototype = {\n\t    solve: function (value) {\n\t        value = Matrix.checkMatrix(value);\n\t\n\t        var qr = this.QR,\n\t            m = qr.rows;\n\t\n\t        if (value.rows !== m)\n\t            throw new Error('Matrix row dimensions must agree');\n\t        if (!this.isFullRank())\n\t            throw new Error('Matrix is rank deficient');\n\t\n\t        var count = value.columns,\n\t            X = value.clone(),\n\t            n = qr.columns,\n\t            i, j, k, s;\n\t\n\t        for (k = 0; k < n; k++) {\n\t            for (j = 0; j < count; j++) {\n\t                s = 0;\n\t                for (i = k; i < m; i++) {\n\t                    s += qr[i][k] * X[i][j];\n\t                }\n\t                s = -s / qr[k][k];\n\t                for (i = k; i < m; i++) {\n\t                    X[i][j] += s * qr[i][k];\n\t                }\n\t            }\n\t        }\n\t        for (k = n - 1; k >= 0; k--) {\n\t            for (j = 0; j < count; j++) {\n\t                X[k][j] /= this.Rdiag[k];\n\t            }\n\t            for (i = 0; i < k; i++) {\n\t                for (j = 0; j < count; j++) {\n\t                    X[i][j] -= X[k][j] * qr[i][k];\n\t                }\n\t            }\n\t        }\n\t\n\t        return X.subMatrix(0, n - 1, 0, count - 1);\n\t    },\n\t    isFullRank: function () {\n\t        var columns = this.QR.columns;\n\t        for (var i = 0; i < columns; i++) {\n\t            if (this.Rdiag[i] === 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    },\n\t    get upperTriangularFactor() {\n\t        var qr = this.QR,\n\t            n = qr.columns,\n\t            X = new Matrix(n, n),\n\t            i, j;\n\t        for (i = 0; i < n; i++) {\n\t            for (j = 0; j < n; j++) {\n\t                if (i < j) {\n\t                    X[i][j] = qr[i][j];\n\t                } else if (i === j) {\n\t                    X[i][j] = this.Rdiag[i];\n\t                } else {\n\t                    X[i][j] = 0;\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    },\n\t    get orthogonalFactor() {\n\t        var qr = this.QR,\n\t            rows = qr.rows,\n\t            columns = qr.columns,\n\t            X = new Matrix(rows, columns),\n\t            i, j, k, s;\n\t\n\t        for (k = columns - 1; k >= 0; k--) {\n\t            for (i = 0; i < rows; i++) {\n\t                X[i][k] = 0;\n\t            }\n\t            X[k][k] = 1;\n\t            for (j = k; j < columns; j++) {\n\t                if (qr[k][k] !== 0) {\n\t                    s = 0;\n\t                    for (i = k; i < rows; i++) {\n\t                        s += qr[i][k] * X[i][j];\n\t                    }\n\t\n\t                    s = -s / qr[k][k];\n\t\n\t                    for (i = k; i < rows; i++) {\n\t                        X[i][j] += s * qr[i][k];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return X;\n\t    }\n\t};\n\t\n\tmodule.exports = QrDecomposition;\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(10);\n\t\n\t// https://github.com/lutzroeder/Mapack/blob/master/Source/CholeskyDecomposition.cs\n\tfunction CholeskyDecomposition(value) {\n\t    if (!(this instanceof CholeskyDecomposition)) {\n\t        return new CholeskyDecomposition(value);\n\t    }\n\t    value = Matrix.checkMatrix(value);\n\t    if (!value.isSymmetric())\n\t        throw new Error('Matrix is not symmetric');\n\t\n\t    var a = value,\n\t        dimension = a.rows,\n\t        l = new Matrix(dimension, dimension),\n\t        positiveDefinite = true,\n\t        i, j, k;\n\t\n\t    for (j = 0; j < dimension; j++) {\n\t        var Lrowj = l[j];\n\t        var d = 0;\n\t        for (k = 0; k < j; k++) {\n\t            var Lrowk = l[k];\n\t            var s = 0;\n\t            for (i = 0; i < k; i++) {\n\t                s += Lrowk[i] * Lrowj[i];\n\t            }\n\t            Lrowj[k] = s = (a[j][k] - s) / l[k][k];\n\t            d = d + s * s;\n\t        }\n\t\n\t        d = a[j][j] - d;\n\t\n\t        positiveDefinite &= (d > 0);\n\t        l[j][j] = Math.sqrt(Math.max(d, 0));\n\t        for (k = j + 1; k < dimension; k++) {\n\t            l[j][k] = 0;\n\t        }\n\t    }\n\t\n\t    if (!positiveDefinite) {\n\t        throw new Error('Matrix is not positive definite');\n\t    }\n\t\n\t    this.L = l;\n\t}\n\t\n\tCholeskyDecomposition.prototype = {\n\t    get leftTriangularFactor() {\n\t        return this.L;\n\t    },\n\t    solve: function (value) {\n\t        value = Matrix.checkMatrix(value);\n\t\n\t        var l = this.L,\n\t            dimension = l.rows;\n\t\n\t        if (value.rows !== dimension) {\n\t            throw new Error('Matrix dimensions do not match');\n\t        }\n\t\n\t        var count = value.columns,\n\t            B = value.clone(),\n\t            i, j, k;\n\t\n\t        for (k = 0; k < dimension; k++) {\n\t            for (j = 0; j < count; j++) {\n\t                for (i = 0; i < k; i++) {\n\t                    B[k][j] -= B[i][j] * l[k][i];\n\t                }\n\t                B[k][j] /= l[k][k];\n\t            }\n\t        }\n\t\n\t        for (k = dimension - 1; k >= 0; k--) {\n\t            for (j = 0; j < count; j++) {\n\t                for (i = k + 1; i < dimension; i++) {\n\t                    B[k][j] -= B[i][j] * l[i][k];\n\t                }\n\t                B[k][j] /= l[k][k];\n\t            }\n\t        }\n\t\n\t        return B;\n\t    }\n\t};\n\t\n\tmodule.exports = CholeskyDecomposition;\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Created by acastillo on 8/24/15.\n\t */\n\t/**\n\t * Non in-place function definitions, compatible with mathjs code *\n\t */\n\t\n\t'use strict';\n\t\n\tvar Matrix = __webpack_require__(9);\n\t\n\tfunction transpose(A){\n\t    if(typeof A == 'number')\n\t        return A;\n\t    var result = A.clone();\n\t    return result.transpose();\n\t}\n\t\n\tfunction add(A, B){\n\t    if(typeof A == 'number'&&typeof B === 'number')\n\t        return A+B;\n\t    if(typeof A == 'number')\n\t        return this.add(B,A);\n\t\n\t    var result = A.clone();\n\t    return result.add(B);\n\t\n\t}\n\t\n\tfunction subtract(A, B){\n\t    if(typeof A == 'number'&&typeof B === 'number')\n\t        return A-B;\n\t    if(typeof A == 'number')\n\t        return this.subtract(B,A);\n\t    var result = A.clone();\n\t    return result.sub(B);\n\t}\n\t\n\tfunction multiply(A, B){\n\t    if(typeof A == 'number'&&typeof B === 'number')\n\t        return A*B;\n\t    if(typeof A == 'number')\n\t        return this.multiply(B,A);\n\t\n\t    var result = A.clone();\n\t\n\t    if(typeof B === 'number')\n\t        result.mul(B);\n\t    else\n\t        result = result.mmul(B);\n\t\n\t    if(result.rows==1&&result.columns==1)\n\t        return result[0][0];\n\t    else\n\t        return result;\n\t\n\t}\n\t\n\tfunction dotMultiply(A, B){\n\t    var result = A.clone();\n\t    return result.mul(B);\n\t}\n\t\n\tfunction dotDivide(A, B){\n\t    var result = A.clone();\n\t    return result.div(B);\n\t}\n\t\n\tfunction diag(A){\n\t    var diag = null;\n\t    var rows = A.rows, cols = A.columns, j, r;\n\t    //It is an array\n\t    if(typeof cols === \"undefined\" && (typeof A)=='object'){\n\t        if(A[0]&&A[0].length){\n\t            rows = A.length;\n\t            cols = A[0].length;\n\t            r = Math.min(rows,cols);\n\t            diag = new Matrix.zeros(cols, cols);\n\t            for (j = 0; j < cols; j++) {\n\t                diag[j][j]=A[j][j];\n\t            }\n\t        }\n\t        else{\n\t            cols = A.length;\n\t            diag = new Matrix.zeros(cols, cols);\n\t            for (j = 0; j < cols; j++) {\n\t                diag[j][j]=A[j];\n\t            }\n\t        }\n\t\n\t    }\n\t    if(rows == 1){\n\t        diag = new Matrix.zeros(cols, cols);\n\t        for (j = 0; j < cols; j++) {\n\t            diag[j][j]=A[0][j];\n\t        }\n\t    }\n\t    else{\n\t        if(rows>0 && cols > 0){\n\t            r = Math.min(rows,cols);\n\t            diag = new Array(r);\n\t            for (j = 0; j < r; j++) {\n\t                diag[j] = A[j][j];\n\t            }\n\t        }\n\t    }\n\t    return diag;\n\t}\n\t\n\tfunction min(A, B){\n\t    if(typeof A==='number' && typeof B ==='number')\n\t        return Math.min(A,B);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (A[i][j] < B[i][j]) {\n\t                result[i][j] = A[i][j];\n\t            }\n\t            else{\n\t                result[i][j] = B[i][j];\n\t            }\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction max(A, B){\n\t    if(typeof A==='number' && typeof B ==='number')\n\t        return Math.max(A,B);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            if (A[i][j] > B[i][j]) {\n\t                result[i][j] = A[i][j];\n\t            }\n\t            else{\n\t                result[i][j] = B[i][j];\n\t            }\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction sqrt(A){\n\t    if(typeof A==='number' )\n\t        return Math.sqrt(A);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            result[i][j] = Math.sqrt(A[i][j]);\n\t\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction abs(A){\n\t    if(typeof A==='number' )\n\t        return Math.abs(A);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            result[i][j] = Math.abs(A[i][j]);\n\t\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction exp(A){\n\t    if(typeof A==='number' )\n\t        return Math.sqrt(A);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            result[i][j] = Math.exp(A[i][j]);\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction dotPow(A, b){\n\t    if(typeof A==='number' )\n\t        return Math.pow(A,b);\n\t    //console.log(A);\n\t    var ii = A.rows, jj = A.columns;\n\t    var result = new Matrix(ii,jj);\n\t    for (var i = 0; i < ii; i++) {\n\t        for (var j = 0; j < jj; j++) {\n\t            result[i][j] = Math.pow(A[i][j],b);\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction solve(A, B){\n\t    return A.solve(B);\n\t}\n\t\n\tfunction inv(A){\n\t    if(typeof A ===\"number\")\n\t        return 1/A;\n\t    return A.inverse();\n\t}\n\t\n\tmodule.exports = {\n\t    transpose:transpose,\n\t    add:add,\n\t    subtract:subtract,\n\t    multiply:multiply,\n\t    dotMultiply:dotMultiply,\n\t    dotDivide:dotDivide,\n\t    diag:diag,\n\t    min:min,\n\t    max:max,\n\t    solve:solve,\n\t    inv:inv,\n\t    sqrt:sqrt,\n\t    exp:exp,\n\t    dotPow:dotPow,\n\t    abs:abs\n\t};\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar SD = __webpack_require__(1);\n\tvar PeakPicking2D = __webpack_require__(20);\n\tvar JcampConverter=__webpack_require__(3);\n\t\n\tfunction NMR2D(sd) {\n\t    SD.call(this, sd); // Héritage\n\t}\n\t\n\tNMR2D.prototype = Object.create(SD.prototype);\n\tNMR2D.prototype.constructor = NMR2D;\n\t\n\tNMR2D.fromJcamp = function(jcamp,options) {\n\t    options = options || {xy:true,keepSpectra:true,keepRecordsRegExp:/^.+$/};\n\t    var spectrum= JcampConverter.convert(jcamp,options);\n\t    return new NMR2D(spectrum);\n\t}\n\t\n\tNMR2D.prototype.isHomoNuclear=function(){\n\t    return this.sd.xType==this.sd.yType;\n\t}\n\t\n\t//Returns the observe frequency in the direct dimension\n\tNMR2D.prototype.observeFrequencyX=function(){\n\t    return this.sd.spectra[0].observeFrequency;\n\t}\n\t\n\t//Returns the observe frequency in the indirect dimension\n\tNMR2D.prototype.observeFrequencyY=function(){\n\t    return this.sd.indirectFrequency;\n\t}\n\t\n\t/**\n\t * Returns the solvent name\n\t */\n\tNMR2D.prototype.getSolventName=function(){\n\t    return (this.sd.info[\".SOLVENTNAME\"]||this.sd.info[\"$SOLVENT\"]).replace(\"<\",\"\").replace(\">\",\"\");\n\t}\n\t\n\t/**\n\t * This function returns the units of the direct dimension. It overrides the SD getXUnits function\n\t * @returns {ntuples.units|*|b.units}\n\t */\n\tNMR2D.prototype.getXUnits = function(){\n\t    return this.sd.ntuples[1].units;\n\t}\n\t/**\n\t * This function returns the units of the indirect dimension. It overrides the SD getYUnits function\n\t * @returns {ntuples.units|*|b.units}\n\t */\n\tNMR2D.prototype.getYUnits = function(){\n\t    return this.sd.ntuples[0].units;\n\t}\n\t/**\n\t * Returns the units of the dependent variable\n\t * @returns {ntuples.units|*|b.units}\n\t */\n\tNMR2D.prototype.getZUnits = function(){\n\t    return this.sd.ntuples[2].units;\n\t}\n\t/**\n\t * Overwrite this function. Now, the Y axe refers to the indirect dimension\n\t * @returns {sd.minMax.maxY}\n\t */\n\tNMR2D.prototype.getLastY = function(){\n\t    return this.sd.minMax.maxY;\n\t}\n\t/**\n\t * * Overwrite this function. Now, the Y axe refers to the indirect dimension\n\t * @returns {sd.minMax.minY}\n\t */\n\tNMR2D.prototype.getFirstY = function(){\n\t    return this.sd.minMax.minY;\n\t}\n\t\n\t//Returns the separation between 2 consecutive points in the indirect domain\n\tNMR2D.prototype.getDeltaY=function(){\n\t    return ( this.getLastY()-this.getFirstY()) / (this.getNbSubSpectra()-1);\n\t}\n\t\n\t/**\n\t * @function nmrPeakDetection2D(options)\n\t * This function process the given spectraData and tries to determine the NMR signals. \n\t + Returns an NMRSignal2D array containing all the detected 2D-NMR Signals\n\t * @param\toptions:+Object\t\t\tObject containing the options\n\t * @option\tthresholdFactor:number\tA factor to scale the automatically determined noise threshold.\n\t * @returns\t+Object\tset of NMRSignal2D\n\t */\n\tNMR2D.prototype.nmrPeakDetection2D=function(options){\n\t    options = options||{};\n\t    if(!options.thresholdFactor)\n\t        options.thresholdFactor=1;\n\t    var id = Math.round(Math.random()*255);\n\t    if(!options.id){\n\t        id=options.id;\n\t    }\n\t    var peakList = PeakPicking2D.findPeaks2D(this, options.thresholdFactor);\n\t\n\t    //lets add an unique ID for each peak.\n\t    for(var i=0;i<peakList.length;i++){\n\t        peakList[i]._highlight=[id+\"_\"+i];\n\t    }\n\t    return peakList;\n\t}\n\t\n\t/**\n\t* Returns the noise factor depending on the nucleus.\n\t*/\n\tNMR2D.prototype.getNMRPeakThreshold=function(nucleus) {\n\t    if (nucleus == \"1H\")\n\t        return 3.0;\n\t    if (nucleus ==\"13C\")\n\t        return 5.0;\n\t    return 1.0;\n\t}\n\t\n\t/**\n\t* Returns the nucleus in the specified dimension\n\t*/\n\tNMR2D.prototype.getNucleus=function(dim){\n\t    if(dim==1)\n\t        return this.sd.xType;\n\t    if(dim==2)\n\t        return this.sd.yType;\n\t    return this.sd.xType;\n\t}\n\t\n\tmodule.exports = NMR2D;\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar FFTUtils = __webpack_require__(21);\n\tvar PeakOptimizer = __webpack_require__(23);\n\tvar SimpleClustering =  __webpack_require__(24);\n\tvar StatArray = __webpack_require__(2);\n\t\n\tvar PeakPicking2D= {\n\t    DEBUG : false,\n\t    smallFilter : [\n\t        [0, 0, 1, 2, 2, 2, 1, 0, 0],\n\t        [0, 1, 4, 7, 7, 7, 4, 1, 0],\n\t        [1, 4, 5, 3, 0, 3, 5, 4, 1],\n\t        [2, 7, 3, -12, -23, -12, 3, 7, 2],\n\t        [2, 7, 0, -23, -40, -23, 0, 7, 2],\n\t        [2, 7, 3, -12, -23, -12, 3, 7, 2],\n\t        [1, 4, 5, 3, 0, 3, 5, 4, 1],\n\t        [0, 1, 3, 7, 7, 7, 3, 1, 0],\n\t        [0, 0, 1, 2, 2, 2, 1, 0, 0]],\n\t\n\t\n\t    //How noisy is the spectrum depending on the kind of experiment.\n\t    getLoGnStdDevNMR : function(spectraData) {\n\t    if (spectraData.isHomoNuclear())\n\t        return 1.5\n\t    else\n\t        return 3;\n\t    },\n\t\n\t    findPeaks2D : function(spectraData, thresholdFactor){\n\t        if(thresholdFactor==0)\n\t            thresholdFactor=1;\n\t        if(thresholdFactor<0)\n\t            thresholdFactor=-thresholdFactor;\n\t        var nbPoints = spectraData.getNbPoints();\n\t        var nbSubSpectra = spectraData.getNbSubSpectra();\n\t\n\t        var data = new Array(nbPoints * nbSubSpectra);\n\t        //var data = new Array(nbPoints * nbSubSpectra/2);\n\t\n\t        var isHomonuclear = spectraData.isHomoNuclear();\n\t\n\t        //var sum = new Array(nbPoints);\n\t\n\t        for (var iSubSpectra = 0; iSubSpectra < nbSubSpectra; iSubSpectra++) {\n\t            var spectrum = spectraData.getYData(iSubSpectra);\n\t            for (var iCol = 0; iCol < nbPoints; iCol++) {\n\t                if(isHomonuclear){\n\t                    data[iSubSpectra * nbPoints + iCol] =(spectrum[iCol]>0?spectrum[iCol]:0);\n\t                }\n\t                else{\n\t                    data[iSubSpectra * nbPoints + iCol] =Math.abs(spectrum[iCol]);\n\t                }\n\t            }\n\t        }\n\t\n\t        var nStdDev = this.getLoGnStdDevNMR(spectraData);\n\t        if(isHomonuclear){\n\t            var convolutedSpectrum = this.convoluteWithLoG(data, nbSubSpectra, nbPoints);\n\t            var peaksMC1 = this.findPeaks2DLoG(data, convolutedSpectrum, nbSubSpectra, nbPoints, nStdDev*thresholdFactor);//)1.5);\n\t            var peaksMax1 = this.findPeaks2DMax(data, convolutedSpectrum, nbSubSpectra, nbPoints, (nStdDev+0.5)*thresholdFactor);//2.0);\n\t            for(var i=0;i<peaksMC1.length;i++)\n\t                peaksMax1.push(peaksMC1[i]);\n\t            //console.log(peaksMax1);\n\t            return PeakOptimizer.enhanceSymmetry(this.createSignals2D(peaksMax1,spectraData,24));\n\t\n\t        }\n\t        else{\n\t            var convolutedSpectrum = this.convoluteWithLoG(data, nbSubSpectra, nbPoints);\n\t            var peaksMC1 = this.findPeaks2DLoG(data, convolutedSpectrum, nbSubSpectra, nbPoints, nStdDev*thresholdFactor);\n\t            //Peak2D[] peaksMC1 = PeakPicking2D.findPeaks2DMax(data, nbSubSpectra, nbPoints, (nStdDev+0.5)*thresholdFactor);\n\t            //Remove peaks with less than 3% of the intensity of the highest peak\n\t            return this.createSignals2D(PeakOptimizer.clean(peaksMC1, 0.05), spectraData,24);\n\t        }\n\t\n\t    },\n\t    /**\n\t     Calculates the 1st derivative of the 2D matrix, using the LoG kernel approximation\n\t     */\n\t    convoluteWithLoG : function(inputSpectrum, nRows, nCols){\n\t        var ftSpectrum = new Array(nCols * nRows);\n\t        for (var i = nRows * nCols-1; i >=0; i--){\n\t            ftSpectrum[i] = inputSpectrum[i];\n\t        }\n\t\n\t        ftSpectrum = FFTUtils.fft2DArray(ftSpectrum, nRows, nCols);\n\t\n\t        var dim = this.smallFilter.length;\n\t        var ftFilterData = new Array(nCols * nRows);\n\t        for(var i=nCols * nRows-1;i>=0;i--){\n\t            ftFilterData[i]=0;\n\t        }\n\t\n\t        var iRow, iCol;\n\t        var shift = (dim - 1) / 2;\n\t        //console.log(dim);\n\t        for (var ir = 0; ir < dim; ir++) {\n\t            iRow = (ir - shift + nRows) % nRows;\n\t            for (var ic = 0; ic < dim; ic++) {\n\t                iCol = (ic - shift + nCols) % nCols;\n\t                ftFilterData[iRow * nCols + iCol] = this.smallFilter[ir][ic];\n\t            }\n\t        }\n\t\n\t        ftFilterData = FFTUtils.fft2DArray(ftFilterData, nRows, nCols);\n\t\n\t        var ftRows = nRows * 2;\n\t        var ftCols = nCols / 2 + 1;\n\t        FFTUtils.convolute2DI(ftSpectrum, ftFilterData, ftRows, ftCols);\n\t\n\t        return  FFTUtils.ifft2DArray(ftSpectrum, ftRows, ftCols);\n\t    },\n\t    /**\n\t     Detects all the 2D-peaks in the given spectrum based on center of mass logic.\n\t     */\n\t    findPeaks2DLoG : function(inputSpectrum, convolutedSpectrum, nRows, nCols, nStdDev) {\n\t        var threshold = 0;\n\t        for(var i=nCols*nRows-2;i>=0;i--)\n\t            threshold+=Math.pow(convolutedSpectrum[i]-convolutedSpectrum[i+1],2);\n\t        threshold=-Math.sqrt(threshold);\n\t        threshold*=nStdDev/nRows;\n\t\n\t        var bitmask = new Array(nCols * nRows);\n\t        for(var i=nCols * nRows-1;i>=0;i--){\n\t            bitmask[i]=0;\n\t        }\n\t        var nbDetectedPoints = 0;\n\t        var lasti=-1;\n\t        for (var i = convolutedSpectrum.length-1; i >=0 ; i--) {\n\t            if (convolutedSpectrum[i] < threshold) {\n\t                bitmask[i] = 1;\n\t                nbDetectedPoints++;\n\t            }\n\t        }\n\t        var iStart = 0;\n\t        //int ranges = 0;\n\t        var peakList = [];\n\t\n\t        while (nbDetectedPoints != 0) {\n\t            for (iStart; iStart < bitmask.length && bitmask[iStart]==0; iStart++){};\n\t            //\n\t            if (iStart == bitmask.length)\n\t                break;\n\t\n\t            nbDetectedPoints -= this.extractArea(inputSpectrum, convolutedSpectrum,\n\t                bitmask, iStart, nRows, nCols, peakList, threshold);\n\t        }\n\t\n\t        if (peakList.length > 0&&this.DEBUG) {\n\t            console.log(\"No peak found\");\n\t        }\n\t        return peakList;\n\t    },\n\t    /**\n\t     Detects all the 2D-peaks in the given spectrum based on the Max logic.\n\t     */\n\t    findPeaks2DMax : function(inputSpectrum, cs, nRows, nCols, nStdDev) {\n\t        var threshold = 0;\n\t        for(var i=nCols*nRows-2;i>=0;i--)\n\t            threshold+=Math.pow(cs[i]-cs[i+1],2);\n\t        threshold=-Math.sqrt(threshold);\n\t        threshold*=nStdDev/nRows;\n\t\n\t        var rowI,colI;\n\t        var peakListMax = [];\n\t        var tmpIndex = 0;\n\t        for (var i = 0; i < cs.length; i++) {\n\t            if (cs[i] < threshold) {\n\t                //It is a peak?\n\t                rowI=Math.floor(i/nCols);\n\t                colI=i%nCols;\n\t                //Verifies if this point is a peak;\n\t                if(rowI>0&&rowI+1<nRows&&colI+1<nCols&&colI>0){\n\t                    //It is the minimum in the same row\n\t                    if(cs[i]<cs[i+1]&&cs[i]<cs[i-1]){\n\t                        //It is the minimum in the previous row\n\t                        tmpIndex=(rowI-1)*nCols+colI;\n\t                        if(cs[i]<cs[tmpIndex-1]&&cs[i]<cs[tmpIndex]&&cs[i]<cs[tmpIndex+1]){\n\t                            //It is the minimum in the next row\n\t                            tmpIndex=(rowI+1)*nCols+colI;\n\t                            if(cs[i]<cs[tmpIndex-1]&&cs[i]<cs[tmpIndex]&&cs[i]<cs[tmpIndex+1]){\n\t                                peakListMax.push({x:colI,y:rowI,z:inputSpectrum[i]});\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return peakListMax;\n\t    },\n\t    /*\n\t     This function detects the peaks\n\t     */\n\t    extractArea : function(spectrum, convolutedSpectrum, bitmask, iStart,\n\t                                                   nRows, nCols, peakList, threshold) {\n\t        var iRow = Math.floor(iStart / nCols);\n\t        var iCol = iStart % nCols;\n\t        var peakPoints =[];\n\t        //console.log(iStart+\" \"+iRow+\" \"+iCol);\n\t        // scanBitmask(bitmask, convolutedSpectrum, nRows, nCols, iRow, iCol,\n\t        // peakPoints);\n\t        this.scanBitmask(bitmask, nRows, nCols, iRow, iCol, peakPoints);\n\t        //console.log(\"extractArea.lng \"+peakPoints.length);\n\t        var x = new Array(peakPoints.length);\n\t        var y = new Array(peakPoints.length);\n\t        var z = new Array(peakPoints.length);\n\t        var nValues = peakPoints.length;\n\t        var xAverage = 0.0;\n\t        var yAverage = 0.0;\n\t        var zSum = 0.0;\n\t        if (nValues >= 9) {\n\t            if (this.DEBUG)\n\t                console.log(\"nValues=\" + nValues);\n\t            var maxValue = Number.NEGATIVE_INFINITY;\n\t            var maxIndex = -1;\n\t            for (var i = 0; i < nValues; i++) {\n\t                var pt = (peakPoints.splice(0,1))[0];\n\t                x[i] = pt[0];\n\t                y[i] = pt[1];\n\t                z[i] = spectrum[pt[1] * nCols + pt[0]];\n\t                xAverage += x[i] * z[i];\n\t                yAverage += y[i] * z[i];\n\t                zSum += z[i];\n\t                if (z[i] > maxValue) {\n\t                    maxValue = z[i];\n\t                    maxIndex = i;\n\t                }\n\t            }\n\t            if (maxIndex != -1) {\n\t                xAverage /= zSum;\n\t                yAverage /= zSum;\n\t                var newPeak = {x:xAverage, y:yAverage, z:zSum};\n\t                var minmax;\n\t                minmax =StatArray.minMax(x);\n\t                newPeak.minX=minmax.min;\n\t                newPeak.maxX=minmax.max;\n\t                minmax = StatArray.minMax(y);\n\t                newPeak.minY=minmax.min;\n\t                newPeak.maxY=minmax.max;\n\t                peakList.push(newPeak);\n\t            }\n\t        }\n\t        return nValues;\n\t    },\n\t    /*\n\t     Return all the peaks(x,y points) that composes a signal.\n\t     */\n\t    scanBitmask : function(bitmask, nRows, nCols, iRow, iCol, peakPoints) {\n\t        //console.log(nRows+\" \"+iRow+\" \"+nCols+\" \"+iCol);\n\t        if (iRow < 0 || iCol < 0 || iCol == nCols || iRow == nRows)\n\t            return;\n\t        if (bitmask[iRow * nCols + iCol]) {\n\t            bitmask[iRow * nCols + iCol] = 0;\n\t            peakPoints.push([iCol, iRow]);\n\t            this.scanBitmask(bitmask, nRows, nCols, iRow + 1, iCol, peakPoints);\n\t            this.scanBitmask(bitmask, nRows, nCols, iRow - 1, iCol, peakPoints);\n\t            this.scanBitmask(bitmask, nRows, nCols, iRow, iCol + 1, peakPoints);\n\t            this.scanBitmask(bitmask, nRows, nCols, iRow, iCol - 1, peakPoints);\n\t        }\n\t    },\n\t    /**\n\t     This function converts a set of 2D-peaks in 2D-signals. Each signal could be composed\n\t     of many 2D-peaks, and it has some additional information related to the NMR spectrum.\n\t     */\n\t    createSignals2D : function(peaks, spectraData, tolerance){\n\t        //console.log(peaks.length);\n\t        var signals=[];\n\t        var nbSubSpectra = spectraData.getNbSubSpectra();\n\t\n\t        var bf1=spectraData.observeFrequencyX();\n\t        var bf2=spectraData.observeFrequencyY();\n\t\n\t        var firstY = spectraData.getFirstY();\n\t        var lastY = spectraData.getLastY();\n\t        var dy = spectraData.getDeltaY();\n\t\n\t        //console.log(firstY+\" \"+lastY+\" \"+dy+\" \"+nbSubSpectra);\n\t        //spectraData.setActiveElement(0);\n\t        var noValid=0;\n\t        for (var i = peaks.length-1; i >=0 ; i--) {\n\t            //console.log(peaks[i].x+\" \"+spectraData.arrayPointToUnits(peaks[i].x));\n\t            //console.log(peaks[i].y+\" \"+(firstY + dy * (peaks[i].y)));\n\t            peaks[i].x=(spectraData.arrayPointToUnits(peaks[i].x));\n\t            peaks[i].y=(firstY + dy * (peaks[i].y));\n\t\n\t            //console.log(peaks[i])\n\t            //Still having problems to correctly detect peaks on those areas. So I'm removing everything there.\n\t            if(peaks[i].y<-1||peaks[i].y>=210){\n\t                peaks.splice(i,1);\n\t            }\n\t        }\n\t        //console.log(peaks);\n\t        //The connectivity matrix is an square and symmetric matrix, so we'll only store the upper diagonal in an\n\t        //array like form\n\t        var connectivity = [];\n\t        var tmp=0;\n\t        tolerance*=tolerance;\n\t        //console.log(tolerance);\n\t        for (var i = 0; i < peaks.length; i++) {\n\t            for (var j = i; j < peaks.length; j++) {\n\t                tmp=Math.pow((peaks[i].x-peaks[j].x)*bf1,2)+Math.pow((peaks[i].y-peaks[j].y)*bf2,2);\n\t                //Console.log(peaks[i].getX()+\" \"+peaks[j].getX()+\" \"+tmp);\n\t                if(tmp<tolerance){//30*30Hz We cannot distinguish peaks with less than 20 Hz of separation\n\t                    connectivity.push(1);\n\t                }\n\t                else{\n\t                    connectivity.push(0);\n\t                }\n\t            }\n\t        }\n\t\n\t        //console.log(connectivity);\n\t\n\t        var clusters = SimpleClustering.fullClusterGenerator(connectivity);\n\t\n\t        //console.log(clusters)\n\t\n\t        var signals = [];\n\t        if (peaks != null) {\n\t            var xValue, yValue;\n\t            for (var iCluster = 0; iCluster < clusters.length; iCluster++) {\n\t                var signal={nucleusX:spectraData.getNucleus(1),nucleusY:spectraData.getNucleus(2)};\n\t                signal.resolutionX=( spectraData.getLastX()-spectraData.getFirstX()) / spectraData.getNbPoints();\n\t                signal.resolutionY=dy;\n\t                var peaks2D = [];\n\t                signal.shiftX = 0;\n\t                signal.shiftY = 0;\n\t                var sumZ = 0;\n\t                for(var jPeak = clusters[iCluster].length-1;jPeak>=0;jPeak--){\n\t                    if(clusters[iCluster][jPeak]==1){\n\t                        peaks2D.push(peaks[jPeak]);\n\t                        signal.shiftX+=peaks[jPeak].x*peaks[jPeak].z;\n\t                        signal.shiftY+=peaks[jPeak].y*peaks[jPeak].z;\n\t                        sumZ+=peaks[jPeak].z;\n\t                    }\n\t                }\n\t                signal.shiftX/=sumZ;\n\t                signal.shiftY/=sumZ;\n\t                signal.peaks = peaks2D;\n\t                signals.push(signal);\n\t            }\n\t        }\n\t        //console.log(signals);\n\t        return signals;\n\t    }\n\t}\n\t\n\tmodule.exports = PeakPicking2D;\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar FFT = __webpack_require__(22);\n\t\n\tvar FFTUtils= {\n\t    DEBUG : false,\n\t\n\t    /**\n\t     * Calculates the inverse of a 2D Fourier transform\n\t     *\n\t     * @param ft\n\t     * @param ftRows\n\t     * @param ftCols\n\t     * @return\n\t     */\n\t    ifft2DArray : function(ft, ftRows, ftCols){\n\t        var tempTransform = new Array(ftRows * ftCols);\n\t        var nRows = ftRows / 2;\n\t        var nCols = (ftCols - 1) * 2;\n\t        // reverse transform columns\n\t        FFT.init(nRows);\n\t        var tmpCols = {re: new Array(nRows), im: new Array(nRows)};\n\t        for (var iCol = 0; iCol < ftCols; iCol++) {\n\t            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n\t                tmpCols.re[iRow] = ft[(iRow * 2) * ftCols + iCol];\n\t                tmpCols.im[iRow] = ft[(iRow * 2 + 1) * ftCols + iCol];\n\t            }\n\t            //Unnormalized inverse transform\n\t            FFT.bt(tmpCols.re, tmpCols.im);\n\t            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n\t                tempTransform[(iRow * 2) * ftCols + iCol] = tmpCols.re[iRow];\n\t                tempTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n\t            }\n\t        }\n\t\n\t        // reverse row transform\n\t        var finalTransform = new Array(nRows * nCols);\n\t        FFT.init(nCols);\n\t        var tmpRows = {re: new Array(nCols), im: new Array(nCols)};\n\t        var scale = nCols * nRows;\n\t        for (var iRow = 0; iRow < ftRows; iRow += 2) {\n\t            tmpRows.re[0] = tempTransform[iRow * ftCols];\n\t            tmpRows.im[0] = tempTransform[(iRow + 1) * ftCols];\n\t            for (var iCol = 1; iCol < ftCols; iCol++) {\n\t                tmpRows.re[iCol] = tempTransform[iRow * ftCols + iCol];\n\t                tmpRows.im[iCol] = tempTransform[(iRow + 1) * ftCols + iCol];\n\t                tmpRows.re[nCols - iCol] = tempTransform[iRow * ftCols + iCol];\n\t                tmpRows.im[nCols - iCol] = -tempTransform[(iRow + 1) * ftCols + iCol];\n\t            }\n\t            //Unnormalized inverse transform\n\t            FFT.bt(tmpRows.re, tmpRows.im);\n\t\n\t            var indexB = (iRow / 2) * nCols;\n\t            for (var iCol = nCols - 1; iCol >= 0; iCol--) {\n\t                finalTransform[indexB + iCol] = tmpRows.re[iCol] / scale;\n\t            }\n\t        }\n\t        return finalTransform;\n\t    },\n\t    /**\n\t     * Calculates the fourier transform of a matrix of size (nRows,nCols) It is\n\t     * assumed that both nRows and nCols are a power of two\n\t     *\n\t     * On exit the matrix has dimensions (nRows * 2, nCols / 2 + 1) where the\n\t     * even rows contain the real part and the odd rows the imaginary part of the\n\t     * transform\n\t     * @param data\n\t     * @param nRows\n\t     * @param nCols\n\t     * @return\n\t     */\n\t    fft2DArray:function(data, nRows, nCols) {\n\t        var ftCols = (nCols / 2 + 1);\n\t        var ftRows = nRows * 2;\n\t        var tempTransform = new Array(ftRows * ftCols);\n\t        FFT.init(nCols);\n\t        // transform rows\n\t        var tmpRows = {re: new Array(nCols), im: new Array(nCols)};\n\t        var row1 = {re: new Array(nCols), im: new Array(nCols)}\n\t        var row2 = {re: new Array(nCols), im: new Array(nCols)}\n\t        var index, iRow0, iRow1, iRow2, iRow3;\n\t        for (var iRow = 0; iRow < nRows / 2; iRow++) {\n\t            index = (iRow * 2) * nCols;\n\t            tmpRows.re = data.slice(index, index + nCols);\n\t\n\t            index = (iRow * 2 + 1) * nCols;\n\t            tmpRows.im = data.slice(index, index + nCols);\n\t\n\t            FFT.fft1d(tmpRows.re, tmpRows.im);\n\t\n\t            this.reconstructTwoRealFFT(tmpRows, row1, row2);\n\t            //Now lets put back the result into the output array\n\t            iRow0 = (iRow * 4) * ftCols;\n\t            iRow1 = (iRow * 4 + 1) * ftCols;\n\t            iRow2 = (iRow * 4 + 2) * ftCols;\n\t            iRow3 = (iRow * 4 + 3) * ftCols;\n\t            for (var k = ftCols - 1; k >= 0; k--) {\n\t                tempTransform[iRow0 + k] = row1.re[k];\n\t                tempTransform[iRow1 + k] = row1.im[k];\n\t                tempTransform[iRow2 + k] = row2.re[k];\n\t                tempTransform[iRow3 + k] = row2.im[k];\n\t            }\n\t        }\n\t\n\t        //console.log(tempTransform);\n\t        row1 = null;\n\t        row2 = null;\n\t        // transform columns\n\t        var finalTransform = new Array(ftRows * ftCols);\n\t        FFT.init(nRows);\n\t        var tmpCols = {re: new Array(nRows), im: new Array(nRows)};\n\t        for (var iCol = ftCols - 1; iCol >= 0; iCol--) {\n\t            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n\t                tmpCols.re[iRow] = tempTransform[(iRow * 2) * ftCols + iCol];\n\t                tmpCols.im[iRow] = tempTransform[(iRow * 2 + 1) * ftCols + iCol];\n\t            }\n\t            FFT.fft1d(tmpCols.re, tmpCols.im);\n\t            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n\t                finalTransform[(iRow * 2) * ftCols + iCol] = tmpCols.re[iRow];\n\t                finalTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n\t            }\n\t        }\n\t\n\t        //console.log(finalTransform);\n\t        return finalTransform;\n\t\n\t    },\n\t    /**\n\t     *\n\t     * @param fourierTransform\n\t     * @param realTransform1\n\t     * @param realTransform2\n\t     *\n\t     * Reconstructs the individual Fourier transforms of two simultaneously\n\t     * transformed series. Based on the Symmetry relationships (the asterisk\n\t     * denotes the complex conjugate)\n\t     *\n\t     * F_{N-n} = F_n^{*} for a purely real f transformed to F\n\t     *\n\t     * G_{N-n} = G_n^{*} for a purely imaginary g transformed to G\n\t     *\n\t     */\n\t    reconstructTwoRealFFT:function(fourierTransform, realTransform1, realTransform2) {\n\t        var length = fourierTransform.re.length;\n\t\n\t        // the components n=0 are trivial\n\t        realTransform1.re[0] = fourierTransform.re[0];\n\t        realTransform1.im[0] = 0.0;\n\t        realTransform2.re[0] = fourierTransform.im[0];\n\t        realTransform2.im[0] = 0.0;\n\t        var rm, rp, im, ip, j;\n\t        for (var i = length / 2; i > 0; i--) {\n\t            j = length - i;\n\t            rm = 0.5 * (fourierTransform.re[i] - fourierTransform.re[j]);\n\t            rp = 0.5 * (fourierTransform.re[i] + fourierTransform.re[j]);\n\t            im = 0.5 * (fourierTransform.im[i] - fourierTransform.im[j]);\n\t            ip = 0.5 * (fourierTransform.im[i] + fourierTransform.im[j]);\n\t            realTransform1.re[i] = rp;\n\t            realTransform1.im[i] = im;\n\t            realTransform1.re[j] = rp;\n\t            realTransform1.im[j] = -im;\n\t            realTransform2.re[i] = ip;\n\t            realTransform2.im[i] = -rm;\n\t            realTransform2.re[j] = ip;\n\t            realTransform2.im[j] = rm;\n\t        }\n\t    },\n\t\n\t    /**\n\t     * In place version of convolute 2D\n\t     *\n\t     * @param ftSignal\n\t     * @param ftFilter\n\t     * @param ftRows\n\t     * @param ftCols\n\t     * @return\n\t     */\n\t    convolute2DI:function(ftSignal, ftFilter, ftRows, ftCols) {\n\t        var re, im;\n\t        for (var iRow = 0; iRow < ftRows / 2; iRow++) {\n\t            for (var iCol = 0; iCol < ftCols; iCol++) {\n\t                //\n\t                re = ftSignal[(iRow * 2) * ftCols + iCol]\n\t                * ftFilter[(iRow * 2) * ftCols + iCol]\n\t                - ftSignal[(iRow * 2 + 1) * ftCols + iCol]\n\t                * ftFilter[(iRow * 2 + 1) * ftCols + iCol];\n\t                im = ftSignal[(iRow * 2) * ftCols + iCol]\n\t                * ftFilter[(iRow * 2 + 1) * ftCols + iCol]\n\t                + ftSignal[(iRow * 2 + 1) * ftCols + iCol]\n\t                * ftFilter[(iRow * 2) * ftCols + iCol];\n\t                //\n\t                ftSignal[(iRow * 2) * ftCols + iCol] = re;\n\t                ftSignal[(iRow * 2 + 1) * ftCols + iCol] = im;\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tmodule.exports = FFTUtils;\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Fast Fourier Transform module\n\t * 1D-FFT/IFFT, 2D-FFT/IFFT (radix-2)\n\t */\n\tvar FFT = (function(){\n\t  var FFT;  \n\t  \n\t  if(true) {\n\t    FFT = exports;   // for CommonJS\n\t  } else {\n\t    FFT = {};\n\t  }\n\t  \n\t  var version = {\n\t    release: '0.3.0',\n\t    date: '2013-03'\n\t  };\n\t  FFT.toString = function() {\n\t    return \"version \" + version.release + \", released \" + version.date;\n\t  };\n\t\n\t  // core operations\n\t  var _n = 0,          // order\n\t      _bitrev = null,  // bit reversal table\n\t      _cstb = null;    // sin/cos table\n\t\n\t  var core = {\n\t    init : function(n) {\n\t      if(n !== 0 && (n & (n - 1)) === 0) {\n\t        _n = n;\n\t        core._initArray();\n\t        core._makeBitReversalTable();\n\t        core._makeCosSinTable();\n\t      } else {\n\t        throw new Error(\"init: radix-2 required\");\n\t      }\n\t    },\n\t    // 1D-FFT\n\t    fft1d : function(re, im) {\n\t      core.fft(re, im, 1);\n\t    },\n\t    // 1D-IFFT\n\t    ifft1d : function(re, im) {\n\t      var n = 1/_n;\n\t      core.fft(re, im, -1);\n\t      for(var i=0; i<_n; i++) {\n\t        re[i] *= n;\n\t        im[i] *= n;\n\t      }\n\t    },\n\t     // 1D-IFFT\n\t    bt1d : function(re, im) {\n\t      core.fft(re, im, -1);\n\t    },\n\t    // 2D-FFT Not very useful if the number of rows have to be equal to cols\n\t    fft2d : function(re, im) {\n\t      var tre = [],\n\t          tim = [],\n\t          i = 0;\n\t      // x-axis\n\t      for(var y=0; y<_n; y++) {\n\t        i = y*_n;\n\t        for(var x1=0; x1<_n; x1++) {\n\t          tre[x1] = re[x1 + i];\n\t          tim[x1] = im[x1 + i];\n\t        }\n\t        core.fft1d(tre, tim);\n\t        for(var x2=0; x2<_n; x2++) {\n\t          re[x2 + i] = tre[x2];\n\t          im[x2 + i] = tim[x2];\n\t        }\n\t      }\n\t      // y-axis\n\t      for(var x=0; x<_n; x++) {\n\t        for(var y1=0; y1<_n; y1++) {\n\t          i = x + y1*_n;\n\t          tre[y1] = re[i];\n\t          tim[y1] = im[i];\n\t        }\n\t        core.fft1d(tre, tim);\n\t        for(var y2=0; y2<_n; y2++) {\n\t          i = x + y2*_n;\n\t          re[i] = tre[y2];\n\t          im[i] = tim[y2];\n\t        }\n\t      }\n\t    },\n\t    // 2D-IFFT\n\t    ifft2d : function(re, im) {\n\t      var tre = [],\n\t          tim = [],\n\t          i = 0;\n\t      // x-axis\n\t      for(var y=0; y<_n; y++) {\n\t        i = y*_n;\n\t        for(var x1=0; x1<_n; x1++) {\n\t          tre[x1] = re[x1 + i];\n\t          tim[x1] = im[x1 + i];\n\t        }\n\t        core.ifft1d(tre, tim);\n\t        for(var x2=0; x2<_n; x2++) {\n\t          re[x2 + i] = tre[x2];\n\t          im[x2 + i] = tim[x2];\n\t        }\n\t      }\n\t      // y-axis\n\t      for(var x=0; x<_n; x++) {\n\t        for(var y1=0; y1<_n; y1++) {\n\t          i = x + y1*_n;\n\t          tre[y1] = re[i];\n\t          tim[y1] = im[i];\n\t        }\n\t        core.ifft1d(tre, tim);\n\t        for(var y2=0; y2<_n; y2++) {\n\t          i = x + y2*_n;\n\t          re[i] = tre[y2];\n\t          im[i] = tim[y2];\n\t        }\n\t      }\n\t    },\n\t    // core operation of FFT\n\t    fft : function(re, im, inv) {\n\t      var d, h, ik, m, tmp, wr, wi, xr, xi,\n\t          n4 = _n >> 2;\n\t      // bit reversal\n\t      for(var l=0; l<_n; l++) {\n\t        m = _bitrev[l];\n\t        if(l < m) {\n\t          tmp = re[l];\n\t          re[l] = re[m];\n\t          re[m] = tmp;\n\t          tmp = im[l];\n\t          im[l] = im[m];\n\t          im[m] = tmp;\n\t        }\n\t      }\n\t      // butterfly operation\n\t      for(var k=1; k<_n; k<<=1) {\n\t        h = 0;\n\t        d = _n/(k << 1);\n\t        for(var j=0; j<k; j++) {\n\t          wr = _cstb[h + n4];\n\t          wi = inv*_cstb[h];\n\t          for(var i=j; i<_n; i+=(k<<1)) {\n\t            ik = i + k;\n\t            xr = wr*re[ik] + wi*im[ik];\n\t            xi = wr*im[ik] - wi*re[ik];\n\t            re[ik] = re[i] - xr;\n\t            re[i] += xr;\n\t            im[ik] = im[i] - xi;\n\t            im[i] += xi;\n\t          }\n\t          h += d;\n\t        }\n\t      }\n\t    },\n\t    // initialize the array (supports TypedArray)\n\t    _initArray : function() {\n\t      if(typeof Uint32Array !== 'undefined') {\n\t        _bitrev = new Uint32Array(_n);\n\t      } else {\n\t        _bitrev = [];\n\t      }\n\t      if(typeof Float64Array !== 'undefined') {\n\t        _cstb = new Float64Array(_n*1.25);\n\t      } else {\n\t        _cstb = [];\n\t      }\n\t    },\n\t    // zero padding\n\t    _paddingZero : function() {\n\t      // TODO\n\t    },\n\t    // makes bit reversal table\n\t    _makeBitReversalTable : function() {\n\t      var i = 0,\n\t          j = 0,\n\t          k = 0;\n\t      _bitrev[0] = 0;\n\t      while(++i < _n) {\n\t        k = _n >> 1;\n\t        while(k <= j) {\n\t          j -= k;\n\t          k >>= 1;\n\t        }\n\t        j += k;\n\t        _bitrev[i] = j;\n\t      }\n\t    },\n\t    // makes trigonometiric function table\n\t    _makeCosSinTable : function() {\n\t      var n2 = _n >> 1,\n\t          n4 = _n >> 2,\n\t          n8 = _n >> 3,\n\t          n2p4 = n2 + n4,\n\t          t = Math.sin(Math.PI/_n),\n\t          dc = 2*t*t,\n\t          ds = Math.sqrt(dc*(2 - dc)),\n\t          c = _cstb[n4] = 1,\n\t          s = _cstb[0] = 0;\n\t      t = 2*dc;\n\t      for(var i=1; i<n8; i++) {\n\t        c -= dc;\n\t        dc += t*c;\n\t        s += ds;\n\t        ds -= t*s;\n\t        _cstb[i] = s;\n\t        _cstb[n4 - i] = c;\n\t      }\n\t      if(n8 !== 0) {\n\t        _cstb[n8] = Math.sqrt(0.5);\n\t      }\n\t      for(var j=0; j<n4; j++) {\n\t        _cstb[n2 - j]  = _cstb[j];\n\t      }\n\t      for(var k=0; k<n2p4; k++) {\n\t        _cstb[k + n2] = -_cstb[k];\n\t      }\n\t    }\n\t  };\n\t  // aliases (public APIs)\n\t  var apis = ['init', 'fft1d', 'ifft1d', 'fft2d', 'ifft2d'];\n\t  for(var i=0; i<apis.length; i++) {\n\t    FFT[apis[i]] = core[apis[i]];\n\t  }\n\t  FFT.bt = core.bt1d;\n\t  FFT.fft = core.fft1d;\n\t  FFT.ifft = core.ifft1d;\n\t  \n\t  return FFT;\n\t}).call(this);\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\tvar PeakOptimizer={\n\t\tdiagonalError:0.05,\n\t\ttolerance:0.05,\n\t\tDEBUG:false,\n\t    toleranceX : 0.025,\n\t    toleranceY : 0.5,\n\t\n\t    clean: function(peaks, threshold){\n\t        var max = Number.NEGATIVE_INFINITY;\n\t        var i,peak;\n\t        //double min = Double.MAX_VALUE;\n\t        for(i=peaks.length-1;i>=0;i--){\n\t            if(Math.abs(peaks[i].z)>max)\n\t                max=Math.abs(peaks[i].z);\n\t        }\n\t        max*=threshold;\n\t        for(i=peaks.length-1;i>=0;i--){\n\t            if(Math.abs(peaks[i].z)<max)\n\t                peaks.splice(i,1);\n\t        }\n\t        return peaks;\n\t    },\n\t\t\n\t\tenhanceSymmetry: function(signals){\n\t\t\t\n\t\t\tvar properties = this.initializeProperties(signals);\n\t\t\tvar output = signals;\n\t\n\t\t\tif(this.DEBUG)\n\t\t\t\tconsole.log(\"Before optimization size: \"+output.size());\n\t\t\t\n\t\t\t//First step of the optimization: Symmetry validation\n\t\t\tvar i,hits,index;\n\t\t\tvar signal;\n\t\t\tfor(i=output.length-1;i>=0;i--){\n\t\t\t\tsignal = output[i];\n\t\t\t\tif(signal.peaks.length>1)\n\t\t\t\t\tproperties[i][1]++;\n\t\t\t\tif(properties[i][0]==1){\n\t\t\t\t\tindex = this.exist(output, properties, signal,-1,true);\n\t\t\t\t\tif(index>=0){\n\t\t\t\t\t\tproperties[i][1]+=2;\n\t\t\t\t\t\tproperties[index][1]+=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//Second step of the optimization: Diagonal image existence\n\t\t\tfor(i=output.length-1;i>=0;i--){\n\t\t\t\tsignal = output[i];\n\t\t\t\tif(properties[i][0]==0){\n\t\t\t\t\thits = this.checkCrossPeaks(output, properties, signal, true);\n\t\t\t\t\tproperties[i][1]+=hits;\n\t\t\t\t\t//checkCrossPeaks(output, properties, signal, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//Now, each peak have a score between 0 and 4, we can complete the patterns which\n\t\t\t//contains peaks with high scores, and finally, we can remove peaks with scores 0 and 1\n\t\t\tvar count = 0;\n\t\t\tfor(i=output.length-1;i>=0;i--){\n\t\t\t\tif(properties[i][0]!==0&&properties[i][1]>2){\n\t\t\t\t\tcount++;\n\t\t\t\t\tcount+=this.completeMissingIfNeeded(output,properties,output[i],properties[i]);\n\t\t\t\t}\n\t\t\t\tif(properties[i][1]>=2&&properties[i][0]===0)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\t\n\t\t\tif(this.DEBUG)\n\t\t\t\tconsole.log(\"After optimization size: \"+count);\n\t\t\tvar  toReturn = new Array(count);\n\t\t\tcount--;\n\t\t\tfor(i=output.length-1;i>=0;i--){\n\t\t\t\tif(properties[i][0]!==0&&properties[i][1]>2\n\t\t\t\t\t\t||properties[i][0]===0&&properties[i][1]>1){\n\t\t\t\t\ttoReturn[count--]=output[i];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tconsole.log(\"Removed \"+i+\" \"+output[i].peaks.length);\n\t\t\t\t}\n\t\t\t\t//if(properties.get(i)[1]>=2)\n\t\t\t\t//\ttoReturn[count--]=output.get(i);\n\t\t\t}\n\t\t\treturn toReturn;\n\t\t},\n\t\t\n\t\tcompleteMissingIfNeeded: function(output, properties, thisSignal, thisProp) {\n\t\t\t//Check for symmetry\n\t\t\tvar index = this.exist(output, properties, thisSignal,-thisProp[0],true);\n\t\t\tvar addedPeaks=0;\n\t\t\tvar newSignal = null, tmpProp=null;\n\t\t\tif(index<0){//If this signal have no a symmetry image, we have to include it\n\t\t\t\tnewSignal = {nucleusX:thisSignal.nucleusX,nucleusY:thisSignal.nucleusY};\n\t\t\t\tnewSignal.resolutionX=thisSignal.resolutionX;\n\t\t\t\tnewSignal.resolutionY=thisSignal.resolutionY;\n\t\t\t\tnewSignal.shiftX=thisSignal.shiftY;\n\t\t\t\tnewSignal.shiftY=thisSignal.shiftX;\n\t\t\t\tnewSignal.peaks = [{x:thisSignal.shiftY,y:thisSignal.shiftX,z:1}];\n\t\t\t\toutput.push(newSignal);\n\t\t\t\ttmpProp = [-thisProp[0],thisProp[1]];\n\t\t\t\tproperties.push(tmpProp);\n\t\t\t\taddedPeaks++;\n\t\t\t}\n\t\t\t//Check for diagonal peaks\n\t\t\tvar j=0;\n\t\t\tvar diagX=false, diagY=false;\n\t\t\tvar signal;\n\t\t\tfor(j=output.length-1;j>=0;j--){\n\t\t\t\tsignal = output[j];\n\t\t\t\tif(properties[j][0]===0){\n\t\t\t\t\tif(Math.abs(signal.shiftX-thisSignal.shiftX)<this.diagonalError)\n\t\t\t\t\t\tdiagX=true;\n\t\t\t\t\tif(Math.abs(signal.shiftY-thisSignal.shiftY)<this.diagonalError)\n\t\t\t\t\t\tdiagY=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(diagX===false){\n\t\t\t\tnewSignal = {nucleusX:thisSignal.nucleusX,nucleusY:thisSignal.nucleusY};\n\t\t\t\tnewSignal.resolutionX=thisSignal.resolutionX;\n\t\t\t\tnewSignal.resolutionY=thisSignal.resolutionY;\n\t\t\t\tnewSignal.shiftX=thisSignal.shiftX;\n\t\t\t\tnewSignal.shiftY=thisSignal.shiftX;\n\t\t\t\tnewSignal.peaks = [{x:thisSignal.shiftX,y:thisSignal.shiftX,z:1}];\n\t\t\t\toutput.push(newSignal);\n\t\t\t\ttmpProp = [0,thisProp[1]];\n\t\t\t\tproperties.push(tmpProp);\n\t\t\t\taddedPeaks++;\n\t\t\t}\n\t\t\tif(diagY===false){\n\t\t\t\tnewSignal = {nucleusX:thisSignal.nucleusX,nucleusY:thisSignal.nucleusY};\n\t\t\t\tnewSignal.resolutionX=thisSignal.resolutionX;\n\t\t\t\tnewSignal.resolutionY=thisSignal.resolutionY;\n\t\t\t\tnewSignal.shiftX=thisSignal.shiftY;\n\t\t\t\tnewSignal.shiftY=thisSignal.shiftY;\n\t\t\t\tnewSignal.peaks = [{x:thisSignal.shiftY,y:thisSignal.shiftY,z:1}];\n\t\t\t\toutput.push(newSignal);\n\t\t\t\ttmpProp = [0,thisProp[1]];\n\t\t\t\tproperties.push(tmpProp);\n\t\t\t\taddedPeaks++;\n\t\t\t}\n\t\t\treturn addedPeaks;\n\t\t\t\n\t\t},\n\t\t\n\t\t//Check for any diagonal peak that match this cross peak\n\t\tcheckCrossPeaks: function(output, properties, signal, updateProperties) {\n\t\t\tvar hits = 0, i=0, shift=signal.shiftX*4;\n\t\t\tvar crossPeaksX = [],crossPeaksY = [];\n\t\t\tvar cross;\n\t\t\tfor(i=output.length-1;i>=0;i--){\n\t\t\t\tcross = output[i];\n\t\t\t\tif(properties[i][0]!==0){\n\t\t\t\t\tif(Math.abs(cross.shiftX-signal.shiftX)<this.diagonalError){\n\t\t\t\t\t\thits++;\n\t\t\t\t\t\tif(updateProperties)\n\t\t\t\t\t\t\tproperties[i][1]++;\n\t\t\t\t\t\tcrossPeaksX.push(i);\n\t\t\t\t\t\tshift+=cross.shiftX;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(Math.abs(cross.shiftY-signal.shiftY)<this.diagonalError){\n\t\t\t\t\t\t\thits++;\n\t\t\t\t\t\t\tif(updateProperties)\n\t\t\t\t\t\t\t\tproperties[i][1]++;\n\t\t\t\t\t\t\tcrossPeaksY.push(i);\n\t\t\t\t\t\t\tshift+=cross.shiftY;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//Update found crossPeaks and diagonal peak\n\t\t\tshift/=(crossPeaksX.length+crossPeaksY.length+4);\n\t\t\tif(crossPeaksX.length>0){\n\t\t\t\tfor( i=crossPeaksX.length-1;i>=0;i--){\n\t\t\t\t\toutput[crossPeaksX[i]].shiftX=shift;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(crossPeaksY.length>0){\n\t\t\t\tfor( i=crossPeaksY.length-1;i>=0;i--){\n\t\t\t\t\toutput[crossPeaksY[i]].shiftY=shift;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsignal.shiftX=shift;\n\t\t\tsignal.shiftY=shift;\n\t\t\treturn hits;\n\t\t},\n\t\n\t\texist: function(output, properties, signal, type, symmetricSearch) {\n\t\t\tfor(var i=output.length-1;i>=0;i--){\n\t\t\t\tif(properties[i][0]==type){\n\t\t\t\t\tif(this.distanceTo(signal, output[i], symmetricSearch)<this.tolerance){\n\t\t\t\t\t\tif(!symmetricSearch){\n\t\t\t\t\t\t\tvar shiftX=(output[i].shiftX+signal.shiftX)/2.0;\n\t\t\t\t\t\t\tvar shiftY=(output[i].shiftY+signal.shiftY)/2.0;\n\t\t\t\t\t\t\toutput[i].shiftX=shiftX;\n\t\t\t\t\t\t\toutput[i].shiftY=shiftY;\n\t\t\t\t\t\t\tsignal.shiftX=shiftX;\n\t\t\t\t\t\t\tsignal.shiftY=shiftY;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tvar shiftX=signal.shiftX;\n\t\t\t\t\t\t\tvar shiftY=output[i].shiftX;\n\t\t\t\t\t\t\toutput[i].shiftY=shiftX;\n\t\t\t\t\t\t\tsignal.shiftY=shiftY;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t},\n\t\t/**\n\t\t * We try to determine the position of each signal within the spectrum matrix.\n\t\t * Peaks could be of 3 types: upper diagonal, diagonal or under diagonal 1,0,-1\n\t\t * respectively.\n\t\t * @param Signals\n\t\t * @return A matrix containing the properties of each signal\n\t\t */\n\t\tinitializeProperties: function(signals){\n\t\t\tvar signalsProperties = new Array(signals.length);\n\t\t\tfor(var i=signals.length-1;i>=0;i--){\n\t\t\t\tsignalsProperties[i]=[0,0];\n\t\t\t\t//We check if it is a diagonal peak\n\t\t\t\tif(Math.abs(signals[i].shiftX-signals[i].shiftY)<=this.diagonalError){\n\t\t\t\t\tsignalsProperties[i][1]=1;\n\t\t\t\t\t//We adjust the x and y value to be symmetric.\n\t\t\t\t\t//In general chemical shift in the direct dimension is better than in the other one,\n\t\t\t\t\t//so, we believe more to the shiftX than to the shiftY.\n\t\t\t\t\tvar shift = (signals[i].shiftX*2+signals[i].shiftY)/3.0;\n\t\t\t\t\tsignals[i].shiftX=shift;\n\t\t\t\t\tsignals[i].shiftY=shift;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(signals[i].shiftX-signals[i].shiftY>0)\n\t\t\t\t\t\tsignalsProperties[i][0]=1;\n\t\t\t\t\telse\n\t\t\t\t\t\tsignalsProperties[i][0]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn signalsProperties;\n\t\t},\n\t\t\n\t\t/**\n\t\t * This function calculates the distance between 2 nmr signals . If toImage is true, \n\t\t * it will interchange x by y in the distance calculation for the second signal.\n\t\t */\n\t\tdistanceTo: function(a, b, toImage){\n\t\t\tif(!toImage){\n\t\t\t\treturn Math.sqrt(Math.pow(a.shiftX-b.shiftX, 2)\n\t\t\t\t\t\t+Math.pow(a.shiftY-b.shiftY, 2));\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn Math.sqrt(Math.pow(a.shiftX-b.shiftY, 2)\n\t\t\t\t\t\t+Math.pow(a.shiftY-b.shiftX, 2));\n\t\t\t}\n\t\t}\n\t};\n\t\n\tmodule.exports = PeakOptimizer;\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\tvar SimpleClustering={\n\t\n\t\t/*This function returns the cluster list for a given connectivity matrix.\n\t\t*To improve the performance, the connectivity(square and symmetric) matrix \n\t\t*is given as a single vector containing  the upper diagonal of the matrix\n\t\t*Note: This algorithm is O(n*n) complexity. I wonder if there is something better. \n\t\t*acastillo\n\t\t*/\n\t\tfullClusterGenerator:function(conn){\n\t\t\tvar nRows = Math.sqrt(conn.length*2+0.25)-0.5;\n\t\t\t//console.log(\"nRows: \"+nRows+\" - \"+conn.length);\n\t\t\tvar clusterList = [];\n\t\t\tvar available = new Array(nRows);\n\t\t\tvar remaining = nRows, i=0;\n\t\t\tvar cluster = [];\n\t\t\t//Mark all the elements as available\n\t\t\tfor(i=nRows-1;i>=0;i--){\n\t\t\t\tavailable[i]=1;\n\t\t\t}\n\t\t\tvar nextAv=-1;\n\t\t\tvar toInclude = [];\n\t\t\twhile(remaining>0){\n\t\t\t\tif(toInclude.length===0){\n\t\t\t\t\t//If there is no more elements to include. Start a new cluster\n\t\t\t\t\tcluster = new Array(nRows);\n\t\t\t\t\tfor(i=nRows-1;i>=0;i--)\n\t\t\t\t\t\tcluster[i]=0;\n\t\t\t\t\tclusterList.push(cluster);\n\t\t\t    \tfor(nextAv = nRows-1;available[nextAv]==0;nextAv--){};\n\t\t\t    }\n\t\t\t    else{\n\t\t\t    \tnextAv=toInclude.splice(0,1);\n\t\t\t    }\n\t\t\t    //console.log(\"row: \"+nextAv);\n\t\t\t    cluster[nextAv]=1;\n\t\t\t    available[nextAv]=0;\n\t\t\t    remaining--;\n\t\t\t    //Copy the next available row\n\t\t\t    var row = new Array(nRows);\n\t\t\t\tfor(i=nRows-1;i>=0;i--){\n\t\t\t\t\tvar c=Math.max(nextAv,i);\n\t\t\t\t\tvar r=Math.min(nextAv,i);\n\t\t\t\t\t//The element in the conn matrix\n\t\t\t\t\t//console.log(\"index: \"+r*(2*nRows-r-1)/2+c)\n\t\t\t\t\trow[i]=conn[r*(2*nRows-r-1)/2+c];\n\t\t\t\t\t//console.log(\"col: \"+i+\":\"+row[i]);\n\t\t\t\t\t//There is new elements to include in this row?\n\t\t\t\t\t//Then, include it to the current cluster\n\t\t\t\t\tif(row[i]==1&&available[i]==1&&cluster[i]==0){\n\t\t\t\t\t\ttoInclude.push(i);\n\t\t\t\t\t\tcluster[i]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn clusterList;\n\t\t}\n\t}\n\t\n\tmodule.exports = SimpleClustering;\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t/**\n\t * This library formats a set of nmr1D signals to the ACS format.\n\t * Created by acastillo on 3/11/15. p\n\t */\n\tvar ACS=ACS || {};\n\tACS.formater =(function() {\n\t    var acsString=\"\";\n\t    var parenthesis=\"\";\n\t    var spectro=\"\";\n\t    rangeForMultiplet=false;\n\t\n\t    function fromNMRSignal1D2ACS(spectrum, options){\n\t        acsString=\"\";\n\t        parenthesis=\"\";\n\t        spectro=\"\";\n\t        var solvent = null;\n\t        if(options&&options.solvent)\n\t            solvent = options.solvent;\n\t        //options.rangeForMultiplet=false;\n\t        if(options&&options.rangeForMultiplet!=undefined)\n\t            rangeForMultiplet = options.rangeForMultiplet;\n\t\n\t        //console.log(\"Range1: \"+options.rangeForMultiplet);\n\t\n\t        spectrum.type=\"NMR SPEC\";\n\t        if (spectrum[0][\"nucleus\"]==\"1H\") {\n\t            formatAcs_default(spectrum, false, 2, 1, solvent);\n\t        } else if (spectrum[0][\"nucleus\"]==\"13C\") {\n\t            formatAcs_default(spectrum, false, 1, 0, solvent);\n\t        }\n\t\n\t        if (acsString.length>0) acsString+=\".\";\n\t\n\t        return acsString;\n\t    }\n\t\n\t    /*function formatAcs_default_IR(spectra, ascending, decimalValue, smw) {\n\t     appendSeparator();\n\t     appendSpectroInformation(spectra);\n\t     if (spectra[\"peakLabels\"]) {\n\t     var numberPeakLabels=spectra[\"peakLabels\"].length;\n\t     var minIntensity= 9999999;\n\t     var maxIntensity=-9999999;\n\t     for (var i=0; i<numberPeakLabels; i++) {\n\t     if (spectra[\"peakLabels\"][i].intensity<minIntensity) minIntensity=spectra[\"peakLabels\"][i].intensity;\n\t     if (spectra[\"peakLabels\"][i].intensity>maxIntensity) maxIntensity=spectra[\"peakLabels\"][i].intensity;\n\t     }\n\t     for (var i=0; i<numberPeakLabels; i++) {\n\t     if (ascending) {\n\t     var peakLabel=spectra[\"peakLabels\"][i];\n\t     } else {\n\t     var peakLabel=spectra[\"peakLabels\"][numberPeakLabels-i-1];\n\t     }\n\t     if (peakLabel) {\n\t     appendSeparator();\n\t     appendValue(peakLabel,decimalValue);\n\t     if (smw) { // we need to add small / medium / strong\n\t     if (peakLabel.intensity<((maxIntensity-minIntensity)/3+minIntensity)) acsString+=\" (s)\";\n\t     else if (peakLabel.intensity>(maxIntensity-(maxIntensity-minIntensity)/3)) acsString+=\" (w)\";\n\t     else acsString+=\" (m)\";\n\t     }\n\t     }\n\t     }\n\t     }\n\t     }*/\n\t\n\t    function formatAcs_default(spectra, ascending, decimalValue, decimalJ, solvent) {\n\t        appendSeparator();\n\t        appendSpectroInformation(spectra, solvent);\n\t        var numberSmartPeakLabels=spectra.length;\n\t        //console.log(\"SP \"+spectra);\n\t        //console.log(\"# \"+numberSmartPeakLabels);\n\t        for (var i=0; i<numberSmartPeakLabels; i++) {\n\t            if (ascending) {\n\t                var signal=spectra[i];\n\t            } else {\n\t                var signal=spectra[numberSmartPeakLabels-i-1];\n\t            }\n\t            if (signal) {\n\t                //console.log(\"X2X\"+i+JSON.stringify(signal));\n\t                appendSeparator();\n\t                appendDelta(signal,decimalValue);\n\t                appendParenthesis(signal,decimalJ);\n\t                //console.log(\"S2S\"+i);\n\t            }\n\t        }\n\t    }\n\t\n\t    function appendSpectroInformation(spectrum, solvent) {\n\t        if (spectrum.type==\"NMR SPEC\") {\n\t            if (spectrum[0].nucleus) {\n\t                acsString+=formatNucleus(spectrum[0].nucleus);\n\t            }\n\t            acsString+=\" NMR\";\n\t            if ((solvent) || (spectrum[0].observe)) {\n\t                acsString+=\" (\";\n\t                if (spectrum[0].observe) {\n\t                    acsString+=(spectrum[0].observe*1).toFixed(0)+\" MHz\";\n\t                    if (solvent) acsString+=\", \";\n\t                }\n\t                if (solvent) {\n\t                    acsString+=formatMF(solvent);\n\t                }\n\t                acsString+=\")\";\n\t            }\n\t            acsString+=\" δ \";\n\t        } else if (spectrum.type==\"IR\") {\n\t            acsString+=\" IR \";\n\t        } else if (spectrum.type==\"MASS\") {\n\t            acsString+=\" MASS \";\n\t        }\n\t    }\n\t\n\t    function appendDelta(line, nbDecimal) {\n\t        //console.log(\"appendDelta1\");\n\t        var startX = 0,stopX=0,delta1=0;\n\t        if(line.startX){\n\t            if((typeof line.startX)==\"string\"){\n\t                startX=parseFloat(line.startX);\n\t            }\n\t            else\n\t                startX=line.startX;\n\t        }\n\t        if(line.stopX){\n\t            if((typeof line.stopX)==\"string\"){\n\t                stopX=parseFloat(line.stopX);\n\t            }\n\t            else\n\t                stopX=line.stopX;\n\t        }\n\t        if(line.delta1){\n\t            if((typeof line.delta1)==\"string\"){\n\t                delta1=parseFloat(line.delta1);\n\t            }\n\t            else\n\t                delta1=line.delta1;\n\t\n\t        }\n\t        //console.log(\"Range2: \"+rangeForMultiplet+\" \"+line.multiplicity);\n\t        if (line.asymmetric===true||(line.multiplicity==\"m\"&&rangeForMultiplet===true)) {//Is it massive??\n\t            if (line.startX&&line.stopX) {\n\t                if (startX<stopX) {\n\t                    acsString+=startX.toFixed(nbDecimal)+\"-\"+stopX.toFixed(nbDecimal);\n\t                } else {\n\t                    acsString+=stopX.toFixed(nbDecimal)+\"-\"+startX.toFixed(nbDecimal);\n\t                }\n\t            } else {\n\t                if(line.delta1)\n\t                    acsString+=delta1.toFixed(nbDecimal);\n\t            }\n\t        }\n\t        else{\n\t            if(line.delta1)\n\t                acsString+=delta1.toFixed(nbDecimal);\n\t            else{\n\t                if(line.startX&&line.stopX){\n\t                    acsString+=((startX+stopX)/2).toFixed(nbDecimal);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function appendValue(line, nbDecimal) {\n\t        if (line.xPosition) {\n\t            acsString+=line.xPosition.toFixed(nbDecimal);\n\t        }\n\t    }\n\t\n\t    function appendParenthesis(line, nbDecimal) {\n\t        //console.log(\"appendParenthesis1\");\n\t        // need to add assignment - coupling - integration\n\t        parenthesis=\"\";\n\t        appendMultiplicity(line);\n\t        appendIntegration(line);\n\t        appendCoupling(line,nbDecimal);\n\t        appendAssignment(line);\n\t\n\t\n\t        if (parenthesis.length>0) {\n\t            acsString+=\" (\"+parenthesis+\")\";\n\t        }\n\t        //console.log(\"appendParenthesis2\");\n\t    }\n\t\n\t    function appendIntegration(line) {\n\t        if (line.pubIntegration) {\n\t            appendParenthesisSeparator();\n\t            parenthesis+=line.pubIntegration;\n\t        } else if (line.integralData) {\n\t            appendParenthesisSeparator();\n\t            parenthesis+=line.integralData.value.toFixed(0)+\" H\";\n\t        }\n\t    }\n\t\n\t    function appendAssignment(line) {\n\t        if (line.pubAssignment) {\n\t            appendParenthesisSeparator();\n\t            parenthesis+=formatAssignment(line.pubAssignment);\n\t        }\n\t        else{\n\t            if (line.assignment) {\n\t                appendParenthesisSeparator();\n\t                parenthesis+=formatAssignment(line.assignment);\n\t            }\n\t        }\n\t    }\n\t\n\t    function appendMultiplicity(line) {\n\t        if (line.pubMultiplicity) {\n\t            appendParenthesisSeparator();\n\t            parenthesis+=line.pubMultiplicity;\n\t        } else if (line.multiplicity) {\n\t            appendParenthesisSeparator();\n\t            parenthesis+=line.multiplicity;\n\t        }\n\t    }\n\t\n\t    function appendCoupling(line, nbDecimal) {\n\t        if (line.nmrJs) {\n\t            var j=\"<i>J</i> = \";\n\t            for (var i=0; i<line.nmrJs.length; i++) {\n\t                var coupling=line.nmrJs[i].coupling;\n\t                if (j.length>11) j+=\", \";\n\t                j+=coupling.toFixed(nbDecimal);\n\t            }\n\t            appendParenthesisSeparator();\n\t            parenthesis+=j+\" Hz\";\n\t        }\n\t\n\t    }\n\t\n\t    function formatAssignment(assignment) {\n\t        assignment=assignment.replace(/([0-9])/g,\"<sub>$1</sub>\");\n\t        assignment=assignment.replace(/\\\"([^\\\"]*)\\\"/g,\"<i>$1</i>\");\n\t        return assignment;\n\t    }\n\t\n\t    function formatMF(mf) {\n\t        mf=mf.replace(/([0-9])/g,\"<sub>$1</sub>\");\n\t        return mf;\n\t    }\n\t\n\t    function formatNucleus(nucleus) {\n\t        nucleus=nucleus.replace(/([0-9])/g,\"<sup>$1</sup>\");\n\t        return nucleus;\n\t    }\n\t\n\t    function appendSeparator() {\n\t        if ((acsString.length>0) && (! acsString.match(/ $/))) {\n\t            acsString+=\", \";\n\t        }\n\t    }\n\t\n\t    function appendParenthesisSeparator() {\n\t        if ((parenthesis.length>0) && (! parenthesis.match(\", $\"))) parenthesis+=\", \";\n\t    }\n\t\n\t    function fromACS2NMRSignal1D(acsString){\n\t        return JSON.parse(SDAPI.AcsParserAsJSONString(acsString));\n\t    }\n\t\n\t    return {\n\t        toACS:fromNMRSignal1D2ACS,\n\t        toNMRSignal:fromACS2NMRSignal1D\n\t    }\n\t})();\n\t\n\tmodule.exports=ACS;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** spectra-data.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 4c5ea95b289e8d8306b7\n **/","'use strict';\n\n\nexports.SD = require('./SD');\nexports.NMR = require('./NMR');\nexports.NMR2D = require('./NMR2D');\nexports.ACS = require('./AcsParser');\nexports.JAnalyzer = require('./JAnalyzer');\n//exports.SD2 = require('/SD2');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","// small note on the best way to define array\n// http://jsperf.com/lp-array-and-loops/2\n\nvar StatArray = require('ml-stat/array');\nvar JcampConverter=require(\"jcampconverter\");\n\nfunction SD(sd) {\n    this.sd=sd;\n    this.activeElement=0;\n\n    this.DATACLASS_XY = 1;\n    this.DATACLASS_PEAK = 2;\n\n    this.TYPE_NMR_SPECTRUM = 'NMR Spectrum';\n    this.TYPE_NMR_FID = 'NMR FID';\n    this.TYPE_IR = 'IR';\n    this.TYPE_RAMAN = 'RAMAN';\n    this.TYPE_UV = 'UV';\n    this.TYPE_MASS = 'MASS';\n    this.TYPE_HPLC = 'HPLC';\n    this.TYPE_GC = 'GC';\n    this.TYPE_CD = 'CD';\n    this.TYPE_2DNMR_SPECTRUM = 'nD NMR SPECTRUM';\n    this.TYPE_2DNMR_FID = 'nD NMR FID';\n    this.TYPE_XY_DEC = 'XY DEC';\n    this.TYPE_XY_INC= 'XY INC';\n    this.TYPE_IV = 'IV';\n}\n\nSD.fromJcamp = function(jcamp, options) {\n    options = options ||{};\n    if(typeof options.xy ===\"undefined\")\n        options.xy=true;\n\n    var spectrum= JcampConverter.convert(jcamp,options);\n    return new SD(spectrum);\n}\n\n\n/**\n * @function setActiveElement(nactiveSpectrum);\n * This function sets the nactiveSpectrum sub-spectrum as active\n * \n */\nSD.prototype.setActiveElement = function(nactiveSpectrum){\n    this.activeElement=nactiveSpectrum;\n}\n\n/**\n * @function getActiveElement();\n * This function returns the index of the active sub-spectrum.\n */\nSD.prototype.getActiveElement = function(){\n    return this.activeElement;\n}\n/**\n * This function returns the units of the independent dimension.\n * @returns {xUnit|*|M.xUnit}\n */\nSD.prototype.getXUnits = function(){\n    return this.getSpectrum().xUnit;\n}\n\n/**\n * * This function returns the units of the dependent variable.\n * @returns {yUnit|*|M.yUnit}\n */\nSD.prototype.getYUnits = function(){\n    return this.getSpectrum().yUnit;\n}\n\n/**\n*   Returns the number of points in the current spectrum\n*/\nSD.prototype.getNbPoints=function(i){\n    return this.getSpectrumData(i).y.length;\n}\n\n/**\n * Return the first value of the direct dimension\n */\nSD.prototype.getFirstX=function(i) {\n    i=i||this.activeElement;\n    return this.sd.spectra[i].firstX;\n}\n\n/**\n * Return the last value of the direct dimension\n */\nSD.prototype.getLastX=function(i) {\n    i=i||this.activeElement;\n    return this.sd.spectra[i].lastX;\n}\n\n/**\n * Return the first value of the direct dimension\n */\nSD.prototype.getFirstY=function(i) {\n    i=i||this.activeElement;\n    return this.sd.spectra[i].firstY;\n}\n\n/**\n * Return the first value of the direct dimension\n */\nSD.prototype.getLastY = function(i){\n    i=i||this.activeElement;\n    return this.sd.spectra[i].lastY;\n}\n\nSD.prototype.setDataClass = function(dataClass){\n    if(dataClass==this.DATACLASS_PEAK) {\n        this.getSpectrum().isPeaktable = true;\n        this.getSpectrum().isXYdata = false;\n    }\n    if(dataClass==this.DATACLASS_XY){\n        this.getSpectrum().isXYdata = true;\n        this.getSpectrum().isPeaktable = false;\n    }\n}\n\n/**\n * @function isDataClassPeak();\n * Is this a PEAKTABLE spectrum?\n */\nSD.prototype.isDataClassPeak = function(){\n    if(this.getSpectrum().isPeaktable)\n        return  this.getSpectrum().isPeaktable;\n    return false;\n}\n\n/**\n * @function isDataClassXY();\n * Is this a XY spectrum?\n */\nSD.prototype.isDataClassXY = function(){\n    if(this.getSpectrum().isXYdata)\n        return  this.getSpectrum().isXYdata;\n    return false\n}\n\nSD.prototype.setDataType = function(dataType){\n    this.getSpectrum().dataType=dataType;\n}\n\nSD.prototype.getDataType = function(){\n    return this.getSpectrum().dataType;\n}\n\n/**\n* Return the i-th sub-spectra in the current spectrum\n*/\nSD.prototype.getSpectrumData=function(i) {\n    i=i||this.activeElement;\n    return this.sd.spectra[i].data[0];\n}\n\n/**\n * Return the i-th sub-spectra in the current spectrum\n */\nSD.prototype.getSpectrum=function(i) {\n    i=i||this.activeElement;\n    return this.sd.spectra[i];\n}\n\n/**\n * Returns the number of sub-spectra in this object\n */\nSD.prototype.getNbSubSpectra=function(){\n    return this.sd.spectra.length;\n}\n\n\n/**\n *   Returns an array containing the x values of the spectrum\n */\nSD.prototype.getXData=function(i){\n    return this.getSpectrumData(i).x;\n}\n\n/**\n * @function getYData();\n * This function returns a double array containing the values of the intensity for the current sub-spectrum.\n */\nSD.prototype.getYData=function(i){\n    return this.getSpectrumData(i).y;\n}\n\nSD.prototype.getX=function(i){\n    return this.getXData()[i];\n}\n\nSD.prototype.getY=function(i){\n    return this.getYData()[i];\n}\n\n/**\n * @function getXYData();\n * To get a 2 dimensional array with the x and y of this spectraData( Only for 1D spectra).\n * Returns a double[2][nbPoints] where the first row contains the x values and the second row the y values.\n */\nSD.prototype.getXYData=function(i){\n    return [this.getXData(i),this.getYData(i)];\n}\n\nSD.prototype.getTitle=function(i) {\n    return this.getSpectrum(i).title;\n}\n\n/**\n * @function setTitle(newTitle);\n * To set the title of this spectraData.\n * @param newTitle The new title\n */\nSD.prototype.setTitle=function(newTitle,i) {\n    this.getSpectrum(i).title=newTitle;\n}\n\n/**\n * @function getMinY(i)\n * This function returns the minimal value of Y\n */\nSD.prototype.getMinY=function(i) {\n    return  StatArray.min(this.getYData(i));\n}\n\n/**\n * @function getMaxY(i)\n * This function returns the maximal value of Y\n */\nSD.prototype.getMaxY=function(i) {\n    return  StatArray.max(this.getYData(i));\n}\n\n/**\n * @function getMinMax(i)\n */\nSD.prototype.getMinMaxY=function(i) {\n    return  StatArray.minMax(this.getYData(i));\n}\n\n\n/**\n* Get the noise threshold level of the current spectrum. It uses median instead of the mean\n*/\nSD.prototype.getNoiseLevel=function(){\n    var mean = 0,stddev=0;\n    var y = this.getYData();\n    var length = this.getNbPoints(),i=0;\n    for(i = 0; i < length; i++){\n        mean+=y[i];\n    }\n    mean/=this.getNbPoints();\n    var averageDeviations = new Array(length);\n    for (i = 0; i < length; i++)\n        averageDeviations[i] = Math.abs(y[i] - mean);\n    averageDeviations.sort();\n    if (length % 2 == 1) {\n        stddev = averageDeviations[(length-1)/2] / 0.6745;\n    } else {\n        stddev = 0.5*(averageDeviations[length/2]+averageDeviations[length/2-1]) / 0.6745;\n    }\n\n    return stddev*this.getNMRPeakThreshold(this.getNucleus(1));\n}\n\n\n/**\n* Return the xValue for the given index\n*/\nSD.prototype.arrayPointToUnits=function(doublePoint){\n    return (this.getFirstX() - (doublePoint* (this.getFirstX() - this.getLastX()) / (this.getNbPoints()-1)));\n}\n\n/**\n * Returns the index-value for the data array corresponding to a X-value in\n * units for the element of spectraData to which it is linked (spectraNb).\n * This method makes use of spectraData.getFirstX(), spectraData.getLastX()\n * and spectraData.getNbPoints() to derive the return value if it of data class XY\n * It performs a binary search if the spectrum is a peak table\n *\n * @param inValue\n *            (value in Units to be converted)\n * @return an integer representing the index value of the inValue\n */\nSD.prototype.unitsToArrayPoint=function(inValue){\n    if (this.isDataClassXY()) {\n        return Math.round((this.getFirstX() - inValue) * (-1.0 / this.getDeltaX()));\n    } else if (this.isDataClassPeak())\n    {\n        var currentArrayPoint = 0,upperLimit=this.getNbPoints()-1, lowerLimit=0, midPoint;\n        //If inverted scale\n        if(this.getFirstX()>this.getLastX()){\n            upperLimit=0;\n            lowerLimit=this.getNbPoints()-1;\n\n            if(inValue>this.getFirstX())\n                return this.getNbPoints();\n            if(inValue<this.getLastX())\n                return -1;\n        }\n        else{\n            if(inValue<this.getFirstX())\n                return -1;\n            if(inValue>this.getLastX())\n                return this.getNbPoints();\n        }\n\n        while (Math.abs(upperLimit-lowerLimit) > 1)\n        {\n            midPoint=Math.round(Math.floor((upperLimit+lowerLimit)/2));\n            //x=this.getX(midPoint);\n            if(this.getX(midPoint)==inValue)\n                return midPoint;\n            if(this.getX(midPoint)>inValue)\n                upperLimit=midPoint;\n            else\n                lowerLimit=midPoint;\n        }\n        currentArrayPoint=lowerLimit;\n        if(Math.abs(this.getX(lowerLimit)-inValue)>Math.abs(this.getX(upperLimit)-inValue))\n            currentArrayPoint=upperLimit;\n        return currentArrayPoint;\n    } else {\n        return 0;\n    }\n}\n\n\n\n/**\n* Returns the separation between 2 consecutive points in the spectra domain\n*/\nSD.prototype.getDeltaX=function(){\n    return (this.getLastX()-this.getFirstX()) / (this.getNbPoints()-1);\n}\n\n/**\n * @function setMinMax(min,max)\n * This function scales the values of Y between the min and max parameters\n * @param min   Minimum desired value for Y\n * @param max   Maximum desired value for Y\n */\nSD.prototype.setMinMax=function(min,max) {\n    var y = this.getYData();\n    var minMax = StatArray.minMax(y);\n    var factor = (max - min)/(minMax.max-minMax.min);\n    for(var i=0;i< y.length;i++){\n        y[i]=(y[i]-minMax.min)*factor+min;\n    }\n}\n\n/**\n * @function setMin(min)\n * This function scales the values of Y to fit the min parameter\n * @param min   Minimum desired value for Y\n */\nSD.prototype.setMin=function(min) {\n    var y = this.getYData();\n    var currentMin = StatArray.min(y);\n    var factor = min/currentMin;\n    for(var i=0;i< y.length;i++){\n        y[i]*=factor;\n    }\n}\n\n/**\n * @function setMax(max)\n * This function scales the values of Y to fit the max parameter\n * @param max   Maximum desired value for Y\n */\nSD.prototype.setMax=function(max) {\n    var y = this.getYData();\n    var currentMin = StatArray.max(y);\n    var factor = max/currentMin;\n    for(var i=0;i< y.length;i++){\n        y[i]*=factor;\n    }\n}\n\n/**\n * @function YShift(value)\n * This function shifts the values of Y\n * @param value Distance of the shift\n */\nSD.prototype.YShift=function(value) {\n    var y = this.getSpectrumData().y;\n    var length = this.getNbPoints(),i=0;\n    for(i=0;i<length;i++){\n        y[i]+=value;\n    }\n    this.getSpectrum().firstY+=value;\n    this.getSpectrum().lastY+=value;\n}\n\n/**\n * @function shift(globalShift)\n * This function shift the given spectraData. After this function is applied, all the peaks in the\n * spectraData will be found at xi+globalShift\n * @param globalShift\n */\nSD.prototype.shift=function(globalShift) {\n    for(var i=0;i<this.getNbSubSpectra();i++){\n        this.setActiveElement(i);\n        var x = this.getSpectrumData().x;\n        var length = this.getNbPoints(),i=0;\n        for(i=0;i<length;i++){\n            x[i]+=globalShift;\n        }\n\n        this.getSpectrum().firstX+=globalShift;\n        this.getSpectrum().lastX+=globalShift;\n    }\n\n}\n\n/**\n * @function fillWith(from, to, value)\n * This function fills a zone of the spectrum with the given value.\n * @param from\n * @param to\n * @param fillWith\n */\nSD.prototype.fillWith=function(from, to, value) {\n    var tmp, start, end, x, y;\n    if(from > to) {\n        var tmp = from;\n        from = to;\n        to = tmp;\n    }\n\n    for(var i=0;i<this.getNbSubSpectra();i++){\n        this.setActiveElement(i);\n        x = this.getXData();\n        y = this.getYData();\n        start = this.unitsToArrayPoint(from);\n        end = this.unitsToArrayPoint(to);\n        if(start > end){\n            tmp = start;\n            start = end;\n            end = tmp;\n        }\n        if(start<0)\n            start=0;\n        if(end>=this.getNbPoints)\n            end=this.getNbPoints-1;\n        for(i=start;i<=end;i++){\n                y[i]=value;\n        }\n    }\n}\n\n/**\n * @function suppressZone(from, to)\n * This function suppress a zone from the given spectraData within the given x range.\n * Returns a spectraData of type PEAKDATA without peaks in the given region\n * @param from\n * @param to\n */\nSD.prototype.suppressZone=function(from, to) {\n    var tmp, start, end, x, y;\n    if(from > to) {\n        var tmp = from;\n        from = to;\n        to = tmp;\n    }\n\n    for(var i=0;i<this.getNbSubSpectra();i++){\n        this.setActiveElement(i);\n        x = this.getXData();\n        y = this.getYData();\n        start = this.unitsToArrayPoint(from);\n        end = this.unitsToArrayPoint(to);\n        if(start > end){\n            tmp = start;\n            start = end;\n            end = tmp;\n        }\n        if(start<0)\n            start=0;\n        if(end>=this.getNbPoints)\n            end=this.getNbPoints-1;\n        for(i=end;i>=start;i--){\n            y.splice(i,1);\n            x.splice(i,1);\n        }\n    }\n    this.setDataClass(this.DATACLASS_PEAK);\n}\n\n\n/**\n * @function peakPicking(parameters)\n * This function performs a simple peak detection in a spectraData. The parameters that can be specified are:\n * Returns a two dimensional array of double specifying [x,y] of the detected peaks.\n * @option from:    Lower limit.\n * @option to:      Upper limit.\n * @option threshold: The minimum intensity to consider a peak as a signal, expressed as a percentage of the highest peak. \n * @option stdev: Number of standard deviation of the noise for the threshold calculation if a threshold is not specified.\n * @option resolution: The maximum resolution of the spectrum for considering peaks.\n * @option yInverted: Is it a Y inverted spectrum?(like an IR spectrum)\n * @option smooth: A function for smoothing the spectraData before the detection. If your are dealing with\n * experimental spectra, smoothing will make the algorithm less prune to false positives.\n */\nSD.prototype.simplePeakPicking=function(parameters) {\n    //@TODO implements this filter\n}\n\n/**\n * @function getMaxPeak();\n * Get the maximum peak\n */\nSD.prototype.getMaxPeak = function(){\n    var y = this.getSpectraDataY();\n    var max=y[0], index=0;\n    for(var i=0;i< y.length;i++){\n        if(max<y[i]){\n            max = y[i];\n            index=i;\n        }\n    }\n    return [this.getSpectraDataX()[index],max];\n}\n\n/**\n * @function getParamDouble(name, defvalue);\n * Get the value of the parameter\n * @param  name The parameter name\n * @param  defvalue The default value\n */\nSD.prototype.getParamDouble = function(name, defvalue){\n    var value = this.sd.info[name];\n    if(!value)\n        value = defvalue;\n    return value;\n}\n\n/**\n * @function getParamString(name, defvalue);\n * Get the value of the parameter\n * @param  name The parameter name\n * @param  defvalue The default value\n */\nSD.prototype.getParamString = function(name, defvalue){\n    var value = this.sd.info[name];\n    if(!value)\n        value = defvalue;\n    return value+\"\";\n}\n\n/**\n * @function getParamInt(name, defvalue);\n * Get the value of the parameter\n * @param  name The parameter name\n * @param  defvalue The default value\n */\nSD.prototype.getParamInt = function(name, defvalue){\n    var value = this.sd.info[name];\n    if(!value)\n        value = defvalue;\n    return value;\n}\n\n/**\n * Return the y elements of the current spectrum\n * @returns {*}\n */\nSD.prototype.getSpectrumDataY = function(){\n    return this.getYData();\n}\n\n/**\n * Return the x elements of the current spectrum\n * @returns {*}\n */\nSD.prototype.getSpectraDataX = function(){\n    return this.getXData();\n}\n\n/**\n * Set a new parameter to this spectrum\n * @param name\n * @param value\n */\nSD.prototype.putParam = function(name, value){\n    this.sd.info[name]=value;\n}\n\n/**\n * This function returns the area under the spectrum in the given window\n */\nSD.prototype.getArea = function(from, to){\n    var i0 = this.unitsToArrayPoint(from);\n    var ie = this.unitsToArrayPoint(to);\n    var area = 0;\n    if(i0>ie){\n        var tmp = i0;\n        i0 = ie;\n        ie = tmp;\n    }\n    i0=i0<0?0:i0;\n    ie=ie>=this.getNbPoints()?this.getNbPoints()-1:ie;\n    for(var i=i0;i<ie;i++){\n        area+= this.getY(i);\n    }\n    return area*Math.abs(this.getDeltaX());\n},\n\n/**\n * Returns a equally spaced vector within the given window.\n * @param from\n * @param to\n * @param nPoints\n * @returns {*}\n */\nSD.prototype.getVector = function(from, to, nPoints){\n    var x = this.getSpectraDataX();\n    var y = this.getSpectraDataY();\n    var result = [];\n    var start = 0, end = x.length- 1,direction=1;\n    var reversed = false;\n\n    if(x[0]>x[1]){\n        direction = -1;\n        start= x.length-1;\n        end = 0;\n    }\n\n    if(from > to){\n        var tmp = from;\n        from = to;\n        to = tmp;\n        reversed = true;\n    }\n\n    if(x[end]>from||x[start]>to)\n        return [];\n\n    while(x[start]<from){start+=direction;}\n\n    if(x[end]>to){\n        var end = start;\n        while(x[end]<to){end+=direction;}\n    }\n    var winPoints = Math.abs(end-start)+1;\n    var xwin = new Array(winPoints), ywin = new Array(winPoints);\n    var index = 0;\n    if(direction==-1)\n        index=winPoints-1;\n    var i=start-direction;\n    do{\n        i+=direction;\n        xwin[index]=x[i];\n        ywin[index]=y[i];\n        index+=direction;\n    }while(i!=end);\n\n    return [xwin,ywin];\n}\n\n/**\n * @function is2D();\n * Is it a 2D spectrum?\n */\nSD.prototype.is2D = function(){\n    return false;\n}\n\n\nmodule.exports = SD;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/SD.js\n ** module id = 1\n ** module chunks = 0\n **/","'use strict';\n// https://github.com/accord-net/framework/blob/development/Sources/Accord.Statistics/Tools.cs\n\nfunction max(values) {\n    var max = -Infinity, l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] > max) max = values[i];\n    }\n    return max;\n}\n\nfunction min(values) {\n    var min = Infinity, l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] < min) min = values[i];\n    }\n    return min;\n}\n\nfunction minMax(values) {\n    var min = Infinity,\n        max = -Infinity,\n        l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] < min) min = values[i];\n        if (values[i] > max) max = values[i];\n    }\n    return {\n        min: min,\n        max: max\n    };\n}\n\nfunction mean(values) {\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i];\n    return sum / l;\n}\n\nfunction geometricMean(values) {\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum *= values[i];\n    return Math.pow(sum, 1 / l);\n}\n\nfunction logGeometricMean(values) {\n    var lnsum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        lnsum += Math.log(values[i]);\n    return lnsum / l;\n}\n\nfunction grandMean(means, samples) {\n    var sum = 0, n = 0, l = means.length;\n    for (var i = 0; i < l; i++) {\n        sum += samples[i] * means[i];\n        n += samples[i];\n    }\n    return sum / n;\n}\n\nfunction truncatedMean(values, percent, inPlace) {\n    if (typeof(inPlace) === 'undefined') inPlace = false;\n\n    values = inPlace ? values : values.slice();\n    values.sort();\n\n    var l = values.length;\n    var k = Math.floor(l * percent);\n\n    var sum = 0;\n    for (var i = k; i < l - k; i++)\n        sum += values[i];\n\n    return sum / (l - 2 * k);\n}\n\nfunction contraHarmonicMean(values, order) {\n    if (typeof(order) === 'undefined') order = 1;\n    var r1 = 0, r2 = 0, l = values.length;\n    for (var i = 0; i < l; i++) {\n        r1 += Math.pow(values[i], order + 1);\n        r2 += Math.pow(values[i], order);\n    }\n    return r1 / r2;\n}\n\nfunction standardDeviation(values, unbiased) {\n    return Math.sqrt(variance(values, unbiased));\n}\n\nfunction standardError(values) {\n    return standardDeviation(values) / Math.sqrt(values.length);\n}\n\nfunction median(values, alreadySorted) {\n    if (typeof(alreadySorted) === 'undefined') alreadySorted = false;\n    if (!alreadySorted) {\n        values = values.slice();\n        values.sort();\n    }\n\n    var l = values.length;\n    var half = Math.floor(l / 2);\n    if (l % 2 === 0)\n        return (values[half - 1] + values[half]) * 0.5;\n    return values[half];\n}\n\nfunction quartiles(values, alreadySorted) {\n    if (typeof(alreadySorted) === 'undefined') alreadySorted = false;\n    if (!alreadySorted) {\n        values = values.slice();\n        values.sort();\n    }\n\n    var quart = values.length / 4;\n    var q1 = values[Math.ceil(quart) - 1];\n    var q2 = median(values, true);\n    var q3 = values[Math.ceil(quart * 3) - 1];\n\n    return {q1: q1, q2: q2, q3: q3};\n}\n\nfunction variance(values, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var theMean = mean(values);\n    var theVariance = 0, l = values.length;\n\n    for (var i = 0; i < l; i++) {\n        var x = values[i] - theMean;\n        theVariance += x * x;\n    }\n\n    if (unbiased)\n        return theVariance / (l - 1);\n    else\n        return theVariance / l;\n}\n\nfunction pooledStandardDeviation(samples, unbiased) {\n    return Math.sqrt(pooledVariance(samples, unbiased));\n}\n\nfunction pooledVariance(samples, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var sum = 0;\n    var length = 0, l = samples.length;\n    for (var i = 0; i < l; i++) {\n        var values = samples[i];\n        var vari = variance(values);\n\n        sum += (values.length - 1) * vari;\n\n        if (unbiased)\n            length += values.length - 1;\n        else\n            length += values.length;\n    }\n    return sum / length;\n}\n\nfunction mode(values) {\n    var l = values.length,\n        itemCount = new Array(l),\n        i;\n    for (i = 0; i < l; i++) {\n        itemCount[i] = 0;\n    }\n    var itemArray = new Array(l);\n    var count = 0;\n\n    for (i = 0; i < l; i++) {\n        var index = itemArray.indexOf(values[i]);\n        if (index >= 0)\n            itemCount[index]++;\n        else {\n            itemArray[count] = values[i];\n            itemCount[count] = 1;\n            count++;\n        }\n    }\n\n    var maxValue = 0, maxIndex = 0;\n    for (i = 0; i < count; i++) {\n        if (itemCount[i] > maxValue) {\n            maxValue = itemCount[i];\n            maxIndex = i;\n        }\n    }\n\n    return itemArray[maxIndex];\n}\n\nfunction covariance(vector1, vector2, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var mean1 = mean(vector1);\n    var mean2 = mean(vector2);\n\n    if (vector1.length !== vector2.length)\n        throw \"Vectors do not have the same dimensions\";\n\n    var cov = 0, l = vector1.length;\n    for (var i = 0; i < l; i++) {\n        var x = vector1[i] - mean1;\n        var y = vector2[i] - mean2;\n        cov += x * y;\n    }\n\n    if (unbiased)\n        return cov / (l - 1);\n    else\n        return cov / l;\n}\n\nfunction skewness(values, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var theMean = mean(values);\n\n    var s2 = 0, s3 = 0, l = values.length;\n    for (var i = 0; i < l; i++) {\n        var dev = values[i] - theMean;\n        s2 += dev * dev;\n        s3 += dev * dev * dev;\n    }\n    var m2 = s2 / l;\n    var m3 = s3 / l;\n\n    var g = m3 / (Math.pow(m2, 3 / 2.0));\n    if (unbiased) {\n        var a = Math.sqrt(l * (l - 1));\n        var b = l - 2;\n        return (a / b) * g;\n    }\n    else {\n        return g;\n    }\n}\n\nfunction kurtosis(values, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var theMean = mean(values);\n    var n = values.length, s2 = 0, s4 = 0;\n\n    for (var i = 0; i < n; i++) {\n        var dev = values[i] - theMean;\n        s2 += dev * dev;\n        s4 += dev * dev * dev * dev;\n    }\n    var m2 = s2 / n;\n    var m4 = s4 / n;\n\n    if (unbiased) {\n        var v = s2 / (n - 1);\n        var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n        var b = s4 / (v * v);\n        var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n\n        return a * b - 3 * c;\n    }\n    else {\n        return m4 / (m2 * m2) - 3;\n    }\n}\n\nfunction entropy(values, eps) {\n    if (typeof(eps) === 'undefined') eps = 0;\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i] * Math.log(values[i] + eps);\n    return -sum;\n}\n\nfunction weightedMean(values, weights) {\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i] * weights[i];\n    return sum;\n}\n\nfunction weightedStandardDeviation(values, weights) {\n    return Math.sqrt(weightedVariance(values, weights));\n}\n\nfunction weightedVariance(values, weights) {\n    var theMean = weightedMean(values, weights);\n    var vari = 0, l = values.length;\n    var a = 0, b = 0;\n\n    for (var i = 0; i < l; i++) {\n        var z = values[i] - theMean;\n        var w = weights[i];\n\n        vari += w * (z * z);\n        b += w;\n        a += w * w;\n    }\n\n    return vari * (b / (b * b - a));\n}\n\nfunction center(values, inPlace) {\n    if (typeof(inPlace) === 'undefined') inPlace = false;\n\n    var result = values;\n    if (!inPlace)\n        result = values.slice();\n\n    var theMean = mean(result), l = result.length;\n    for (var i = 0; i < l; i++)\n        result[i] -= theMean;\n}\n\nfunction standardize(values, standardDev, inPlace) {\n    if (typeof(standardDev) === 'undefined') standardDev = standardDeviation(values);\n    if (typeof(inPlace) === 'undefined') inPlace = false;\n    var l = values.length;\n    var result = inPlace ? values : new Array(l);\n    for (var i = 0; i < l; i++)\n        result[i] = values[i] / standardDev;\n    return result;\n}\n\nfunction cumulativeSum(array) {\n    var l = array.length;\n    var result = new Array(l);\n    result[0] = array[0];\n    for (var i = 1; i < l; i++)\n        result[i] = result[i - 1] + array[i];\n    return result;\n}\n\nmodule.exports = {\n    min: min,\n    max: max,\n    minMax: minMax,\n    mean: mean,\n    geometricMean: geometricMean,\n    logGeometricMean: logGeometricMean,\n    grandMean: grandMean,\n    truncatedMean: truncatedMean,\n    contraHarmonicMean: contraHarmonicMean,\n    standardDeviation: standardDeviation,\n    standardError: standardError,\n    median: median,\n    quartiles: quartiles,\n    variance: variance,\n    pooledStandardDeviation: pooledStandardDeviation,\n    pooledVariance: pooledVariance,\n    mode: mode,\n    covariance: covariance,\n    skewness: skewness,\n    kurtosis: kurtosis,\n    entropy: entropy,\n    weightedMean: weightedMean,\n    weightedStandardDeviation: weightedStandardDeviation,\n    weightedVariance: weightedVariance,\n    center: center,\n    standardize: standardize,\n    cumulativeSum: cumulativeSum\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-stat/array.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\n\nfunction getConverter() {\n\n    // the following RegExp can only be used for XYdata, some peakTables have values with a \"E-5\" ...\n    var xyDataSplitRegExp = /[,\\t \\+-]*(?=[^\\d,\\t \\.])|[ \\t]+(?=[\\d+\\.-])/;\n    var removeCommentRegExp = /\\$\\$.*/;\n    var peakTableSplitRegExp = /[,\\t ]+/;\n    var DEBUG = false;\n\n    var GC_MS_FIELDS = ['TIC', '.RIC', 'SCANNUMBER'];\n\n    function convertToFloatArray(stringArray) {\n        var l = stringArray.length;\n        var floatArray = new Array(l);\n        for (var i = 0; i < l; i++) {\n            floatArray[i] = parseFloat(stringArray[i]);\n        }\n        return floatArray;\n    }\n\n    /*\n     options.keepSpectra: keep the original spectra for a 2D\n     options.xy: true // create x / y array instead of a 1D array\n     options.keepRecordsRegExp: which fields do we keep\n     */\n\n    function convert(jcamp, options) {\n        options = options || {};\n\n        var keepRecordsRegExp=/^[A-Z]+$/;\n        if (options.keepRecordsRegExp) keepRecordsRegExp=options.keepRecordsRegExp;\n\n        var start = new Date();\n\n        var ntuples = {},\n            ldr,\n            dataLabel,\n            dataValue,\n            ldrs,\n            i, ii, position, endLine, infos;\n\n        var result = {};\n        result.profiling = [];\n        result.logs = [];\n        var spectra = [];\n        result.spectra = spectra;\n        result.info = {};\n        var spectrum = {};\n\n        if (!(typeof jcamp === 'string')) return result;\n        // console.time('start');\n\n        if (result.profiling) result.profiling.push({action: 'Before split to LDRS', time: new Date() - start});\n\n        ldrs = jcamp.split(/[\\r\\n]+##/);\n\n        if (result.profiling) result.profiling.push({action: 'Split to LDRS', time: new Date() - start});\n\n        if (ldrs[0]) ldrs[0] = ldrs[0].replace(/^[\\r\\n ]*##/, '');\n\n        for (i = 0, ii = ldrs.length; i < ii; i++) {\n            ldr = ldrs[i];\n            // This is a new LDR\n            position = ldr.indexOf('=');\n            if (position > 0) {\n                dataLabel = ldr.substring(0, position);\n                dataValue = ldr.substring(position + 1).trim();\n            } else {\n                dataLabel = ldr;\n                dataValue = '';\n            }\n            dataLabel = dataLabel.replace(/[_ -]/g, '').toUpperCase();\n\n            if (dataLabel === 'DATATABLE') {\n                endLine = dataValue.indexOf('\\n');\n                if (endLine === -1) endLine = dataValue.indexOf('\\r');\n                if (endLine > 0) {\n                    var xIndex = -1;\n                    var yIndex = -1;\n                    // ##DATA TABLE= (X++(I..I)), XYDATA\n                    // We need to find the variables\n\n                    infos = dataValue.substring(0, endLine).split(/[ ,;\\t]+/);\n                    if (infos[0].indexOf('++') > 0) {\n                        var firstVariable = infos[0].replace(/.*\\(([a-zA-Z0-9]+)\\+\\+.*/, '$1');\n                        var secondVariable = infos[0].replace(/.*\\.\\.([a-zA-Z0-9]+).*/, '$1');\n                        xIndex = ntuples.symbol.indexOf(firstVariable);\n                        yIndex = ntuples.symbol.indexOf(secondVariable);\n                    }\n\n                    if (xIndex === -1) xIndex = 0;\n                    if (yIndex === -1) yIndex = 0;\n\n                    if (ntuples.first) {\n                        if (ntuples.first.length > xIndex) spectrum.firstX = ntuples.first[xIndex];\n                        if (ntuples.first.length > yIndex) spectrum.firstY = ntuples.first[yIndex];\n                    }\n                    if (ntuples.last) {\n                        if (ntuples.last.length > xIndex) spectrum.lastX = ntuples.last[xIndex];\n                        if (ntuples.last.length > yIndex) spectrum.lastY = ntuples.last[yIndex];\n                    }\n                    if (ntuples.vardim && ntuples.vardim.length > xIndex) {\n                        spectrum.nbPoints = ntuples.vardim[xIndex];\n                    }\n                    if (ntuples.factor) {\n                        if (ntuples.factor.length > xIndex) spectrum.xFactor = ntuples.factor[xIndex];\n                        if (ntuples.factor.length > yIndex) spectrum.yFactor = ntuples.factor[yIndex];\n                    }\n                    if (ntuples.units) {\n                        if (ntuples.units.length > xIndex) spectrum.xUnit = ntuples.units[xIndex];\n                        if (ntuples.units.length > yIndex) spectrum.yUnit = ntuples.units[yIndex];\n                    }\n                    spectrum.datatable = infos[0];\n                    if (infos[1] && infos[1].indexOf('PEAKS') > -1) {\n                        dataLabel = 'PEAKTABLE';\n                    } else if (infos[1] && (infos[1].indexOf('XYDATA') || infos[0].indexOf('++') > 0)) {\n                        dataLabel = 'XYDATA';\n                        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n                    }\n                }\n            }\n\n\n            if (dataLabel === 'TITLE') {\n                spectrum.title = dataValue;\n            } else if (dataLabel === 'DATATYPE') {\n                spectrum.dataType = dataValue;\n                if (dataValue.indexOf('nD') > -1) {\n                    result.twoD = true;\n                }\n            } else if (dataLabel === 'XUNITS') {\n                spectrum.xUnit = dataValue;\n            } else if (dataLabel === 'YUNITS') {\n                spectrum.yUnit = dataValue;\n            } else if (dataLabel === 'FIRSTX') {\n                spectrum.firstX = parseFloat(dataValue);\n            } else if (dataLabel === 'LASTX') {\n                spectrum.lastX = parseFloat(dataValue);\n            } else if (dataLabel === 'FIRSTY') {\n                spectrum.firstY = parseFloat(dataValue);\n            } else if (dataLabel === 'NPOINTS') {\n                spectrum.nbPoints = parseFloat(dataValue);\n            } else if (dataLabel === 'XFACTOR') {\n                spectrum.xFactor = parseFloat(dataValue);\n            } else if (dataLabel === 'YFACTOR') {\n                spectrum.yFactor = parseFloat(dataValue);\n            } else if (dataLabel === 'DELTAX') {\n                spectrum.deltaX = parseFloat(dataValue);\n            } else if (dataLabel === '.OBSERVEFREQUENCY' || dataLabel === '$SFO1') {\n                if (!spectrum.observeFrequency) spectrum.observeFrequency = parseFloat(dataValue);\n            } else if (dataLabel === '.OBSERVENUCLEUS') {\n                if (!spectrum.xType) result.xType = dataValue.replace(/[^a-zA-Z0-9]/g, '');\n            } else if (dataLabel === '$SFO2') {\n                if (!result.indirectFrequency) result.indirectFrequency = parseFloat(dataValue);\n\n            } else if (dataLabel === '$OFFSET') {   // OFFSET for Bruker spectra\n                result.shiftOffsetNum = 0;\n                if (!result.shiftOffsetVal)  result.shiftOffsetVal = parseFloat(dataValue);\n            } else if (dataLabel === '$REFERENCEPOINT') {   // OFFSET for Varian spectra\n\n\n                // if we activate this part it does not work for ACD specmanager\n                //         } else if (dataLabel=='.SHIFTREFERENCE') {   // OFFSET FOR Bruker Spectra\n                //                 var parts = dataValue.split(/ *, */);\n                //                 result.shiftOffsetNum = parseInt(parts[2].trim());\n                //                 result.shiftOffsetVal = parseFloat(parts[3].trim());\n            } else if (dataLabel === 'VARNAME') {\n                ntuples.varname = dataValue.split(/[, \\t]{2,}/);\n            } else if (dataLabel === 'SYMBOL') {\n                ntuples.symbol = dataValue.split(/[, \\t]{2,}/);\n            } else if (dataLabel === 'VARTYPE') {\n                ntuples.vartype = dataValue.split(/[, \\t]{2,}/);\n            } else if (dataLabel === 'VARFORM') {\n                ntuples.varform = dataValue.split(/[, \\t]{2,}/);\n            } else if (dataLabel === 'VARDIM') {\n                ntuples.vardim = convertToFloatArray(dataValue.split(/[, \\t]{2,}/));\n            } else if (dataLabel === 'UNITS') {\n                ntuples.units = dataValue.split(/[, \\t]{2,}/);\n            } else if (dataLabel === 'FACTOR') {\n                ntuples.factor = convertToFloatArray(dataValue.split(/[, \\t]{2,}/));\n            } else if (dataLabel === 'FIRST') {\n                ntuples.first = convertToFloatArray(dataValue.split(/[, \\t]{2,}/));\n            } else if (dataLabel === 'LAST') {\n                ntuples.last = convertToFloatArray(dataValue.split(/[, \\t]{2,}/));\n            } else if (dataLabel === 'MIN') {\n                ntuples.min = convertToFloatArray(dataValue.split(/[, \\t]{2,}/));\n            } else if (dataLabel === 'MAX') {\n                ntuples.max = convertToFloatArray(dataValue.split(/[, \\t]{2,}/));\n            } else if (dataLabel === '.NUCLEUS') {\n                if (result.twoD) {\n                    result.yType = dataValue.split(/[, \\t]{2,}/)[0];\n                }\n            } else if (dataLabel === 'PAGE') {\n                spectrum.page = dataValue.trim();\n                spectrum.pageValue = parseFloat(dataValue.replace(/^.*=/, ''));\n                spectrum.pageSymbol = spectrum.page.replace(/=.*/, '');\n                var pageSymbolIndex = ntuples.symbol.indexOf(spectrum.pageSymbol);\n                var unit = '';\n                if (ntuples.units && ntuples.units[pageSymbolIndex]) {\n                    unit = ntuples.units[pageSymbolIndex];\n                }\n                if (result.indirectFrequency && unit !== 'PPM') {\n                    spectrum.pageValue /= result.indirectFrequency;\n                }\n            } else if (dataLabel === 'RETENTIONTIME') {\n                spectrum.pageValue = parseFloat(dataValue);\n            } else if (dataLabel === 'XYDATA') {\n                prepareSpectrum(result, spectrum);\n                // well apparently we should still consider it is a PEAK TABLE if there are no '++' after\n                if (dataValue.match(/.*\\+\\+.*/)) {\n                    parseXYData(spectrum, dataValue, result);\n                } else {\n                    parsePeakTable(spectrum, dataValue, result);\n                }\n                spectra.push(spectrum);\n                spectrum = {};\n            } else if (dataLabel === 'PEAKTABLE') {\n                prepareSpectrum(result, spectrum);\n                parsePeakTable(spectrum, dataValue, result);\n                spectra.push(spectrum);\n                spectrum = {};\n            } else if (isMSField(dataLabel)) {\n                spectrum[convertMSFieldToLabel(dataLabel)] = dataValue;\n            } else if (dataLabel.match(keepRecordsRegExp)) {\n                result.info[dataLabel] = dataValue.trim();\n            }\n        }\n\n        // Currently disabled\n        //    if (options && options.lowRes) addLowRes(spectra,options);\n\n        if (result.profiling) result.profiling.push({action: 'Finished parsing', time: new Date() - start});\n\n        if (Object.keys(ntuples).length>0) {\n            var newNtuples=[];\n            var keys=Object.keys(ntuples);\n            for (var i=0; i<keys.length; i++) {\n                var key=keys[i];\n                var values=ntuples[key];\n                for (var j=0; j<values.length; j++) {\n                    if (! newNtuples[j]) newNtuples[j]={};\n                    newNtuples[j][key]=values[j];\n                }\n            }\n            result.ntuples=newNtuples;\n        }\n\n        if (result.twoD) {\n            add2D(result);\n            if (result.profiling) result.profiling.push({\n                action: 'Finished countour plot calculation',\n                time: new Date() - start\n            });\n            if (!options.keepSpectra) {\n                delete result.spectra;\n            }\n        }\n\n\n        // maybe it is a GC (HPLC) / MS. In this case we add a new format\n        if (spectra.length > 1 && (! spectra[0].dataType || spectra[0].dataType.toLowerCase().match(/.*mass./))) {\n            addGCMS(result);\n            if (result.profiling) result.profiling.push({\n                action: 'Finished GCMS calculation',\n                time: new Date() - start\n            });\n        }\n\n\n        if (options.xy) { // the spectraData should not be a oneD array but an object with x and y\n            if (spectra.length > 0) {\n                for (var i=0; i<spectra.length; i++) {\n                    var spectrum=spectra[i];\n                    if (spectrum.data.length>0) {\n                        for (var j=0; j<spectrum.data.length; j++) {\n                            var data=spectrum.data[j];\n                            var newData={x:Array(data.length/2), y:Array(data.length/2)};\n                            for (var k=0; k<data.length; k=k+2) {\n                                newData.x[k/2]=data[k];\n                                newData.y[k/2]=data[k+1];\n                            }\n                            spectrum.data[j]=newData;\n                        }\n\n                    }\n\n                }\n            }\n        }\n\n        if (result.profiling) {\n            result.profiling.push({action: 'Total time', time: new Date() - start});\n        }\n\n        //   console.log(result);\n        //    console.log(JSON.stringify(spectra));\n        return result;\n\n    }\n\n\n    function convertMSFieldToLabel(value) {\n        return value.toLowerCase().replace(/[^a-z0-9]/g, '');\n    }\n\n    function isMSField(dataLabel) {\n        for (var i = 0; i < GC_MS_FIELDS.length; i++) {\n            if (dataLabel === GC_MS_FIELDS[i]) return true;\n        }\n        return false;\n    }\n\n    function addGCMS(result) {\n        var spectra = result.spectra;\n        var existingGCMSFields = [];\n        var i;\n        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n            if (spectra[0][label]) {\n                existingGCMSFields.push(label);\n            }\n        }\n        if (existingGCMSFields.length===0) return;\n        var gcms = {};\n        gcms.gc = {};\n        gcms.ms = [];\n        for (i = 0; i < existingGCMSFields.length; i++) {\n            gcms.gc[existingGCMSFields[i]] = [];\n        }\n        for (i = 0; i < spectra.length; i++) {\n            var spectrum = spectra[i];\n            for (var j = 0; j < existingGCMSFields.length; j++) {\n                gcms.gc[existingGCMSFields[j]].push(spectrum.pageValue);\n                gcms.gc[existingGCMSFields[j]].push(parseFloat(spectrum[existingGCMSFields[j]]));\n            }\n          if (spectrum.data) gcms.ms[i] = spectrum.data[0];\n\n        }\n        result.gcms = gcms;\n    }\n\n    function prepareSpectrum(result, spectrum) {\n        if (!spectrum.xFactor) spectrum.xFactor = 1;\n        if (!spectrum.yFactor) spectrum.yFactor = 1;\n        if (spectrum.observeFrequency) {\n            if (spectrum.xUnit && spectrum.xUnit.toUpperCase() === 'HZ') {\n                spectrum.xUnit = 'PPM';\n                spectrum.xFactor = spectrum.xFactor / spectrum.observeFrequency;\n                spectrum.firstX = spectrum.firstX / spectrum.observeFrequency;\n                spectrum.lastX = spectrum.lastX / spectrum.observeFrequency;\n                spectrum.deltaX = spectrum.deltaX / spectrum.observeFrequency;\n            }\n        }\n        if (result.shiftOffsetVal) {\n            var shift = spectrum.firstX - result.shiftOffsetVal;\n            spectrum.firstX = spectrum.firstX - shift;\n            spectrum.lastX = spectrum.lastX - shift;\n        }\n    }\n\n    function parsePeakTable(spectrum, value, result) {\n        spectrum.isPeaktable=true;\n        var i, ii, j, jj, values;\n        var currentData = [];\n        spectrum.data = [currentData];\n\n        // counts for around 20% of the time\n        var lines = value.split(/,? *,?[;\\r\\n]+ */);\n\n        var k = 0;\n        for (i = 1, ii = lines.length; i < ii; i++) {\n            values = lines[i].trim().replace(removeCommentRegExp, '').split(peakTableSplitRegExp);\n            if (values.length % 2 === 0) {\n                for (j = 0, jj = values.length; j < jj; j = j + 2) {\n                    // takes around 40% of the time to add and parse the 2 values nearly exclusively because of parseFloat\n                    currentData[k++] = (parseFloat(values[j]) * spectrum.xFactor);\n                    currentData[k++] = (parseFloat(values[j + 1]) * spectrum.yFactor);\n                }\n            } else {\n                result.logs.push('Format error: ' + values);\n            }\n        }\n    }\n\n    function parseXYData(spectrum, value, result) {\n        // we check if deltaX is defined otherwise we calculate it\n        if (!spectrum.deltaX) {\n            spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n        }\n\n        spectrum.isXYdata=true;\n\n        var currentData = [];\n        spectrum.data = [currentData];\n\n        var currentX = spectrum.firstX;\n        var currentY = spectrum.firstY;\n        var lines = value.split(/[\\r\\n]+/);\n        var lastDif, values, ascii, expectedY;\n        values = [];\n        for (var i = 1, ii = lines.length; i < ii; i++) {\n            //var previousValues=JSON.parse(JSON.stringify(values));\n            values = lines[i].trim().replace(removeCommentRegExp, '').split(xyDataSplitRegExp);\n            if (values.length > 0) {\n                if (DEBUG) {\n                    if (!spectrum.firstPoint) {\n                        spectrum.firstPoint = parseFloat(values[0]);\n                    }\n                    var expectedCurrentX = parseFloat(values[0] - spectrum.firstPoint) * spectrum.xFactor + spectrum.firstX;\n                    if ((lastDif || lastDif === 0)) {\n                        expectedCurrentX += spectrum.deltaX;\n                    }\n                    result.logs.push('Checking X value: currentX: ' + currentX + ' - expectedCurrentX: ' + expectedCurrentX);\n                }\n                for (var j = 1, jj = values.length; j < jj; j++) {\n                    if (j === 1 && (lastDif || lastDif === 0)) {\n                        lastDif = null; // at the beginning of each line there should be the full value X / Y so the diff is always undefined\n                        // we could check if we have the expected Y value\n                        ascii = values[j].charCodeAt(0);\n\n                        if (false) { // this code is just to check the jcamp DIFDUP and the next line repeat of Y value\n                            // + - . 0 1 2 3 4 5 6 7 8 9\n                            if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n                                expectedY = parseFloat(values[j]);\n                            } else\n                            // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n                            if ((ascii > 63) && (ascii < 74)) {\n                                // we could use parseInt but parseFloat is faster at least in Chrome\n                                expectedY = parseFloat(String.fromCharCode(ascii - 16) + values[j].substring(1));\n                            } else\n                            // negative SQZ digits a b c d e f g h i (ascii 97-105)\n                            if ((ascii > 96) && (ascii < 106)) {\n                                // we could use parseInt but parseFloat is faster at least in Chrome\n                                expectedY = -parseFloat(String.fromCharCode(ascii - 48) + values[j].substring(1));\n                            }\n                            if (expectedY !== currentY) {\n                                result.logs.push('Y value check error: Found: ' + expectedY + ' - Current: ' + currentY);\n                                result.logs.push('Previous values: ' + previousValues.length);\n                                result.logs.push(previousValues);\n                            }\n                        }\n                    } else {\n                        if (values[j].length > 0) {\n                            ascii = values[j].charCodeAt(0);\n                            // + - . 0 1 2 3 4 5 6 7 8 9\n                            if ((ascii === 43) || (ascii === 45) || (ascii === 46) || ((ascii > 47) && (ascii < 58))) {\n                                lastDif = null;\n                                currentY = parseFloat(values[j]);\n                                currentData.push(currentX, currentY * spectrum.yFactor);;\n                                currentX += spectrum.deltaX;\n                            } else\n                            // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n                            if ((ascii > 63) && (ascii < 74)) {\n                                lastDif = null;\n                                currentY = parseFloat(String.fromCharCode(ascii - 16) + values[j].substring(1));\n                                currentData.push(currentX, currentY * spectrum.yFactor);;\n                                currentX += spectrum.deltaX;\n                            } else\n                            // negative SQZ digits a b c d e f g h i (ascii 97-105)\n                            if ((ascii > 96) && (ascii < 106)) {\n                                lastDif = null;\n                                currentY = -parseFloat(String.fromCharCode(ascii - 48) + values[j].substring(1));\n                                currentData.push(currentX, currentY * spectrum.yFactor);;\n                                currentX += spectrum.deltaX;\n                            } else\n\n\n\n                            // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n                            if (((ascii > 82) && (ascii < 91)) || (ascii === 115)) {\n                                var dup = parseFloat(String.fromCharCode(ascii - 34) + values[j].substring(1)) - 1;\n                                if (ascii === 115) {\n                                    dup = parseFloat('9' + values[j].substring(1)) - 1;\n                                }\n                                for (var l = 0; l < dup; l++) {\n                                    if (lastDif) {\n                                        currentY = currentY + lastDif;\n                                    }\n                                    currentData.push(currentX, currentY * spectrum.yFactor);;\n                                    currentX += spectrum.deltaX;\n                                }\n                            } else\n                            // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n                            if (ascii === 37) {\n                                lastDif = parseFloat('0' + values[j].substring(1));\n                                currentY += lastDif;\n                                currentData.push(currentX, currentY * spectrum.yFactor);;\n                                currentX += spectrum.deltaX;\n                            } else if ((ascii > 73) && (ascii < 83)) {\n                                lastDif = parseFloat(String.fromCharCode(ascii - 25) + values[j].substring(1));\n                                currentY += lastDif;\n                                currentData.push(currentX, currentY * spectrum.yFactor);;\n                                currentX += spectrum.deltaX;\n                            } else\n                            // negative DIF digits j k l m n o p q r (ascii 106-114)\n                            if ((ascii > 105) && (ascii < 115)) {\n                                lastDif = -parseFloat(String.fromCharCode(ascii - 57) + values[j].substring(1));\n                                currentY += lastDif;\n                                currentData.push(currentX, currentY * spectrum.yFactor);;\n                                currentX += spectrum.deltaX;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n    function convertTo3DZ(spectra) {\n        var noise = 0;\n        var minZ = spectra[0].data[0][0];\n        var maxZ = minZ;\n        var ySize = spectra.length;\n        var xSize = spectra[0].data[0].length / 2;\n        var z = new Array(ySize);\n        for (var i = 0; i < ySize; i++) {\n            z[i] = new Array(xSize);\n            for (var j = 0; j < xSize; j++) {\n                z[i][j] = spectra[i].data[0][j * 2 + 1];\n                if (z[i][j] < minZ) minZ = spectra[i].data[0][j * 2 + 1];\n                if (z[i][j] > maxZ) maxZ = spectra[i].data[0][j * 2 + 1];\n                if (i !== 0 && j !== 0) {\n                    noise += Math.abs(z[i][j] - z[i][j - 1]) + Math.abs(z[i][j] - z[i - 1][j]);\n                }\n            }\n        }\n        return {\n            z: z,\n            minX: spectra[0].data[0][0],\n            maxX: spectra[0].data[0][spectra[0].data[0].length - 2],\n            minY: spectra[0].pageValue,\n            maxY: spectra[ySize - 1].pageValue,\n            minZ: minZ,\n            maxZ: maxZ,\n            noise: noise / ((ySize - 1) * (xSize - 1) * 2)\n        };\n\n    }\n\n    function add2D(result) {\n        var zData = convertTo3DZ(result.spectra);\n        result.contourLines = generateContourLines(zData);\n        delete zData.z;\n        result.minMax = zData;\n    }\n\n\n    function generateContourLines(zData, options) {\n        //console.time('generateContourLines');\n        var noise = zData.noise;\n        var z = zData.z;\n        var contourLevels = [];\n        var nbLevels = 7;\n        var povarHeight = new Float32Array(4);\n        var isOver = [];\n        var nbSubSpectra = z.length;\n        var nbPovars = z[0].length;\n        var pAx, pAy, pBx, pBy;\n\n        var x0 = zData.minX;\n        var xN = zData.maxX;\n        var dx = (xN - x0) / (nbPovars - 1);\n        var y0 = zData.minY;\n        var yN = zData.maxY;\n        var dy = (yN - y0) / (nbSubSpectra - 1);\n        var minZ = zData.minZ;\n        var maxZ = zData.maxZ;\n\n        //System.out.prvarln('y0 '+y0+' yN '+yN);\n        // -------------------------\n        // Povars attribution\n        //\n        // 0----1\n        // |  / |\n        // | /  |\n        // 2----3\n        //\n        // ---------------------d------\n\n        var lineZValue;\n        for (var level = 0; level < nbLevels * 2; level++) { // multiply by 2 for positif and negatif\n            var contourLevel = {};\n            contourLevels.push(contourLevel);\n            var side = level % 2;\n            if (side === 0) {\n                lineZValue = (maxZ - 5 * noise) * Math.exp(level / 2 - nbLevels) + 5 * noise;\n            } else {\n                lineZValue = -(maxZ - 5 * noise) * Math.exp(level / 2 - nbLevels) - 5 * noise;\n            }\n            var lines = [];\n            contourLevel.zValue = lineZValue;\n            contourLevel.lines = lines;\n\n            if (lineZValue <= minZ || lineZValue >= maxZ) continue;\n\n            for (var iSubSpectra = 0; iSubSpectra < nbSubSpectra - 1; iSubSpectra++) {\n                for (var povar = 0; povar < nbPovars - 1; povar++) {\n                    povarHeight[0] = z[iSubSpectra][povar];\n                    povarHeight[1] = z[iSubSpectra][povar + 1];\n                    povarHeight[2] = z[(iSubSpectra + 1)][povar];\n                    povarHeight[3] = z[(iSubSpectra + 1)][(povar + 1)];\n\n                    for (var i = 0; i < 4; i++) {\n                        isOver[i] = (povarHeight[i] > lineZValue);\n                    }\n\n                    // Example povar0 is over the plane and povar1 and\n                    // povar2 are below, we find the varersections and add\n                    // the segment\n                    if (isOver[0] !== isOver[1] && isOver[0] !== isOver[2]) {\n                        pAx = povar + (lineZValue - povarHeight[0]) / (povarHeight[1] - povarHeight[0]);\n                        pAy = iSubSpectra;\n                        pBx = povar;\n                        pBy = iSubSpectra + (lineZValue - povarHeight[0]) / (povarHeight[2] - povarHeight[0]);\n                        lines.push(pAx * dx + x0, pAy * dy + y0, pBx * dx + x0, pBy * dy + y0);\n                    }\n                    if (isOver[3] !== isOver[1] && isOver[3] !== isOver[2]) {\n                        pAx = povar + 1;\n                        pAy = iSubSpectra + 1 - (lineZValue - povarHeight[3]) / (povarHeight[1] - povarHeight[3]);\n                        pBx = povar + 1 - (lineZValue - povarHeight[3]) / (povarHeight[2] - povarHeight[3]);\n                        pBy = iSubSpectra + 1;\n                        lines.push(pAx * dx + x0, pAy * dy + y0, pBx * dx + x0, pBy * dy + y0);\n                    }\n                    // test around the diagonal\n                    if (isOver[1] !== isOver[2]) {\n                        pAx = povar + 1 - (lineZValue - povarHeight[1]) / (povarHeight[2] - povarHeight[1]);\n                        pAy = iSubSpectra + (lineZValue - povarHeight[1]) / (povarHeight[2] - povarHeight[1]);\n                        if (isOver[1] !== isOver[0]) {\n                            pBx = povar + 1 - (lineZValue - povarHeight[1]) / (povarHeight[0] - povarHeight[1]);\n                            pBy = iSubSpectra;\n                            lines.push(pAx * dx + x0, pAy * dy + y0, pBx * dx + x0, pBy * dy + y0);\n                        }\n                        if (isOver[2] !== isOver[0]) {\n                            pBx = povar;\n                            pBy = iSubSpectra + 1 - (lineZValue - povarHeight[2]) / (povarHeight[0] - povarHeight[2]);\n                            lines.push(pAx * dx + x0, pAy * dy + y0, pBx * dx + x0, pBy * dy + y0);\n                        }\n                        if (isOver[1] !== isOver[3]) {\n                            pBx = povar + 1;\n                            pBy = iSubSpectra + (lineZValue - povarHeight[1]) / (povarHeight[3] - povarHeight[1]);\n                            lines.push(pAx * dx + x0, pAy * dy + y0, pBx * dx + x0, pBy * dy + y0);\n                        }\n                        if (isOver[2] !== isOver[3]) {\n                            pBx = povar + (lineZValue - povarHeight[2]) / (povarHeight[3] - povarHeight[2]);\n                            pBy = iSubSpectra + 1;\n                            lines.push(pAx * dx + x0, pAy * dy + y0, pBx * dx + x0, pBy * dy + y0);\n                        }\n                    }\n                }\n            }\n        }\n        // console.timeEnd('generateContourLines');\n        return {\n            minX: zData.minX,\n            maxX: zData.maxX,\n            minY: zData.minY,\n            maxY: zData.maxY,\n            segments: contourLevels\n        };\n        //return contourLevels;\n    }\n\n\n    function addLowRes(spectra, options) {\n        var spectrum;\n        var averageX, averageY;\n        var targetNbPoints = options.lowRes;\n        var highResData;\n        for (var i = 0; i < spectra.length; i++) {\n            spectrum = spectra[i];\n            // we need to find the current higher resolution\n            if (spectrum.data.length > 0) {\n                highResData = spectrum.data[0];\n                for (var j = 1; j < spectrum.data.length; j++) {\n                    if (spectrum.data[j].length > highResData.length) {\n                        highResData = spectrum.data[j];\n                    }\n                }\n\n                if (targetNbPoints > (highResData.length / 2)) return;\n                var i, ii;\n                var lowResData = [];\n                var modulo = Math.ceil(highResData.length / (targetNbPoints * 2));\n                for (i = 0, ii = highResData.length; i < ii; i = i + 2) {\n                    if (i % modulo === 0) {\n                        lowResData.push(highResData[i], highResData[i + 1])\n                    }\n                }\n                spectrum.data.push(lowResData);\n            }\n        }\n    }\n\n    return convert;\n\n}\n\nvar convert = getConverter();\n\nfunction JcampConverter(input, options, useWorker) {\n    if (typeof options === 'boolean') {\n        useWorker = options;\n        options = {};\n    }\n    if (useWorker) {\n        return postToWorker(input, options);\n    } else {\n        return convert(input, options);\n    }\n}\n\nvar stamps = {},\n    worker;\n\nfunction postToWorker(input, options) {\n    if (!worker) {\n        createWorker();\n    }\n    return new Promise(function (resolve) {\n        var stamp = Date.now() + '' + Math.random();\n        stamps[stamp] = resolve;\n        worker.postMessage({stamp: stamp, input: input, options: options});\n    });\n}\n\nfunction createWorker() {\n    var workerURL = URL.createObjectURL(new Blob([\n        'var getConverter =' + getConverter.toString() + ';var convert = getConverter(); onmessage = function (event) { postMessage({stamp: event.data.stamp, output: convert(event.data.input, event.data.options)}); };'\n    ], {type: 'application/javascript'}));\n    worker = new Worker(workerURL);\n    URL.revokeObjectURL(workerURL);\n    worker.addEventListener('message', function (event) {\n        var stamp = event.data.stamp;\n        if (stamps[stamp]) {\n            stamps[stamp](event.data.output);\n        }\n    });\n}\n\nmodule.exports = {\n    convert: JcampConverter\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jcampconverter/src/index.js\n ** module id = 3\n ** module chunks = 0\n **/","var SD = require('./SD');\nvar PeakPicking = require('./PeakPicking');\nvar JcampConverter=require(\"jcampconverter\");\n\nfunction NMR(sd) {\n    SD.call(this, sd); // Héritage\n}\n\nNMR.prototype = Object.create(SD.prototype);\nNMR.prototype.constructor = NMR;\n\nNMR.fromJcamp = function(jcamp,options) {\n    options = options || {xy:true,keepSpectra:true,keepRecordsRegExp:/^.+$/};\n    var spectrum= JcampConverter.convert(jcamp,options);\n    return new NMR(spectrum);\n}\n\n/**\n* Return the observed nucleus \n*/\nNMR.prototype.getNucleus=function(dim){\n    if(!dim||dim==0)\n        return this.sd.xType;\n    else{\n        return \"\";\n    }\n}\n\n/**\n* Returns the solvent name\n*/\nNMR.prototype.getSolventName=function(){\n    return (this.sd.info[\".SOLVENTNAME\"]||this.sd.info[\"$SOLVENT\"]||\"\").replace(\"<\",\"\").replace(\">\",\"\");\n}\n\n//Returns the observe frequency in the direct dimension\nNMR.prototype.observeFrequencyX=function(){\n    return this.sd.spectra[0].observeFrequency;\n}\n\n/**\n* Returns the noise factor depending on the nucleus.\n*/\nNMR.prototype.getNMRPeakThreshold=function(nucleus) {\n    if (nucleus == \"1H\")\n        return 3.0;\n    if (nucleus ==\"13C\")\n        return 5.0;\n    return 1.0;\n}\n\n\n    \n/**\n * @function addNoise(SNR)\n * This function adds white noise to the the given spectraData. The intensity of the noise is \n * calculated from the given signal to noise ratio.\n * @param SNR Signal to noise ratio\n */\n NMR.prototype.addNoise=function(SNR) {\n     //@TODO Implement addNoise filter\n}\n\n\n/**\n * @function addSpectraDatas(spec2,factor1,factor2,autoscale )   \n *  This filter performs a linear combination of two spectraDatas.\n * A=spec1\n * B=spec2\n * After to apply this filter you will get:\n *      A=A*factor1+B*factor2\n * if autoscale is set to 'true' then you will obtain:\n *  A=A*factor1+B*k*factor2\n * Where the k is a factor such that the maximum peak in A is equal to the maximum peak in spectraData2 \n * @param spec2 spectraData2\n * @param factor1 linear factor for spec1\n * @param factor2 linear factor for spec2\n * @param autoscale Auto-adjust scales before combine the spectraDatas\n * @example spec1 = addSpectraDatas(spec1,spec2,1,-1, false) This subtract spec2 from spec1\n*/\nNMR.prototype.addSpectraDatas=function(spec2,factor1,factor2,autoscale ) {\n    //@TODO Implement addSpectraDatas filter\n}\n\n/**\n * @function autoBaseline()\n * Automatically corrects the base line of a given spectraData. After this process the spectraData\n * should have meaningful integrals.\n */\nNMR.prototype.autoBaseline=function( ) {\n    //@TODO Implement autoBaseline filter\n}\n\n/**\n * @function fourierTransform()\n * Fourier transforms the given spectraData (Note. no 2D handling yet) this spectraData have to be of type NMR_FID or 2DNMR_FID\n */\nNMR.prototype.fourierTransform=function( ) {\n    //@TODO Implement fourierTransform filter\n}\n\n/**\n * @function postFourierTransform(ph1corr)\n * This filter makes an phase 1 correction that corrects the problem of the spectra that has been obtained \n * on spectrometers using the Bruker digital filters. This method is used in cases when the BrukerSpectra \n * filter could not find the correct number of points to perform a circular shift.\n * The actual problem is that not all of the spectra has the necessary parameters for use only one method for \n * correcting the problem of the Bruker digital filters.\n * @param spectraData A fourier transformed spectraData.\n * @param ph1corr Phase 1 correction value in radians.\n */\nNMR.prototype.postFourierTransform=function(ph1corr) {\n    //@TODO Implement postFourierTransform filter\n}\n\n/**\n * @function zeroFilling(nPointsX [,nPointsY])\n * This function increase the size of the spectrum, filling the new positions with zero values. Doing it one \n * could increase artificially the spectral resolution.\n * @param nPointsX Number of new zero points in the direct dimension\n * @param nPointsY Number of new zero points in the indirect dimension\n */\nNMR.prototype.zeroFilling=function(nPointsX, nPointsY) {\n    //@TODO Implement zeroFilling filter\n}\n\n/**\n * @function  haarWhittakerBaselineCorrection(waveletScale,whittakerLambda)\n * Applies a baseline correction as described in J Magn Resonance 183 (2006) 145-151 10.1016/j.jmr.2006.07.013\n * The needed parameters are the wavelet scale and the lambda used in the whittaker smoother.\n * @param waveletScale To be described\n * @param whittakerLambda To be described\n */\nNMR.prototype.haarWhittakerBaselineCorrection=function(waveletScale,whittakerLambda) {\n    //@TODO Implement haarWhittakerBaselineCorrection filter\n}\n\n/**\n * @function whittakerBaselineCorrection(whittakerLambda,ranges)\n * Applies a baseline correction as described in J Magn Resonance 183 (2006) 145-151 10.1016/j.jmr.2006.07.013\n * The needed parameters are the Wavelet scale and the lambda used in the Whittaker smoother.\n * @param waveletScale To be described\n * @param whittakerLambda To be described\n * @param ranges A string containing the ranges of no signal.\n */\nNMR.prototype.whittakerBaselineCorrection=function(whittakerLambda,ranges) {\n    //@TODO Implement whittakerBaselineCorrection filter\n}\n\n/**\n * @function brukerSpectra(options)\n * This filter applies a circular shift(phase 1 correction in the time domain) to an NMR FID spectrum that \n * have been obtained on spectrometers using the Bruker digital filters. The amount of shift depends on the \n * parameters DECIM and DSPFVS. This spectraData have to be of type NMR_FID\n * @option DECIM: Acquisition parameter\n * @option DSPFVS: Acquisition parameter\n */\nNMR.prototype.brukerSpectra=function(options) {\n    //@TODO Implement brukerSpectra filter\n}\n\n/**\n * @function apodization(functionName, lineBroadening)\n * Apodization of a spectraData object.\n * @param spectraData An spectraData of type NMR_FID\n * @param functionName Valid values for functionsName are\n *  Exponential, exp\n *  Hamming, hamming\n *  Gaussian, gauss\n *  TRAF, traf\n *  Sine Bell, sb\n *  Sine Bell Squared, sb2\n * @param lineBroadening The parameter LB should either be a line broadening factor in Hz \n * or alternatively an angle given by degrees for sine bell functions and the like.\n * @example SD.apodization(, lineBroadening)\n */\nNMR.prototype.apodization=function(functionName, lineBroadening) {\n    //@TODO Implement apodization filter\n}\n\n/**\n * @function echoAntiechoFilter();\n * That decodes an Echo-Antiecho 2D spectrum.\n */\nNMR.prototype.echoAntiechoFilter=function() {\n    //@TODO Implement echoAntiechoFilter filter\n}\n\n/**\n * @function SNVFilter()\n * This function apply a Standard Normal Variate Transformation over the given spectraData. Mainly used for IR spectra.\n */\nNMR.prototype.SNVFilter=function() {\n    //@TODO Implement SNVFilter\n}\n\n/**\n * @function powerFilter(power)\n * This function applies a power to all the Y values.<br>If the power is less than 1 and the spectrum has negative values, it will be shifted so that the lowest value is zero \n * @param   power   The power to apply\n */\nNMR.prototype.powerFilter=function(power) {\n    var minY=this.getMinY();\n    if(power<1 && minY<0){\n        this.YShift(-1*minY);\n        console.warn(\"SD.powerFilter: The spectrum had negative values and was automatically shifted before applying the function.\");\n    }\n    //@TODO Implement powerFilter\n}\n\n/**\n * @function logarithmFilter(base)\n * This function applies a log to all the Y values.<br>If the spectrum has negative or zero values, it will be shifted so that the lowest value is 1 \n * @param   base    The base to use\n */\nNMR.prototype.logarithmFilter=function(base) {\n    var minY=this.getMinY();\n    if(minY<=0){\n        this.YShift((-1*minY)+1);\n        console.warn(\"SD.logarithmFilter: The spectrum had negative values and was automatically shifted before applying the function.\");\n    }\n   //@TODO Implement logarithmFilter filter\n}\n\n\n/**\n * @function correlationFilter(func) \n * This function correlates the given spectraData with the given vector func. The correlation\n * operation (*) is defined as:\n * \n *                    __ inf\n *  c(x)=f(x)(*)g(x)= \\        f(x)*g(x+i)\n *                   ./    \n *                    -- i=-inf\n * @param func A double array containing the function to correlates the spectraData\n * @example var smoothedSP = SD.correlationFilter(spectraData,[1,1]) returns a smoothed version of the\n * given spectraData. \n */\nNMR.prototype.correlationFilter=function(func) {\n    //@TODO Implement correlationFilter filter\n}\n\n/**\n * @function  phaseCorrection(phi0, phi1)\n * Applies the phase correction (phi0,phi1) to a Fourier transformed spectraData. The angles must be given in radians.\n * @param phi0 Zero order phase correction\n * @param phi1 One order phase correction\n*/\nNMR.prototype.phaseCorrection=function(phi0, phi1) {\n    //@TODO Implement phaseCorrection filter\n}\n\n/**\n * @function automaticPhase() \n * This function determines automatically the correct parameters phi0 and phi1 for a phaseCorrection\n * function and applies it.\n */ \nNMR.prototype.automaticPhase=function() {\n    //@TODO Implement automaticPhase filter\n}\n\n/**\n *  @function useBrukerPhase()\n *  This function extract the parameters of the phaseCorrection from the jcamp-dx parameters\n *  if the spectrum was acquired in Bruker spectrometers . Basically it will look for the parameters\n *  $PHC0 and $PHC1, and will use it to call the phaseCorrection function.\n */\nNMR.prototype.useBrukerPhase=function() {\n   //@TODO Implement useBrukerPhase filter\n}\n\n/**\n * @function nmrPeakDetection(parameters);\n * This function process the given spectraData and tries to determine the NMR signals. Returns an NMRSignal1D array containing all the detected 1D-NMR Signals\n * @param parameters A JSONObject containing the optional parameters:\n * @option fromX:   Lower limit.\n * @option toX:     Upper limit.\n * @option threshold: The minimum intensity to consider a peak as a signal, expressed as a percentage of the highest peak. \n * @option stdev: Number of standard deviation of the noise for the threshold calculation if a threshold is not specified.\n */\nNMR.prototype.nmrPeakDetection=function(parameters) {\n    return PeakPicking.peakPicking(this, parameters);\n}\n\n/**\n * @function toJcamp(options)\n * This function creates a String that represents the given spectraData in the format JCAM-DX 5.0\n * The X,Y data can be compressed using one of the methods described in: \n * \"JCAMP-DX. A STANDARD FORMAT FOR THE EXCHANGE OF ION MOBILITY SPECTROMETRY DATA\", \n *  http://www.iupac.org/publications/pac/pdf/2001/pdf/7311x1765.pdf\n * @option encode: ['FIX','SQZ','DIF','DIFDUP','CVS','PAC'] (Default: 'FIX')\n * @option yfactor: The YFACTOR. It allows to compress the data by removing digits from the ordinate. (Default: 1)\n * @option type: [\"NTUPLES\", \"SIMPLE\"] (Default: \"SIMPLE\")\n * @option keep: A set of user defined parameters of the given SpectraData to be stored in the jcamp.\n * @example SD.toJcamp(spectraData,{encode:'DIFDUP',yfactor:0.01,type:\"SIMPLE\",keep:['#batchID','#url']});\n */ \nNMR.prototype.toJcamp=function(options) {\n     //@TODO Implement toJcamp filter\n     return \"NOT ImplementED\"\n}\n\n\nmodule.exports = NMR;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/NMR.js\n ** module id = 4\n ** module chunks = 0\n **/","/**\n * Implementation of the peak pickig method described by Cobas in:\n * A new approach to improving automated analysis of proton NMR spectra\n * through Global Spectral Deconvolution (GSD)\n * http://www.spectroscopyeurope.com/images/stories/ColumnPDFs/TD_23_1.pdf\n */\nvar JAnalyzer = require('./JAnalyzer');\nvar LM = require('curve-fitting');\nvar Matrix = LM.Matrix;\nvar math = Matrix.algebra;\n//var math = require('mathjs')\nvar PeakPicking={\n    impurities:[],\n    maxJ:20,\n\n    peakPicking:function(spectrum, options){\n        options = options||{nH:10, clean:true, realTop:false, thresholdFactor:1, compile:true, integral:0}\n\n        var nH=options.nH||10;\n        var i, j, nHi, sum;\n        //options.realTop = options.realTop||false;\n        //options.thresholdFactor = options.thresholdFactor || 1;\n        //options.compile = options.compile || false;\n        //options.clean = options.clean || false;\n        //var tmp = spectrum.clone();\n        var noiseLevel = Math.abs(spectrum.getNoiseLevel())*(options.thresholdFactor||1);\n        var peakList = this.GSD(spectrum, noiseLevel);\n        peakList = this.optmizeSpectrum(peakList,spectrum,noiseLevel);\n\n        var signals = this.detectSignals(peakList, spectrum, nH, options.integral||0);\n\n        //Remove all the signals with small integral\n        if(options.clean||false){\n            for(var i=signals.length-1;i>=0;i--){\n                if(signals[i].integralData.value<0.5) {\n                    signals.splice(i, 1);\n                }\n            }\n        }\n        if(options.compile||false){\n            for(i=0;i<signals.length;i++){\n                JAnalyzer.compilePattern(signals[i]);\n                if(signals[i].maskPattern&&signals[i].multiplicity!=\"m\"\n                    && signals[i].multiplicity!=\"\"){\n                    //Create a new signal with the removed peaks\n                    nHi = 0;\n                    sum=0;\n                    var peaksO = [];\n                    for(j=signals[i].maskPattern.length-1;j>=0;j--){\n                        sum+=this.area(signals[i].peaks[j]);\n                        if(signals[i].maskPattern[j]===false) {\n                            var peakR = signals[i].peaks.splice(j)[0];\n                            peaksO.push([peakR.x,peakR.intensity,peakR.width]);\n                            signals[i].maskPattern.splice(j);\n                            signals[i].peaksComp.splice(j);\n                            signals[i].nbPeaks--;\n                            nHi+=this.area(peakR);\n                        }\n                    }\n\n                    if(peaksO.length>0){\n                        nHi=nHi*signals[i].integralData.value/sum;\n                        signals[i].integralData.value-=nHi;\n                        var peaks1 = [];\n                        for(var j=peaksO.length-1;j>=0;j--)\n                            peaks1.push(peaksO[j]);\n                        var newSignals = this.detectSignals(peaks1, spectrum, nHi, options.integral||0);\n                        for(j=0;j<newSignals.length;j++)\n                            signals.push(newSignals[j]);\n                    }\n                }\n            }\n            this.updateIntegrals(signals, nH);\n        }\n        signals.sort(function(a,b){\n            return a.delta1- b.delta1\n        });\n\n        //Remove all the signals with small integral\n        if(options.clean||false){\n            for(var i=signals.length-1;i>=0;i--){\n                if(signals[i].integralData.value<0.5) {\n                    signals.splice(i, 1);\n                }\n            }\n        }\n\n        return signals;\n\n        /*var frequency = spectrum.observeFrequencyX();//getParamDouble(\"$BF1\",400);\n        var imp = this.labelPeaks(peakList, solvent, frequency);\n        return [peakList,imp];\n        */\n        //return createSignals(peakList,nH);\n    },\n\n    optmizeSpectrum: function(peakList, spectrum, noiseLevel){\n        var frequency = spectrum.observeFrequencyX();\n        var group = [];\n        var groups = [];\n        var nL = 4, i, j;\n        var limits = [peakList[0][0],nL*peakList[0][2]];\n        var upperLimit, lowerLimit;\n        //Merge forward\n        for(i=0;i<peakList.length;i++){\n            //If the 2 things overlaps\n            //console.log(peakList[i]+\" - \"+limits);\n            if(Math.abs(peakList[i][0]-limits[0])<(nL*peakList[i][2]+limits[1])){\n                //console.log(\"Here\");\n                //Add the peak to the group\n                group.push(peakList[i]);\n                //Update the group limits\n                upperLimit = limits[0]+limits[1];\n                if(peakList[i][0]+nL*peakList[i][2]>upperLimit){\n                    upperLimit = peakList[i][0]+nL*peakList[i][2];\n                }\n                lowerLimit = limits[0]-limits[1];\n                if(peakList[i][0]-nL*peakList[i][2]<lowerLimit){\n                    lowerLimit = peakList[i][0]-nL*peakList[i][2];\n                }\n                //console.log(limits);\n                limits = [(upperLimit+lowerLimit)/2,Math.abs(upperLimit-lowerLimit)/2];\n                //console.log(limits);\n            }\n            else{\n                groups.push({limits:limits,group:group});\n                //var optmimalPeak = fitSpectrum(group,limits,spectrum);\n                group=[peakList[i]];\n                limits = [peakList[i][0],nL*peakList[i][2]];\n            }\n        }\n        groups.push({limits:limits,group:group});\n        //Merge backward\n        for(i =groups.length-2;i>=0;i--){\n            //The groups overlaps\n            if(Math.abs(groups[i].limits[0]-groups[i+1].limits[0])<\n                (groups[i].limits[1]+groups[i+1].limits[1])/2){\n                for(j=0;j<groups[i+1].group.length;j++){\n                    groups[i].group.push(groups[i+1].group[j]);\n                }\n                upperLimit = groups[i].limits[0]+groups[i].limits[1];\n                if(groups[i+1].limits[0]+groups[i+1].limits[1]>upperLimit){\n                    upperLimit = groups[i+1].limits[0]+groups[i+1].limits[1];\n                }\n                lowerLimit = groups[i].limits[0]-groups[i].limits[1];\n                if(groups[i+1].limits[0]-groups[i+1].limits[1]<lowerLimit){\n                    lowerLimit = groups[i+1].limits[0]-groups[i+1].limits[1];\n                }\n                //console.log(limits);\n                groups[i].limits = [(upperLimit+lowerLimit)/2,Math.abs(upperLimit-lowerLimit)/2];\n\n                groups.splice(i+1,1);\n            }\n\n        }\n        var result = [];\n        var index = 0;\n        for(i =0;i<groups.length;i++){\n            //console.log(i+\" \"+groups[i].limits);\n            //if(Math.abs(groups[i].limits[0]-3.1)<0.1){\n                var optmimalPeaks = this.fitSpectrum(groups[i].group,groups[i].limits,spectrum);\n                for(j=0;j<optmimalPeaks.length;j++){\n                    if(optmimalPeaks[j][1]>noiseLevel){\n                        result.push(optmimalPeaks[j]);\n                    }\n                }\n            //}\n            //index++;\n        }\n        return result;\n\n    },\n\n    fitSpectrum: function(group,limits,spectrum){\n        var xy = this.sampling(spectrum, group,false);\n\n        //This function calculates the spectrum as a sum of lorentzian functions. The Lorentzian\n        //parameters are divided in 3 batches. 1st: centers; 2nd: heights; 3th: widths;\n        var lm_func = function(t,p,c){\n            var nL = p.length/3,factor,i, j,p2, cols = t.rows;\n            var tmp = new Matrix(t.length,1), result = new Matrix(t.length,1);\n            for(j=0;j<cols;j++){\n                result[j][0]=0;\n            }\n            for(i=0;i<nL;i++){\n                p2 = Math.pow(p[i+nL*2][0],2);\n                factor = p[i+nL][0]*p2;\n                for(j=0;j<cols;j++){\n                    result[j][0]+=factor/(Math.pow(t[j][0]-p[i][0],2)+p2);\n                }\n            }\n            return result;\n        };\n\n\n        var nbPoints = xy[0].length;\n        var t = new Matrix(nbPoints,1);//independent variable\n        var y_data = new Matrix(nbPoints,1);\n        var maxY = 0,i;\n        for(i=0;i<nbPoints;i++){\n            t[i][0]=xy[0][i][0];\n            y_data[i][0]=xy[1][i][0];\n            if(y_data[i][0]>maxY)\n                maxY = y_data[i][0];\n        }\n        for(i=0;i<nbPoints;i++){\n            y_data[i][0]/=maxY\n        }\n        var weight = [nbPoints / math.sqrt(y_data.dot(y_data))];\n        //console.log(\"weight: \"+weight+\" \"+nbPoints );\n        var opts = [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ];\n        var consts = [ ];// optional vector of constants\n\n        var nL = group.length;\n        var p_init = new Matrix(nL*3,1);\n        var p_min =  new Matrix(nL*3,1);\n        var p_max =  new Matrix(nL*3,1);\n        for( i=0;i<nL;i++){\n            p_init[i][0] = group[i][0];\n            p_init[i+nL][0] = group[i][1]/maxY;\n            p_init[i+2*nL][0] = group[i][2]/2;\n\n            p_min[i][0] = group[i][0]-0.0025;\n            p_min[i+nL][0] = 0;\n            p_min[i+2*nL][0] = group[i][2]/8;\n\n            p_max[i][0] = group[i][0]+0.0025;\n            p_max[i+nL][0] = group[i][1]*1.3/maxY;\n            p_max[i+2*nL][0] = group[i][2]*2;\n        }\n        //console.log(p_init);\n        //console.log(\"y1=\"+JSON.stringify(lm_func(t,p_init,consts)));\n        var p_fit = LM.optimize(lm_func,p_init,t,y_data,weight,-0.00005,p_min,p_max,consts,opts);\n\n        //Put back the result in the correct format\n        var result = new Array(nL);\n        for( i=0;i<nL;i++){\n            result[i]=[p_fit[i][0],p_fit[i+nL][0]*maxY,p_fit[i+2*nL][0]*2];\n        }\n        //console.log(p_init);\n        //console.log(p_fit);\n        /*console.log(\"x=\"+JSON.stringify(t));\n        console.log(\"y=\"+JSON.stringify(y_data));\n        console.log(\"y0=\"+JSON.stringify(lm_func(t,p_fit,consts)));\n        console.log(\"y1=\"+JSON.stringify(lm_func(t,p_init,consts)));\n        console.log(\"plot(x,y,'r*');hold;plot(x,y0,'b');plot(x,y1,'g');\");*/\n        //console.log(p_init)\n        //console.log(p_fit);\n        return result;\n\n    },\n    /**\n     * This method implements a non linear sampling of the spectrum. The point close to\n     * the critic points are more sampled than the other ones.\n     * @param spectrum\n     * @param peaks\n     * @param rowWise\n     */\n    sampling: function(spectrum, peaks, rowWise){\n        var i0, ie, ic,i, j,nbPoints;\n        var xy = []\n        if(i0>ie){\n            var tmp = i0;\n            i0 = ie;\n            ie = tmp;\n        }\n        //Non linear sampling for each peak.\n        for(i=0;i<peaks.length;i++){\n            var more = true;\n            var nL = 4;\n            while(more) {\n                i0 = spectrum.unitsToArrayPoint(peaks[i][0] - peaks[i][2] * nL);\n                ie = spectrum.unitsToArrayPoint(peaks[i][0] + peaks[i][2] * nL);\n                ic = spectrum.unitsToArrayPoint(peaks[i][0]);\n                if (i0 > ie) {\n                    tmp = i0;\n                    i0 = ie;\n                    ie = tmp;\n                }\n                i0 = i0 < 0 ? 0 : i0;\n                ie = ie >= spectrum.getNbPoints() ? spectrum.getNbPoints() - 1 : ie;\n\n                if (ie - i0 < 10) {\n                    for (j = i0; j <= ie; j++) {\n                        xy.push([spectrum.getX(j), spectrum.getY(j)]);\n                    }\n                    more = false;\n                }\n                else {\n                    xy.push([spectrum.getX(i0), spectrum.getY(i0)]);\n                    xy.push([spectrum.getX(ie), spectrum.getY(ie)]);\n                    if (nL > 0.5) {\n                        nL -= 0.5;\n                    }\n                    else {\n                        nL /= 2;\n                    }\n                }\n            }\n        }\n        //console.log(xy);\n        xy.sort(function(a,b){\n            return a[0]-b[0];\n        });\n        //console.log(\"XX \"+xy.length);\n        var x=[],y=[];\n        var index =0;\n        if(rowWise){\n            x=[xy[0][0]],y=[xy[0][1]];\n            for(i=1;i<xy.length;i++){\n                if(x[index]!=xy[i][0]){\n                    x.push(xy[i][0]);\n                    y.push(xy[i][1]);\n                    index++;\n                }\n            }\n        }\n        else{\n            x=[[xy[0][0]]],y=[[xy[0][1]]];\n            for(i=1;i<xy.length;i++){\n                if(x[index][0]!=xy[i][0]){\n                    x.push([xy[i][0]]);\n                    y.push([xy[i][1]]);\n                    index++;\n                }\n            }\n        }\n        return [x,y];\n\n    },\n\n    getVector: function(spectrum, from, to, rowWise){\n        var i0 = spectrum.unitsToArrayPoint(from);\n        var ie = spectrum.unitsToArrayPoint(to);\n        var x = [];\n        var y = [];\n        if(i0>ie){\n            var tmp = i0;\n            i0 = ie;\n            ie = tmp;\n        }\n        i0=i0<0?0:i0;\n        ie=ie>=spectrum.getNbPoints()?spectrum.getNbPoints()-1:ie;\n        for(var i=i0;i<ie;i+=10){\n            if(rowWise){\n                y.push(spectrum.getY(i));\n                x.push(spectrum.getX(i));\n            }\n            else{\n                y.push([spectrum.getY(i)]);\n                x.push([spectrum.getX(i)]);\n            }\n        }\n        return [x,y];\n    },\n\n\n\n    updateLimits : function(signal){\n        if(signal.multiplicity!=\"m\" && signal.multiplicity!=\"\"){\n            //Remove the integral of the removed peaks\n            var peaksO = signal.peaks;\n            var nbPeaks0 = peaksO.length, index = 0, factor = 0, toRemove = 0;\n\n            for(var i=0;i<nbPeaks0;i++){\n                if(signal.maskPattern[i]===false)\n                    toRemove+=this.area(peaksO[i]);\n                factor+= this.area(peaksO[i]);\n            }\n            factor=signal.integralData.value/factor;\n            signal.integralData.value-=toRemove*factor;\n        }\n        return signal.integralData.value;\n    },\n\n    updateIntegrals : function(signals, nH){\n        var sumIntegral = 0,i,sumObserved=0;\n        for(i=0;i<signals.length;i++){\n            sumObserved+=Math.round(signals[i].integralData.value);\n        }\n        if(sumObserved!=nH){\n\n            sumIntegral=nH/sumObserved;\n            for(i=0;i<signals.length;i++){\n                signals[i].integralData.value*=sumIntegral;\n            }\n        }\n    },\n\n    realTopDetection: function(peakList, spectrum){\n        var listP = [];\n        var alpha, beta, gamma, p,currentPoint;\n        for(j=0;j<peakList.length;j++){\n            currentPoint = spectrum.unitsToArrayPoint(peakList[j][0]);\n            //The detected peak could be moved 1 or 2 unit to left or right.\n            if(spectrum.getY(currentPoint-1)>=spectrum.getY(currentPoint-2)\n                &&spectrum.getY(currentPoint-1)>=spectrum.getY(currentPoint)) {\n                currentPoint--;\n            }\n            else{\n                if(spectrum.getY(currentPoint+1)>=spectrum.getY(currentPoint)\n                    &&spectrum.getY(currentPoint+1)>=spectrum.getY(currentPoint+2)) {\n                    currentPoint++;\n                }\n                else{\n                    if(spectrum.getY(currentPoint-2)>=spectrum.getY(currentPoint-3)\n                        &&spectrum.getY(currentPoint-2)>=spectrum.getY(currentPoint-1)) {\n                        currentPoint-=2;\n                    }\n                    else{\n                        if(spectrum.getY(currentPoint+2)>=spectrum.getY(currentPoint+1)\n                            &&spectrum.getY(currentPoint+2)>=spectrum.getY(currentPoint+3)) {\n                            currentPoint+=2;\n                        }\n                    }\n                }\n            }\n            if(spectrum.getY(currentPoint-1)>0&&spectrum.getY(currentPoint+1)>0\n                &&spectrum.getY(currentPoint)>=spectrum.getY(currentPoint-1)\n                &&spectrum.getY(currentPoint)>=spectrum.getY(currentPoint+1)) {\n                alpha = 20 * Math.log10(spectrum.getY(currentPoint - 1));\n                beta = 20 * Math.log10(spectrum.getY(currentPoint));\n                gamma = 20 * Math.log10(spectrum.getY(currentPoint + 1));\n                p = 0.5 * (alpha - gamma) / (alpha - 2 * beta + gamma);\n\n                peakList[j][0] = spectrum.arrayPointToUnits(currentPoint + p);\n                peakList[j][1] = spectrum.getY(currentPoint) - 0.25 * (spectrum.getY(currentPoint - 1)\n                    - spectrum.getY(currentPoint + 1)) * p;//signal.peaks[j].intensity);\n\n            }\n        }\n    },\n\n    /**\n     * Should we read the impurities table from somewhere else?\n     */\n    init:function(){\n        this.impurities = [{\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":7.26}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.56}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.1}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.17}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.1}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.36}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.28}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.19},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.22}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.98},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.01},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.27},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.43}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.26}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.43}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.73}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.3}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.21},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.48}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.65},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.57},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.39}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.4},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.55}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.09},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.02},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.94}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":8.02},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.96},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.88}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.62}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.71}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.25},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.72},{\"proton\":\"OH\",\"coupling\":5,\"multiplicity\":\"s,t\",\"shift\":1.32}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.05},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.12},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.26}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.14},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.46},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.06}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.76}],\"name\":\"ethylene_glycol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":0.86},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"br_s\",\"shift\":1.26}],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.88},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.26}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.65}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.49},{\"proton\":\"OH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.09}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.33}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":7},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.27}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.22},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":4.04}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.62},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.29},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.68}],\"name\":\"pyridine\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.07}],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.85},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.76}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.36},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.17},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.25}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.03},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.53}],\"name\":\"triethylamine\"}],\"solvent\":\"CDCl3\"},{\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":2.05}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.84}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.96}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.09}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.05}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.36}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.18}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.13},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.13}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.96},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.22},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.41}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":8.02}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.43}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.87}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.63}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.11},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.41}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.56},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.47},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.28}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.28},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.46}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.97},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.83}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.96},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.94},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.78}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.52}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.59}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.12},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.57},{\"proton\":\"OH\",\"coupling\":5,\"multiplicity\":\"s,t\",\"shift\":3.39}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.97},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.05},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.2}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.07},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.45},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.28}],\"name\":\"ethylene_glycol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":0.87},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"br_s\",\"shift\":1.29}],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.88},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.28}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.59}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.31},{\"proton\":\"OH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.12}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.43}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.88},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.27}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.1},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":3.9}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.58},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.35},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.76}],\"name\":\"pyridine\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.13}],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.79},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.63}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.32},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.5},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.5}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.45}],\"name\":\"triethylamine\"}],\"solvent\":\"(CD3)2CO\"},{\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":2.5}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.33}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.91}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.09}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.07}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.37}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.11},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.19}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.11},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.08}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.87},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.65},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.18},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.36}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":8.32}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.4}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.9}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.76}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.09},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.38}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.51},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.38},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.24}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.24},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.43}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.96},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.94},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.78}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.95},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.89},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.73}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.54}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.57}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.06},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.44},{\"proton\":\"OH\",\"coupling\":5,\"multiplicity\":\"s,t\",\"shift\":4.63}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.99},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.03},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.17}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.07},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.43},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.91}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.34}],\"name\":\"ethylene_glycol\"},{\"shifts\":[],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.86},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.25}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.53}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.16},{\"proton\":\"OH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.01}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.42}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.88},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.27}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.04},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":3.78}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.58},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.39},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.79}],\"name\":\"pyridine\"},{\"shifts\":[],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.76},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.6}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.3},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.18},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.25}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.93},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.43}],\"name\":\"triethylamine\"}],\"solvent\":\"(CD3)2SO/DMSO\"},{\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":7.16}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.4}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.55}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.55}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.55}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.15}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.05},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.55}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.07},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.04}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.05},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.79},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.24},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.38}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.15}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.4}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.9}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.27}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.11},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.26}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.46},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.34},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.11}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.12},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.33}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.6},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.57},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.05}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.63},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.36},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.86}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.68}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.35}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.34}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.65},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.89},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.92}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.58},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":1.81},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.85}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.41}],\"name\":\"ethylene_glycol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":0.92},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"br_s\",\"shift\":1.36}],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.89},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.24}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.4}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.07}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.94}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.86},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.23}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":0.95},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":3.67}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.53},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":6.66},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":6.98}],\"name\":\"pyridine\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.29}],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.4},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.57}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.11},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.02},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.13}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.4}],\"name\":\"triethylamine\"}],\"solvent\":\"C6D6\"},{\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":1.94}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.13}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.96}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.08}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.96}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.37}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.16},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.18}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.14},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.13}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.97},{\"proton\":\"OHc\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.2},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.22},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.39}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.58}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.44}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.81}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.44}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.12},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.42}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.53},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.45},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.29}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.28},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.45}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.97},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.96},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.83}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.92},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.89},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.77}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.5}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.6}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.12},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.54},{\"proton\":\"OH\",\"coupling\":5,\"multiplicity\":\"s,t\",\"shift\":2.47}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.97},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.06},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.2}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.06},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.43},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.51}],\"name\":\"ethylene_glycol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":0.86},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"br_s\",\"shift\":1.27}],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.89},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.28}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.57}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.28},{\"proton\":\"OH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.16}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.31}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.87},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.29}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.09},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":3.87}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.57},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.33},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.73}],\"name\":\"pyridine\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.08}],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.8},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.64}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.33},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.2},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.2}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.96},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.45}],\"name\":\"triethylamine\"}],\"solvent\":\"CD3CN\"},{\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":3.31}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[{\"proton\":\"H2O\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.87}],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.99}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.15}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.03}],\"name\":\"acetonitrile\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.33}],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.4}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.15},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.2}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[{\"proton\":\"ArH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":6.92},{\"proton\":\"ArCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.21},{\"proton\":\"ArC(CH3)3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.4}],\"name\":\"BHTb\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.9}],\"name\":\"chloroform\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.45}],\"name\":\"cyclohexane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.78}],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":5.49}],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.18},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.49}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.61},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.58},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.35}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.35},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.52}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.07},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.31},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.92}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.97},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.99},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.86}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.65}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.66}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.19},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.6}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.01},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.09},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.24}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.12},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.5},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.01}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.59}],\"name\":\"ethylene_glycol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":0.88},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"br_s\",\"shift\":1.29}],\"name\":\"grease^f\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"t\",\"shift\":0.9},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.29}],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.64}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.34}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.34}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.89},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.29}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.5},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":3.92}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.53},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.44},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.85}],\"name\":\"pyridine\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":0.1}],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.87},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.71}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.32},{\"proton\":\"CH(o/p)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.16},{\"proton\":\"CH(m)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.16}],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.05},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.58}],\"name\":\"triethylamine\"}],\"solvent\":\"CD3OD\"},{\"impurities\":[{\"shifts\":[{\"proton\":\"X\",\"coupling\":0,\"multiplicity\":\"\",\"shift\":4.79}],\"name\":\"solvent_residual_peak\"},{\"shifts\":[],\"name\":\"H2O\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.08}],\"name\":\"acetic_acid\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.22}],\"name\":\"acetone\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.06}],\"name\":\"acetonitrile\"},{\"shifts\":[],\"name\":\"benzene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.24}],\"name\":\"tert-butyl_alcohol\"},{\"shifts\":[{\"proton\":\"CCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":1.21},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.22}],\"name\":\"tert-butyl_methyl_ether\"},{\"shifts\":[],\"name\":\"BHTb\"},{\"shifts\":[],\"name\":\"chloroform\"},{\"shifts\":[],\"name\":\"cyclohexane\"},{\"shifts\":[],\"name\":\"1,2-dichloroethane\"},{\"shifts\":[],\"name\":\"dichloromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.17},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.56}],\"name\":\"diethyl_ether\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.67},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.61},{\"proton\":\"OCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.37}],\"name\":\"diglyme\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.37},{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.6}],\"name\":\"1,2-dimethoxyethane\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.08},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.06},{\"proton\":\"NCH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.9}],\"name\":\"dimethylacetamide\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":7.92},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.01},{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.85}],\"name\":\"dimethylformamide\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.71}],\"name\":\"dimethyl_sulfoxide\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.75}],\"name\":\"dioxane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.17},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.65}],\"name\":\"ethanol\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.07},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":4.14},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.24}],\"name\":\"ethyl_acetate\"},{\"shifts\":[{\"proton\":\"CH3CO\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":2.19},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":3.18},{\"proton\":\"CH2CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":1.26}],\"name\":\"ethyl_methyl_ketone\"},{\"shifts\":[{\"proton\":\"CH\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.65}],\"name\":\"ethylene_glycol\"},{\"shifts\":[],\"name\":\"grease^f\"},{\"shifts\":[],\"name\":\"n-hexane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":9.5,\"multiplicity\":\"d\",\"shift\":2.61}],\"name\":\"HMPAg\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":3.34}],\"name\":\"methanol\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":0,\"multiplicity\":\"s\",\"shift\":4.4}],\"name\":\"nitromethane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.9}],\"name\":\"n-pentane\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":6,\"multiplicity\":\"d\",\"shift\":1.17},{\"proton\":\"CH\",\"coupling\":6,\"multiplicity\":\"sep\",\"shift\":4.02}],\"name\":\"2-propanol\"},{\"shifts\":[{\"proton\":\"CH(2)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":8.52},{\"proton\":\"CH(3)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.45},{\"proton\":\"CH(4)\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":7.87}],\"name\":\"pyridine\"},{\"shifts\":[],\"name\":\"silicone_greasei\"},{\"shifts\":[{\"proton\":\"CH2\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":1.88},{\"proton\":\"CH2O\",\"coupling\":0,\"multiplicity\":\"m\",\"shift\":3.74}],\"name\":\"tetrahydrofuran\"},{\"shifts\":[],\"name\":\"toluene\"},{\"shifts\":[{\"proton\":\"CH3\",\"coupling\":7,\"multiplicity\":\"t\",\"shift\":0.99},{\"proton\":\"CH2\",\"coupling\":7,\"multiplicity\":\"q\",\"shift\":2.57}],\"name\":\"triethylamine\"}],\"solvent\":\"D2O\"}];\n        //this.impurities = API.getVar(\"impurities\").getValue();\n        //File.parse(\"solvent1H.txt\", {header:false});\n        //console.log(this.impurities[0]);\n    },\n    /*\n     {\n     \"nbPeaks\":1,\"multiplicity\":\"\",\"units\":\"PPM\",\"startX\":3.43505,\"assignment\":\"\",\n     \"pattern\":\"s\",\"stopX\":3.42282,\"observe\":400.08,\"asymmetric\":false,\n     \"delta1\":3.42752,\n     \"integralData\":{\"to\":3.43505,\"value\":590586504,\"from\":3.42282},\n     \"nucleus\":\"1H\",\n     \"peaks\":[{\"intensity\":60066147,\"x\":3.42752}]\n     }\n     */\n    detectSignals: function(peakList, spectrum, nH, integralType){\n        var frequency = spectrum.observeFrequencyX();\n        var signals = [];\n        var signal1D = {};\n        var prevPeak = [100000,0],peaks=null;\n        var rangeX = 16/frequency;//Peaks withing this range are considered to belongs to the same signal1D\n        var spectrumIntegral = 0,cs,sum, i,j;\n        for(i=0;i<peakList.length;i++){\n            //console.log(i+\" \"+peakList[i]);\n            if(Math.abs(peakList[i][0]-prevPeak[0])>rangeX){\n                signal1D = {\"nbPeaks\":1,\"units\":\"PPM\",\n                    \"startX\":peakList[i][0]+peakList[i][2],\n                    \"stopX\":peakList[i][0]-peakList[i][2],\n                    \"multiplicity\":\"\",\"pattern\":\"\",\n                    \"observe\":frequency,\"nucleus\":\"1H\",\n                    \"integralData\":{\"from\":peakList[i][0]-peakList[i][2]*3,\n                                    \"to\":peakList[i][0]+peakList[i][2]*3\n                                    //\"value\":this.area(peakList[i])\n                    },\n                    \"peaks\":[]};\n                signal1D.peaks.push({x:peakList[i][0],\"intensity\":peakList[i][1], width:peakList[i][2]});\n                signals.push(signal1D);\n                //spectrumIntegral+=this.area(peakList[i]);\n            }\n            else{\n                var tmp = peakList[i][0]-peakList[i][2];\n                signal1D.stopX=Math.min(signal1D.stopX,tmp);\n                tmp = peakList[i][0]+peakList[i][2];\n                signal1D.stopX=Math.max(signal1D.stopX,tmp);\n                signal1D.nbPeaks++;\n                signal1D.peaks.push({x:peakList[i][0],\"intensity\":peakList[i][1], width:peakList[i][2]});\n                //signal1D.integralData.value+=this.area(peakList[i]);\n                signal1D.integralData.from=Math.min(signal1D.integralData.from, peakList[i][0]-peakList[i][2]*3);\n                signal1D.integralData.to=Math.max(signal1D.integralData.to,peakList[i][0]+peakList[i][2]*3);\n                //spectrumIntegral+=this.area(peakList[i]);\n            }\n            prevPeak = peakList[i];\n        }\n        //Normalize the integral to the normalization parameter and calculate cs\n        for(i=0;i<signals.length;i++){\n            peaks = signals[i].peaks;\n            var integral = signals[i].integralData;\n            cs = 0;\n            sum = 0;\n            for(var j=0;j<peaks.length;j++){\n                cs+=peaks[j].x*this.area(peaks[j]);//.intensity;\n                sum+=this.area(peaks[j]);\n            }\n            signals[i].delta1 = cs/sum;\n\n            if(integralType==0)\n                integral.value = sum;\n            else {\n                integral.value=spectrum.getArea(integral.from,integral.to);//*nH/spectrumIntegral;\n            }\n            spectrumIntegral+=integral.value;\n\n        }\n        for(var i=0;i<signals.length;i++){\n            //console.log(integral.value);\n            var integral = signals[i].integralData;\n            integral.value*=nH/spectrumIntegral;\n        }\n\n        return signals;\n    },\n\n    area: function(peak){\n        return Math.abs(peak.intensity*peak.width*1.57)//1.772453851);\n    },\n    /**\n     This function tries to determine which peaks belongs to common laboratory solvents\n     as trace impurities from DOI:10.1021/jo971176v. The only parameter of the table is\n     the solvent name.\n     */\n    labelPeaks:function(peakList, solvent, frequency){\n        var column = 0;\n        //console.log(this.impurities[0]);\n        for(column=4;column<this.impurities.length;column++){\n            //console.log(\"sss\".contains);\n            if(this.impurities[0][column].indexOf(solvent)>=0){\n                break;\n            }\n        }\n        //console.log(\"labelPeaks \"+column);\n        var nImpurities = this.impurities.length-1;\n        var nPeaks = peakList.length;\n        //Scores matrix\n        //console.log(nImpurities);\n        var scores = new Array(nImpurities);\n        var max = 0, diff=0, score=0;\n        var gamma = 0.2;//ppm\n        var impurityID=-1;\n        var prevImp = \"\";\n        var maxIntensity = 0,i;\n        for(var j=nPeaks-1;j>=0;j--){\n            if(peakList[j][1]>maxIntensity)\n                maxIntensity = peakList[j][1];\n        }\n\n        for(i=nImpurities-1;i>=0;i--){\n            if(this.impurities[i+1][0]!=prevImp){\n                impurityID++;\n                prevImp=this.impurities[i+1][0];\n            }\n\n            //impID, max, maxIndex, average\n            scores[i]=[impurityID,this.impurities[i+1][2],\n                this.impurities[i+1][3],0,[],0];\n            max = 0;\n            for(var j=nPeaks-1;j>=0;j--){\n                diff = 10000;//Big numnber\n                if(this.impurities[i+1][column]>0)\n                    diff = Math.abs(peakList[j][0]-this.impurities[i+1][column]);\n                if(diff<gamma*3){\n                    score=this.score(diff,gamma);\n                    if(score>max){\n                        max=score;\n                        scores[i][3]=max;\n                        scores[i][4]=[j];\n                    }\n                }\n            }\n        }\n        //Calculate the average score for each impurity set of signals\n        var prevIndex = -1, sum=0, count = 0;\n        var candidates=[];\n        var impuritiesPeaks = [];\n        var i=nImpurities-1;\n        while(i>=-1){\n            if(i==-1||scores[i][0]!=prevIndex&&prevIndex!=-1){\n                if(prevIndex!=-1){\n                    scores[i+1][5]=sum/count;\n                    //Now, lets chech the multiplicities\n                    if(scores[i+1][5]>0.9){\n                        //console.log(scores[i+1][0]+\" SS \");\n                        score=this.updateScore(candidates, peakList, maxIntensity, frequency);\n                        if(score>0.9){\n                            //console.log(candidates);\n                            //TODO: Remove peaks and add it do impuritiesPeaks\n                            for(var j=0;j<candidates.length;j++){\n                                for(var k=candidates[j][4].length-1;k>=0;k--){\n                                    impuritiesPeaks.push(peakList[candidates[j][4][k]]);\n                                }\n                            }\n                        }\n                    }\n                }\n                if(i>=0){\n                    prevIndex=scores[i][0];\n                    sum=scores[i][3];\n                    count=1;\n                    candidates=[scores[i]];\n                }\n\n            }else{\n                prevIndex=scores[i][0];\n                candidates.push(scores[i]);\n                sum+=scores[i][3];\n                count++;\n            }\n            i--;\n        }\n        //console.log(impuritiesPeaks.length);\n\n        return impuritiesPeaks;\n    },\n    /**\n     Updates the score that a given impurity is present in the current spectrum. In this part I would expect\n     to have into account the multiplicity of the signal. Also the relative intensity of the signals.\n     THIS IS the KEY part of the algorithm!!!!!!!!!\n     */\n    updateScore:function(candidates, peakList, maxIntensity, frequency){\n        //You may do it to avoid this part.\n        //return 1;\n\n        //Check the multiplicity\n        var mul = \"\";\n        var j = 0,index, k, maxJppm=this.maxJ/frequency;\n        var min=0, indexMin=0, score=0;\n        for(var i=candidates.length-1;i>=0;i--){\n            mul = candidates[i][1];\n            j = candidates[i][2];\n            //console.log(candidates[i][4]);\n            index = candidates[i][4][0];\n            //console.log(peakList[index][0]+\" \"+mul+\" \"+j+\" \"+index);\n            //I guess we should try to identify the pattern in the nearby.\n            if(mul.indexOf(\"sep\")>=0){\n                if(peakList[index][1]>maxIntensity*0.33){\n                    candidates.splice(i,1);//Not a candidate anymore.\n                }\n            }else{\n                if(mul.indexOf(\"s\")>=0||mul.indexOf(\"X\")>=0){\n                    k=index-1;\n                    min=peakList[index][1];\n                    indexMin=index;\n                    while(k>=0&&Math.abs(peakList[index][0]-peakList[k][0])<0.025){\n                        if(peakList[k][1]<min){\n                            min=peakList[k][1];\n                            indexMin=k;\n                        }\n                        k--;\n                    }\n                    k=index+1;\n                    while(k<peakList.length&&Math.abs(peakList[index][0]-peakList[k][0])<0.025){\n                        if(peakList[k][1]<min){\n                            min=peakList[k][1];\n                            indexMin=k;\n                        }\n                        k++;\n                    }\n                    candidates[i][4][0]=indexMin;\n                    score+=1;\n                }\n            }\n            if(mul.indexOf(\"d\")>=0){\n                if(index>0&&index<peakList.length-1){\n                    var thisJ1 = Math.abs(Math.abs(peakList[index-1][0]-peakList[index][0])*frequency-j);\n                    var thisJ2 = Math.abs(Math.abs(peakList[index+1][0]-peakList[index][0])*frequency-j);\n                    var thisJ3 = Math.abs(Math.abs(peakList[index+1][0]-peakList[index-1][0])*frequency-j);\n                    if(thisJ1<2||thisJ2<2||thisJ3<2){\n                        if(thisJ1<thisJ2){\n                            if(thisJ1<thisJ3){\n                                candidates[i][4]=[index-1,index];\n                                score+=1;\n                            }\n                            else{\n                                candidates[i][4]=[index-1,index+1];\n                                score+=1;\n                            }\n                        }\n                        else{\n                            if(thisJ2<thisJ3){\n                                candidates[i][4]=[index,index+1];\n                                score+=1;\n                            }\n                            else{\n                                candidates[i][4]=[index-1,index+1];\n                                score+=1;\n                            }\n                        }\n                    }\n                }\n            }\n            if(mul.indexOf(\"t\")>=0){\n                //console.log(\"here\");\n                if(index>0&&index<peakList.length-1){\n                    var thisJ1 = Math.abs(Math.abs(peakList[index-1][0]-peakList[index][0])*frequency-j);\n                    var thisJ2 = Math.abs(Math.abs(peakList[index+1][0]-peakList[index][0])*frequency-j);\n                    var thisJ4 = Math.abs(Math.abs(peakList[index+1][0]-peakList[index+2][0])*frequency-j);\n                    //console.log(\"XX \"+thisJ1+\" \"+thisJ2);\n                    if(thisJ1<2){\n                        candidates[i][4]=[index-1, index];\n                        score+=0.5;\n                    }\n                    if(thisJ2<2){\n                        candidates[i][4].push(index+1);\n                        score+=0.5;\n                    }\n                    if(thisJ3<2){\n                        candidates[i][4].push(index+2);\n                        score+=0.5;\n                    }\n\n                }\n            }\n            if(mul.indexOf(\"q\")>=0){\n                if(index>1&&index<peakList.length-2){\n                    var thisJ1 = Math.abs(Math.abs(peakList[index-2][0]-peakList[index-1][0])*frequency-j);\n                    var thisJ2 = Math.abs(Math.abs(peakList[index-1][0]-peakList[index][0])*frequency-j);\n                    var thisJ3 = Math.abs(Math.abs(peakList[index+1][0]-peakList[index][0])*frequency-j);\n                    var thisJ4= Math.abs(Math.abs(peakList[index+2][0]-peakList[index+1][0])*frequency-j);\n                    if(thisJ1<2){\n                        candidates[i][4].push(index-2);\n                        score+=0.25;\n                    }\n                    if(thisJ2<2){\n                        candidates[i][4].push(index-1);\n                        score+=0.25;\n                    }\n                    if(thisJ3<2){\n                        candidates[i][4].push(index+1);\n                        score+=0.25;\n                    }\n                    if(thisJ4<2){\n                        candidates[i][4].push(index+2);\n                        score+=0.25;\n                    }\n                }\n            }\n\n\n        }\n\n        //console.log(score/candidates.length+ \" -> \"+candidates);\n        //Lets remove the candidates to be impurities.\n        //It would be equivalent to mark the peaks as valid again\n        if(score/candidates.length < 0.5){\n            for(var i=candidates.length-1;i>=0;i--){\n                candidates.splice(i,1);\n            }\n            return 0;\n        }\n        //Check the relative intensity\n        return 1;\n    },\n\n    score:function(value, gamma){\n        return Math.exp(-Math.pow(value/gamma,2)/2.0);\n    },\n    /**\n     This function joint all the nearby peaks into single signals. We may try to\n     determine the J-couplings and the multiplicity here.\n     */\n    createSignals:function(){\n\n    },\n    /**\n     Determine the peaks of the spectrum by applying a global spectrum deconvolution.\n     */\n    GSD:function(spectrum, noiseLevel){\n        var data= spectrum.getXYData();\n        var y = new Array(data[1].length);\n        var x = data[0];\n        var frequencyX = spectrum.observeFrequencyX();\n        var rangeX = 16/frequency;//Peaks withing this range are considered to belongs to the same signal1D\n        //Lets remove the noise for better performance\n        for(var i=y.length-1;i>=0;i--){\n            y[i]=data[1][i];\n            if(Math.abs(y[i])<noiseLevel)\n                y[i]=0;\n        }\n\n        var dx = x[1]-x[0];\n        // fill convolution frequency axis\n        var X = [];//x[2:(x.length-2)];\n\n        // fill Savitzky-Golay polynomes\n        var Y = new Array();\n        var dY = new Array();\n        var ddY = new Array();\n        for (var j = 2; j < x.length -2; j++){\n            Y.push((1/35.0)*(-3*y[j-2] + 12*y[j-1] + 17*y[j] + 12*y[j+1] - 3*y[j+2]));\n            X.push(x[j]);\n            dY.push((1/(12*dx))*(y[j-2] - 8*y[j-1] + 8*y[j+1] - y[j+2]));\n            ddY.push((1/(7*dx*dx))*(2*y[j-2] - y[j-1] - 2*y[j] - y[j+1] + 2*y[j+2]));\n        }\n        // pushs max and min points in convolution functions\n        var stackInt = new Array();\n        var intervals = new Array();\n        var minddY = new Array();\n        var maxDdy=0;\n        //console.log(Y.length);\n        for (var i = 0; i < Y.length ; i++){\n            if(Math.abs(ddY[i])>maxDdy){\n                maxDdy = Math.abs(ddY[i]);\n            }\n        }\n        //console.log(maxY+\"x\"+maxDy+\"x\"+maxDdy);\n        var broadMask = new Array();\n        for (var i = 1; i < Y.length -1 ; i++){\n            if ((dY[i] < dY[i-1]) && (dY[i] <= dY[i+1])||\n                (dY[i] <= dY[i-1]) && (dY[i] < dY[i+1])) {\n                stackInt.push(X[i]);\n            }\n\n            if ((dY[i] >= dY[i-1]) && (dY[i] > dY[i+1])||\n                (dY[i] > dY[i-1]) && (dY[i] >= dY[i+1])) {\n                try{\n                    intervals.push( [X[i] , stackInt.pop()] );\n                }\n                catch(e){\n                    console.log(\"Error I don't know why \"+e);\n                }\n            }\n            if ((ddY[i] < ddY[i-1]) && (ddY[i] < ddY[i+1])) {\n                minddY.push( [X[i], Y[i], i] );\n                if(Math.abs(ddY[i])>0.0025*maxDdy){\n                    broadMask.push(false);\n                }\n                else{\n                    broadMask.push(true);\n                }\n            }\n        }\n        // creates a list with (frecuency, linewith, height)\n        dx = Math.abs(dx);\n        //var signalsS = new Array();\n        var signals = new Array();\n        var broadLines=[[[Number.MAX_VALUE,0,0]]];\n        Y.sort(function(a, b){return a-b});\n        for (var j = 0; j < minddY.length; j++){\n            var f = minddY[j];\n            var frequency = f[0];\n            var possible = new Array();\n            for (var k=0;k<intervals.length;k++){\n                var i = intervals[k];\n                if (frequency > i[0] && frequency < i[1])\n                    possible.push(i);\n            }\n            //console.log(\"possible \"+possible.length);\n            if (possible.length > 0)\n                if (possible.length == 1)\n                {\n                    var inter = possible[0];\n                    var linewidth = Math.abs(inter[1] - inter[0]);\n                    var height = f[1];\n                    if (Math.abs(height) > 0.00025*Y[0]){\n                        if(!broadMask[j]){\n                            signals.push([frequency, height, linewidth]);\n                            //signalsS.push([frequency, height]);\n                        }\n                        else{\n                            broadLines.push([frequency, height, linewidth]);\n                        }\n                    }\n                }\n                else\n                {\n                    //TODO: nested peaks\n                    console.log(\"Nested \"+possible);\n                }\n        }\n        //console.log(signalsS);\n        //Optimize the possible broad lines\n        var max=0, maxI=0,count=0;\n        var candidates = [],broadLinesS=[];\n        var isPartOf = false;\n        var rangeX = 16/frequencyX;\n        for(var i=broadLines.length-1;i>0;i--){\n            //console.log(broadLines[i][0]+\" \"+rangeX+\" \"+Math.abs(broadLines[i-1][0]-broadLines[i][0]));\n            if(Math.abs(broadLines[i-1][0]-broadLines[i][0])<rangeX){\n\n                candidates.push(broadLines[i]);\n                if(broadLines[i][1]>max){\n                    max = broadLines[i][1];\n                    maxI = i;\n                }\n                count++;\n            }\n            else{\n                isPartOf = true;\n                if(count>30){\n                    isPartOf = false;\n                    /*for(var j=0;j<signals.length;j++){\n                        if(Math.abs(broadLines[maxI][0]-signals[j][0])<rangeX)\n                            isPartOf = true;\n                    }\n                    console.log(\"Was part of \"+isPartOf);*/\n                }\n                if(isPartOf){\n                    for(var j=0;j<candidates.length;j++){\n                        signals.push([candidates[j][0], candidates[j][1], dx]);\n                    }\n                }\n                else{\n                    var fitted =  this.optimizeLorentzian(candidates);\n                    //console.log(fitted);\n                    signals.push(fitted);\n                    //signalsS.push([fitted[0], fitted[1]]);\n                    //console.log(fitted[0]+\" \"+fitted[2]+\" \"+fitted[1]);\n                    //broadLinesS.push([fitted[0], fitted[1]]);\n\n                }\n                candidates = [];\n                max = 0;\n                maxI = 0;\n                count = 0;\n            }\n        }\n        signals.sort(function (a, b) {\n            return a[0] - b[0];\n        });\n\n        return signals;\n        //jexport(\"peakPicking\",signalsS);\n    },\n\n    optimizeLorentzian:function(data){\n\n        var lm_func = function(t,p,c){\n            var factor = p[2][0]*Math.pow(p[1][0],2);\n            var rows = t.rows;\n            var result = new Matrix(t.rows, t.columns);\n            // var tmp = math.add(math.dotPow(math.subtract(t,p[0][0]),2),Math.pow(p[1][0],2));\n            for(var i=0;i<rows;i++){\n                result[i][0]=p[3][0]+factor/(Math.pow(t[i][0]-p[0][0],2)+Math.pow(p[1][0],2));\n            }\n\n            return result;\n        };\n\n\n        var nbPoints = data.length;\n        var t = new Matrix(nbPoints,1);\n\n        var y_data = new Matrix(nbPoints,1);\n        var sum = 0;\n        var maxY = 0;\n        for(var i=0;i<nbPoints;i++){\n            t[i][0]=data[i][0];\n            y_data[i][0]=data[i][1];\n            if(data[i][1]>maxY)\n                maxY = data[i][1];\n        }\n        //console.log(JSON.stringify(t));\n        //console.log(nbPoints);\n        for(var i=0;i<nbPoints;i++){\n            y_data[i][0]/=maxY\n        }\n        var weight = [nbPoints / math.sqrt(y_data.dot(y_data))];\n        //console.log(\"weight: \"+weight);\n        var opts = [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ];\n        var consts = [ ];                         // optional vector of constants\n\n        var p_init = new Matrix([[(t[0][0]+t[nbPoints-1][0])/2],[Math.abs(t[0][0]-t[nbPoints-1][0])/2],[1],[0]]);\n        var p_min = new Matrix([[t[0][0]],[0.0],[0],[0]]);\n        var p_max = new Matrix([[t[nbPoints-1][0]],[Math.abs(t[0][0]-t[nbPoints-1][0])],[1.5],[0.5]]);\n\n        var p_fit = LM.optimize(lm_func,p_init,t,y_data,weight,-0.01,p_min,p_max,consts,opts);\n\n        return [p_fit[0][0],p_fit[2][0]*maxY,p_fit[1][0]*2];\n    }\n}\n\nmodule.exports = PeakPicking;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/PeakPicking.js\n ** module id = 5\n ** module chunks = 0\n **/","/**\n * This library implements the J analyser described by Cobas et al in the paper:\n * A two-stage approach to automatic determination of 1H NMR coupling constants\n * Created by acastillo on 4/5/15.\n */\nvar JAnalyzer = {\n    pascalTriangle : [[0],[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]],\n    patterns: [\"s\",\"d\",\"t\",\"q\",\"quint\",\"h\",\"sept\",\"o\",\"n\"],\n    symRatio : 1.5,\n    maxErrorIter1 : 2.5,//Hz\n    maxErrorIter2 : 1,//Hz\n    DEBUG : false,\n\n    /**\n     * The compilation process implements at the first stage a normalization procedure described by Golotvin et al.\n     * embedding in peak-component-counting method described by Hoyes et al.\n     * @param signal\n     */\n    compilePattern : function(signal){\n        if(this.DEBUG)console.log(\"Debugin...\");\n\n        signal.multiplicity=\"m\";//By default the multiplicity is massive\n        // 1.1 symmetrize\n        // It will add a set of peaks(signal.peaksComp) to the signal that will be used during\n        // the compilation process. The unit of those peaks will be in Hz\n        signal.symRank = this.symmetrizeChoiseBest(signal,this.maxErrorIter1,1);\n        signal.asymmetric = true;\n       // console.log(signal.delta1+\" \"+signal.symRank);\n        //Is the signal symmetric?\n        if(signal.symRank>=0.95&&signal.peaksComp.length<32){\n            if(this.DEBUG)console.log(signal.delta1+ \" nbPeaks \"+signal.peaksComp.length);\n            signal.asymmetric = false;\n            var i,j,min,max,k=1,P1,Jc=[],n2,maxFlagged;\n            //Loop over the possible number of coupling contributing to the multiplet\n            for(var n=0;n<9;n++){\n                if(this.DEBUG)console.log(\"Trying \"+n+\" couplings\");\n                //1.2 Normalize. It makes a deep copy of the peaks before to modify them.\n                peaks = this.normalize(signal,n);\n                //signal.peaksCompX = peaks;\n                var validPattern = false;//It will change to true, when we find the good patter\n                //Lets check if the signal could be a singulet.\n                if(peaks.length == 1 && n === 0){\n                    validPattern=true;\n                }\n                else{\n                    if(peaks.length <= 1){\n                        continue;\n                    }\n                }\n                // 1.3 Establish a range for the Heights Hi [peaks.intensity*0.85,peaks.intensity*1.15];\n                var ranges = this.getRanges(peaks);\n                n2 = Math.pow(2,n);\n\n                if(this.DEBUG){\n                    console.log(\"ranges: \"+JSON.stringify(ranges));\n                    console.log(\"Target sum: \"+n2);\n                }\n\n                // 1.4 Find a combination of integer heights Hi, one from each Si, that sums to 2^n.\n                var heights = null;\n                while(!validPattern&&(heights = this.getNextCombination(ranges, n2))!==null){\n\n                    if(this.DEBUG){\n                        console.log(\"Possible pattern found with \"+n+\" couplings!!!\");\n                        console.log(heights);\n                    }\n                    // 2.1 Number the components of the multiplet consecutively from 1 to 2n,\n                    //starting at peak 1\n                    var numbering = new Array(heights.length);\n                    k=1;\n                    for(i=0;i<heights.length;i++){\n                        numbering[i]=new Array(heights[i]);\n                        for(j=0;j<heights[i];j++){\n                            numbering[i][j]=k++;\n                        }\n                    }\n                    if(this.DEBUG){\n                        console.log(\"Numbering: \"+JSON.stringify(numbering));\n                    }\n                    Jc = []; //The array to store the detected j-coupling\n                    // 2.2 Set j = 1; J1 = P2 - P1. Flag components 1 and 2 as accounted for.\n                    j=1;\n                    Jc.push(peaks[1].x-peaks[0].x);\n                    P1 = peaks[0].x;\n                    numbering[0].splice(0,1);//Flagged\n                    numbering[1].splice(0,1);//Flagged\n                    k=1;\n                    var nFlagged = 2;\n                    maxFlagged = Math.pow(2,n)-1;\n                    while(Jc.length<n&&nFlagged<maxFlagged&&k<peaks.length){\n                        if(this.DEBUG){\n                            console.log(\"New Jc\"+JSON.stringify(Jc));\n                            console.log(\"Aval. numbering \"+JSON.stringify(numbering));\n                        }\n                        // 4.1. Increment j. Set k to the number of the first unflagged component.\n                        j++;\n                        while(k<peaks.length&&numbering[k].length===0){\n                            k++;\n                        }\n                        if(k<peaks.length){\n                            // 4.2 Jj = Pk - P1.\n                            Jc.push(peaks[k].x-peaks[0].x);\n                            //Flag component k and, for each sum of the...\n                            numbering[k].splice(0,1);//Flageed\n                            nFlagged++;\n                            //Flag the other components of the multiplet\n                            for(var u=2;u<=j;u++){\n                                //TODO improve those loops\n                                var jSum = 0;\n                                for(i=0;i<u;i++){\n                                    jSum+=Jc[i];\n                                }\n                                for(i=1;i<numbering.length;i++){\n                                    //Maybe 0.25 Hz is too much?\n                                    if(Math.abs(peaks[i].x-(P1+jSum))<0.25){\n                                        numbering[i].splice(0,1);//Flageed\n                                        nFlagged++;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    //Calculate the ideal patter by using the extracted j-couplings\n                    var pattern = this.idealPattern(Jc);\n                    //Compare the ideal pattern with the proposed intensities.\n                    // All the intensities have to match to accept the multiplet\n                    validPattern = true;\n                    for(i=0;i<pattern.length;i++){\n                        if(pattern[i].intensity != heights[i])\n                            validPattern = false;\n                    }\n                    //More verbosity of the process\n                    if(this.DEBUG){\n                        console.log(\"Jc \"+JSON.stringify(Jc));\n                        console.log(\"Heights \"+JSON.stringify(heights));\n                        console.log(\"pattern \"+JSON.stringify(pattern));\n                        console.log(\"Valid? \"+validPattern);\n                    }\n                }\n                //If we found a valid pattern we should inform about the pattern.\n                if(validPattern){\n                    this.updateSignal(signal,Jc);\n                }\n            }\n        }\n\n        //Before to return, change the units of peaksComp from Hz to PPM again\n        for(i=0;i<signal.peaksComp.length;i++){\n            signal.peaksComp[i].x/=signal.observe;\n        }\n    },\n\n    updateSignal : function(signal, Jc){\n        //Update the limits of the signal\n        var peaks = signal.peaksComp;//Always in Hz\n        var nbPeaks = peaks.length;\n        signal.startX=peaks[0].x/signal.observe+peaks[0].width;\n        signal.stopX=peaks[nbPeaks-1].x/signal.observe-peaks[nbPeaks-1].width;\n        signal.integralData.to=peaks[0].x/signal.observe+peaks[0].width*3;\n        signal.integralData.from=peaks[nbPeaks-1].x/signal.observe-peaks[nbPeaks-1].width*3;\n\n        //Compile the pattern and format the constant couplings\n        signal.maskPattern = signal.mask2;\n        signal.multiplicity = this.abstractPattern(signal,Jc);\n        signal.pattern=signal.multiplicity;//Our library depends on this parameter, but it is old\n        //console.log(signal);\n        if(this.DEBUG)\n            console.log(\"Final j-couplings: \"+JSON.stringify(Jc));\n    },\n\n    /**\n     * Returns the multiplet in the compact format\n     */\n    abstractPattern : function(signal,Jc){\n        var tol = 0.05,i, pattern = \"\", cont = 1;\n        var newNmrJs = [];\n        if(Jc&&Jc.length>0){\n            Jc.sort(function(a,b){\n                return a-b;\n            });\n            for(i=0;i<Jc.length-1;i++){\n                if(Math.abs(Jc[i]-Jc[i+1])<tol){\n                    cont++;\n                }\n                else{\n                    newNmrJs.push({\"coupling\":Math.abs(Jc[i]),\"multiplicity\":this.patterns[cont]});\n                    pattern+=this.patterns[cont];\n                    cont=1;\n                }\n            }\n            newNmrJs.push({\"coupling\":Math.abs(Jc[i]),\"multiplicity\":this.patterns[cont]});\n            pattern+=this.patterns[cont];\n            signal.nmrJs =  newNmrJs;\n        }\n        else{\n            pattern=\"s\";\n            if(Math.abs(signal.startX-signal.stopX)*signal.observe>16){\n                pattern=\"bs\"\n            }\n        }\n        return pattern;\n    },\n\n    /**\n     *This function creates an ideal pattern from the given J-couplings\n     */\n    idealPattern : function(Jc){\n        var hsum = Math.pow(2,Jc.length),i,j;\n        var pattern = [{x:0,intensity:hsum}];\n        //To split the initial height\n        for(i=0;i<Jc.length;i++){\n            for(j=pattern.length-1;j>=0;j--){\n                pattern.push({x:pattern[j].x+Jc[i]/2,\n                    intensity:pattern[j].intensity/2});\n                pattern[j].x = pattern[j].x-Jc[i]/2;\n                pattern[j].intensity = pattern[j].intensity/2;\n            }\n        }\n        //To sum the heights in the same positions\n        pattern.sort(function compare(a,b) { return a.x-b.x});\n        for(j=pattern.length-2;j>=0;j--){\n            if(Math.abs(pattern[j].x-pattern[j+1].x)<0.1){\n                pattern[j].intensity+= pattern[j+1].intensity\n                pattern.splice(j+1,1);\n            }\n        }\n        return pattern;\n    },\n\n    /**\n     * Find a combination of integer heights Hi, one from each Si, that sums to 2n.\n     */\n    getNextCombination : function(ranges, value){\n        var half = Math.ceil(ranges.values.length/2), lng = ranges.values.length;\n        var sum = 0,i;\n        while(sum!=value){\n            //Update the indexes to point at the next possible combination\n            ok = false;\n            var leftIndex = 0;\n            while(!ok){\n                ok = true;\n                ranges.currentIndex[ranges.active]++;\n                if(ranges.currentIndex[ranges.active]>=ranges.values[ranges.active].length){\n                    //In this case, there is no more possible combinations\n                    if(ranges.active+1==half){\n                        return null;\n                    }\n                    else{\n                        //If this happens we need to try the next active peak\n                        ranges.currentIndex[ranges.active]=0;\n                        ok=false;\n                        ranges.active++;\n                    }\n                }\n                else{\n                    ranges.active=0;\n                }\n            }\n            // Sum the heights for this combination\n            sum=0;\n            for(i=0;i<half;i++){\n                sum+= ranges.values[i][ranges.currentIndex[i]]*2;\n            }\n            if(ranges.values.length%2!==0){\n                sum-= ranges.values[half-1][ranges.currentIndex[half-1]];\n            }\n            if(this.DEBUG){\n                console.log(ranges.currentIndex);\n                console.log(sum+\" \"+value);\n            }\n        }\n        //If the sum is equal to the expected value, fill the array to return\n        if(sum==value){\n            var heights = new Array(lng);\n            for(i=0;i<half;i++){\n                heights[i] = ranges.values[i][ranges.currentIndex[i]];\n                heights[lng-i-1] = ranges.values[i][ranges.currentIndex[i]];\n            }\n            return heights;\n        }\n        return null;\n    },\n\n    /**\n     * This function generates the possible values that each peak can contribute\n     * to the multiplet.\n     * @param peaks\n     * @returns {{values: Array, currentIndex: Array, active: number}}\n     */\n    getRanges : function(peaks){\n        var ranges = new Array(peaks.length);\n        var currentIndex = new Array(peaks.length);\n        var min,max;\n        ranges[0] = [1];\n        ranges[peaks.length-1] = [1];\n        currentIndex[0]=-1;\n        currentIndex[peaks.length-1] = 0;\n        for(var i=1;i<peaks.length-1;i++){\n            min = Math.round(peaks[i].intensity*0.85);\n            max = Math.round(peaks[i].intensity*1.15);\n            ranges[i] =[];\n            for(var j=min;j<=max;j++){\n                ranges[i].push(j);\n            }\n            currentIndex[i]=0;\n        }\n        return {values:ranges, currentIndex:currentIndex, active:0};\n    },\n    /**\n     * Performs a symmetrization of the signal by using different aproximations to the center.\n     * It will return the result of the symmetrization that removes less peaks from the signal\n     * @param signal\n     * @param maxError\n     * @param iteration\n     * @returns {*}\n     */\n    symmetrizeChoiseBest : function(signal,maxError,iteration){\n        var symRank1 = this.symmetrize(signal,maxError,iteration);\n        var tmpPeaks = signal.peaksComp;\n        var tmpMask = signal.mask;\n        var cs = signal.delta1;\n        signal.delta1 = (signal.peaks[0].x+signal.peaks[signal.peaks.length-1].x)/2;\n        var symRank2 = this.symmetrize(signal,maxError,iteration);\n        if(signal.peaksComp.length>tmpPeaks.length)\n            return symRank2;\n        else{\n            signal.delta1 = cs;\n            signal.peaksComp = tmpPeaks;\n            signal.mask = tmpMask;\n            return symRank1;\n        }\n\n    },\n    /**\n     * This function will return a set of symmetric peaks that will\n     * be the enter point for the patter compilation process.\n     */\n    symmetrize : function(signal, maxError, iteration){\n        //Before to symmetrize we need to keep only the peaks that possibly conforms the multiplete\n        var max, min, avg, ratio, avgWidth;\n        var peaks = new Array(signal.peaks.length);\n        //Make a deep copy of the peaks and convert PPM ot HZ\n        for(j=0;j<peaks.length;j++){\n            peaks[j]= {x:signal.peaks[j].x*signal.observe,\n                intensity:signal.peaks[j].intensity,\n                width:signal.peaks[j].width};\n        }\n        //Join the peaks that are closer than 0.25 Hz\n        for(j=peaks.length-2;j>=0;j--){\n            if(Math.abs(peaks[j].x-peaks[j+1].x)<0.25){\n                peaks[j].x = (peaks[j].x*peaks[j].intensity+peaks[j+1].x*peaks[j+1].intensity);\n                peaks[j].intensity = peaks[j].intensity+peaks[j+1].intensity;\n                peaks[j].x/=peaks[j].intensity;\n                peaks[j].intensity/=2;\n                peaks[j].width+=peaks[j+1].width;\n                peaks.splice(j+1,1);\n            }\n        }\n        signal.peaksComp = peaks;\n        var nbPeaks = peaks.length;\n        var mask = new Array(nbPeaks);\n        signal.mask = mask;\n        var left=0, right=peaks.length-1, cs = signal.delta1*signal.observe, middle = [(peaks[0].x+peaks[nbPeaks-1].x)/2,1];\n        maxError = this.error(Math.abs(cs-middle[0]));\n        var heightSum = 0;\n        //We try to symmetrize the extreme peaks. We consider as candidates for symmetricing those which have\n        //ratio smaller than 3\n        for(var i=0;i<nbPeaks;i++){\n            mask[i]= true;\n            heightSum+=signal.peaks[i].intensity;\n        }\n\n        while(left<=right){\n            mask[left] = true;\n            mask[right] = true;\n            if(left==right){\n                if(nbPeaks>2&&Math.abs(peaks[left].x-cs)>maxError){\n                    mask[left] = false;\n                }\n            }\n            else{\n                max = Math.max(peaks[left].intensity,peaks[right].intensity);\n                min = Math.min(peaks[left].intensity,peaks[right].intensity);\n                ratio = max/min;\n                if(ratio>this.symRatio){\n                    if(peaks[left].intensity==min){\n                        mask[left] = false;\n                        right++;\n                    }\n                    else{\n                        mask[right] = false;\n                        left--;\n                    }\n                }\n                else{\n                    var diffL = Math.abs(peaks[left].x-cs);\n                    var diffR = Math.abs(peaks[right].x-cs);\n\n                    if(Math.abs(diffL-diffR)<maxError){\n                        //avg = (peaks[left].intensity+peaks[right].intensity)/2;\n                        avg = Math.min(peaks[left].intensity,peaks[right].intensity);\n                        avgWidth = Math.min(peaks[left].width,peaks[right].width);\n                        peaks[left].intensity=peaks[right].intensity=avg;\n                        peaks[left].width=peaks[right].width=avgWidth;\n                        middle=[middle[0]+((peaks[right].x+peaks[left].x)/2), middle[1]+1];\n                    }\n                    else{\n                        if(Math.max(diffL,diffR)==diffR){\n                            mask[right] = false;\n                            left--;\n                        }\n                        else{\n                            mask[left] = false;\n                            right++;\n                        }\n                    }\n                    if(this.DEBUG){\n                        console.log(\"MaxError: \"+maxError+\" \"+middle[0]+\" \"+middle[1]);\n                        console.log(iteration+\" CS: \"+cs+\" Hz \"+cs/signal.observe+\" PPM\");\n                        console.log(\"Middle: \"+(middle[0]/middle[1])+\" Hz \"+(middle[0]/middle[1])/signal.observe+\" PPM\");\n                        console.log(diffL+ \" \"+diffR);\n                        console.log(Math.abs(diffL-diffR));\n                        console.log(JSON.stringify(peaks));\n                        console.log(JSON.stringify(mask));\n                    }\n                }\n            }\n            left++;\n            right--;\n            //Only alter cs if it is the first iteration of the sym process.\n            if(iteration==1){\n                cs = this.chemicalShift(peaks, mask);\n                //There is not more available peaks\n                if(isNaN(cs)){ return 0;}\n            }\n            maxError = this.error(Math.abs(cs-middle[0]/middle[1]));\n        }\n        //To remove the weak peaks and recalculate the cs\n        for(i=nbPeaks-1;i>=0;i--){\n            if(mask[i]===false){\n                peaks.splice(i,1);\n            }\n        }\n        cs = this.chemicalShift(peaks);\n        if(isNaN(cs)){ return 0;}\n        signal.delta1 = cs/signal.observe;\n        //Now, the peak should be symmetric in heights, but we need to know if it is symmetric in x\n        var symFactor = 0,weight = 0;\n        if(peaks.length>1){\n            for(i=Math.ceil(peaks.length/2)-1;i>=0;i--){\n                symFactor+=(3+Math.min(Math.abs(peaks[i].x-cs),Math.abs(peaks[peaks.length-1-i].x-cs)))\n                /(3+Math.max(Math.abs(peaks[i].x-cs),Math.abs(peaks[peaks.length-1-i].x-cs)))*peaks[i].intensity;\n                weight+=peaks[i].intensity;\n            }\n            symFactor/=weight;\n        }\n        else{\n            if(peaks.length==1)\n                symFactor=1;\n        }\n        var newSumHeights = 0;\n        for(i=0;i<peaks.length;i++){\n            newSumHeights+=peaks[i].intensity;\n        }\n        symFactor-=(heightSum-newSumHeights)/heightSum*0.12; //Removed peaks penalty\n        if(this.DEBUG){\n            console.log(\"Penalty \"+(heightSum-newSumHeights)/heightSum*0.12);\n            console.log(\"cs: \"+(cs/signal.observe)+\" symFactor: \"+symFactor);\n        }\n        //Sometimes we need a second opinion after the first symmetrization.\n        if(symFactor>0.8&&symFactor<0.97&&iteration<2){\n            return this.symmetrize(signal, this.maxErrorIter2, 2);\n        }{\n            //Center the given pattern at cs and symmetrize x\n            if(peaks.length>1) {\n                var weight = 0, dxi;\n                for (i = Math.ceil(peaks.length / 2) - 1; i >= 0; i--) {\n                    dxi = (peaks[i].x - peaks[peaks.length - 1 - i].x)/2.0;\n                    peaks[i].x =cs+dxi;\n                    peaks[peaks.length - 1 - i].x=cs-dxi;\n                }\n            }\n        }\n        return symFactor;\n    },\n\n    error : function(value){\n        var maxError = value*2.5;\n        if(maxError<0.75)\n            maxError = 0.75;\n        if(maxError > 3)\n            maxError = 3;\n        return maxError;\n    },\n    /**\n     * 2 stages normalizarion of the peaks heights to Math.pow(2,n).\n     * Creates a new mask with the peaks that could contribute to the multiplete\n     * @param signal\n     * @param n\n     * @returns {*}\n     */\n    normalize : function(signal, n){\n        //Perhaps this is slow\n        var peaks = JSON.parse(JSON.stringify(signal.peaksComp));\n        var norm = 0,norm2=0,i;//Math.pow(2,n);\n        for(i=0;i<peaks.length;i++){\n            norm+= peaks[i].intensity;\n        }\n        norm=Math.pow(2,n)/norm;\n        signal.mask2 = JSON.parse(JSON.stringify(signal.mask));\n        //console.log(\"Mask0 \"+JSON.stringify(signal.mask2));\n        var index=signal.mask2.length-1;\n        for(i=peaks.length-1;i>=0;i--){\n            peaks[i].intensity*= norm;\n            while(index>=0&&signal.mask2[index]===false)\n                index--;\n            if(peaks[i].intensity<0.75){\n                if(this.DEBUG)\n                    console.log(\"Peak \"+i+\" does not seem to belong to this multiplet \"+peaks[i].intensity);\n                peaks.splice(i,1);\n                signal.mask2[index]=false;\n            }\n            else{\n                norm2+= peaks[i].intensity;\n            }\n            index--;\n        }\n        norm2=Math.pow(2,n)/norm2;\n        for(i=peaks.length-1;i>=0;i--){\n            peaks[i].intensity*= norm2;\n        }\n        //console.log(\"Mask1 \"+JSON.stringify(signal.mask2));\n        if(this.DEBUG) console.log(JSON.stringify(peaks));\n        return peaks;\n    },\n\n    /**\n     * Calculates the chemical shift as the weighted sum of the peaks\n     * @param peaks\n     * @param mask\n     * @returns {number}\n     */\n    chemicalShift : function(peaks, mask){\n        var sum=0,cs= 0, i, area;\n        if(mask){\n            for(i=0;i<peaks.length;i++){\n                //console.log(mask[i]);\n                if(mask[i]===true){\n                    area = this.area(peaks[i]);\n                    sum+=area;\n                    cs+=area*peaks[i].x;\n                }\n            }\n        }\n        else{\n            for(i=0;i<peaks.length;i++){\n                area = this.area(peaks[i]);\n                sum+=area;\n                cs+=area*peaks[i].x;\n            }\n        }\n        return cs/sum;\n    },\n\n    area: function(peak){\n        return Math.abs(peak.intensity*peak.width*1.57)//1.772453851);\n    }\n}\n\nmodule.exports = JAnalyzer;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/JAnalyzer.js\n ** module id = 6\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = require('./LM');\nmodule.exports.Matrix = require('ml-matrix');\nmodule.exports.Matrix.algebra = require('./algebra');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/curve-fitting/src/index.js\n ** module id = 7\n ** module chunks = 0\n **/","/**\n * Created by acastillo on 8/5/15.\n */\nvar Matrix = require(\"ml-matrix\");\nvar math = require(\"./algebra\");\n\nvar DEBUG = false;\n/** Levenberg Marquardt curve-fitting: minimize sum of weighted squared residuals\n ----------  INPUT  VARIABLES  -----------\n func   = function of n independent variables, 't', and m parameters, 'p',\n returning the simulated model: y_hat = func(t,p,c)\n p      = n-vector of initial guess of parameter values\n t      = m-vectors or matrix of independent variables (used as arg to func)\n y_dat  = m-vectors or matrix of data to be fit by func(t,p)\n weight = weighting vector for least squares fit ( weight >= 0 ) ...\n inverse of the standard measurement errors\n Default:  sqrt(d.o.f. / ( y_dat' * y_dat ))\n dp     = fractional increment of 'p' for numerical derivatives\n dp(j)>0 central differences calculated\n dp(j)<0 one sided 'backwards' differences calculated\n dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n Default:  0.001;\n p_min  = n-vector of lower bounds for parameter values\n p_max  = n-vector of upper bounds for parameter values\n c      = an optional matrix of values passed to func(t,p,c)\n opts   = vector of algorithmic parameters\n parameter    defaults    meaning\n opts(1)  =  prnt            3        >1 intermediate results; >2 plots\n opts(2)  =  MaxIter      10*Npar     maximum number of iterations\n opts(3)  =  epsilon_1       1e-3     convergence tolerance for gradient\n opts(4)  =  epsilon_2       1e-3     convergence tolerance for parameters\n opts(5)  =  epsilon_3       1e-3     convergence tolerance for Chi-square\n opts(6)  =  epsilon_4       1e-2     determines acceptance of a L-M step\n opts(7)  =  lambda_0        1e-2     initial value of L-M paramter\n opts(8)  =  lambda_UP_fac   11       factor for increasing lambda\n opts(9)  =  lambda_DN_fac    9       factor for decreasing lambda\n opts(10) =  Update_Type      1       1: Levenberg-Marquardt lambda update\n 2: Quadratic update\n 3: Nielsen's lambda update equations\n\n ----------  OUTPUT  VARIABLES  -----------\n p       = least-squares optimal estimate of the parameter values\n X2      = Chi squared criteria\n sigma_p = asymptotic standard error of the parameters\n sigma_y = asymptotic standard error of the curve-fit\n corr    = correlation matrix of the parameters\n R_sq    = R-squared cofficient of multiple determination\n cvg_hst = convergence history\n\n Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. 22 Sep 2013\n modified from: http://octave.sourceforge.net/optim/function/leasqr.html\n using references by\n Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n Sam Roweis       http://www.cs.toronto.edu/~roweis/notes/lm.pdf\n Manolis Lourakis http://www.ics.forth.gr/~lourakis/levmar/levmar.pdf\n Hans Nielson     http://www2.imm.dtu.dk/~hbn/publ/TR9905.ps\n Mathworks        optimization toolbox reference manual\n K. Madsen, H.B., Nielsen, and O. Tingleff\n http://www2.imm.dtu.dk/pubdb/views/edoc_download.php/3215/pdf/imm3215.pdf\n */\nvar LM = {\n\n    optimize: function(func,p,t,y_dat,weight,dp,p_min,p_max,c,opts){\n\n        var tensor_parameter = 0;\t\t\t// set to 1 of parameter is a tensor\n\n        var iteration  = 0;\t\t\t// iteration counter\n        //func_calls = 0;\t\t\t// running count of function evaluations\n\n        if((typeof p[0])!=\"object\"){\n            for(var i=0;i< p.length;i++){\n                p[i]=[p[i]];\n            }\n\n        }\n        //p = p(:); y_dat = y_dat(:);\t\t// make column vectors\n\n        var eps = 2^-52;\n        var Npar   = p.length;//length(p); \t\t\t// number of parameters\n        var Npnt   = y_dat.length;//length(y_dat);\t\t// number of data points\n        var p_old  = new Matrix.zeros(Npar,1);\t\t// previous set of parameters\n        var y_old  = new Matrix.zeros(Npnt,1);\t\t// previous model, y_old = y_hat(t;p_old)\n        var X2     = 1e-2/eps;\t\t\t// a really big initial Chi-sq value\n        var X2_old = 1e-2/eps;\t\t\t// a really big initial Chi-sq value\n        var J = new Matrix.zeros(Npnt,Npar);\n        /*var J      = new Array(Npnt);//zeros(Npnt,Npar);\t\t// Jacobian matrix\n         for(var  i=0;i<Npnt;i++){\n         J[i] = new Array(Npar);\n         }*/\n\n        if (t.length != y_dat.length) {\n            console.log('lm.m error: the length of t must equal the length of y_dat');\n\n            length_t = t.length;\n            length_y_dat = y_dat.length;\n            var X2 = 0, corr = 0, sigma_p = 0, sigma_y = 0, R_sq = 0, cvg_hist = 0;\n            if (!tensor_parameter) {\n                return;\n            }\n        }\n\n        weight = weight||Math.sqrt((Npnt-Npar+1)/(math.multiply(math.transpose(y_dat),y_dat)));\n        dp = dp || 0.001;\n        p_min   = p_min || math.multiply(Math.abs(p),-100);\n        p_max   = p_max || math.multiply(Math.abs(p),100);\n        c = c || 1;\n        // Algorithmic Paramters\n        //prnt MaxIter  eps1  eps2  epx3  eps4  lam0  lamUP lamDN UpdateType\n        opts = opts ||[  3,10*Npar, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2, 11, 9, 1 ];\n\n        var prnt          = opts[0];\t// >1 intermediate results; >2 plots\n        var MaxIter       = opts[1];\t// maximum number of iterations\n        var epsilon_1     = opts[2];\t// convergence tolerance for gradient\n        var epsilon_2     = opts[3];\t// convergence tolerance for parameter\n        var epsilon_3     = opts[4];\t// convergence tolerance for Chi-square\n        var epsilon_4     = opts[5];\t// determines acceptance of a L-M step\n        var lambda_0      = opts[6];\t// initial value of damping paramter, lambda\n        var lambda_UP_fac = opts[7];\t// factor for increasing lambda\n        var lambda_DN_fac = opts[8];\t// factor for decreasing lambda\n        var Update_Type   = opts[9];\t// 1: Levenberg-Marquardt lambda update\n        // 2: Quadratic update\n        // 3: Nielsen's lambda update equations\n\n        if ( tensor_parameter && prnt == 3 ) prnt = 2;\n\n        //plotcmd='figure(11); plot(t(:,1),y_dat,''og'',t(:,1),y_hat,''-b''); axis tight; drawnow ';\n\n        //p_min=p_min(:); p_max=p_max(:); \t// make column vectors\n\n        if(!dp.length || dp.length == 1){\n            var dp_array = new Array(Npar);\n            for(var i=0;i<Npar;i++)\n                dp_array[i]=[dp];\n            dp=dp_array;\n        }\n\n        // indices of the parameters to be fit\n        var idx   = [];\n        for(var i=0;i<dp.length;i++){\n            if(dp[i]!=0){\n                idx.push(i);\n            }\n        }\n\n        var Nfit = idx.length;\t\t\t// number of parameters to fit\n        var stop = false;\t\t\t\t// termination flag\n\n        var weight_sq = null;\n        //console.log(weight);\n        if ( !weight.length || weight.length < Npnt )\t{\n            // squared weighting vector\n            //weight_sq = ( weight(1)*ones(Npnt,1) ).^2;\n            //console.log(\"weight[0] \"+typeof weight[0]);\n            var tmp = math.multiply(new Matrix.ones(Npnt,1),weight[0]);\n            weight_sq = math.dotMultiply(tmp,tmp);\n        }\n        else{\n            //weight_sq = (weight(:)).^2;\n            weight_sq = math.dotMultiply(weight,weight);\n        }\n\n\n        // initialize Jacobian with finite difference calculation\n        //console.log(\"J \"+weight_sq);\n        var result = this.lm_matx(func,t,p_old,y_old,1,J,p,y_dat,weight_sq,dp,c);\n        var JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n        //[JtWJ,JtWdy,X2,y_hat,J] = this.lm_matx(func,t,p_old,y_old,1,J,p,y_dat,weight_sq,dp,c);\n        //console.log(JtWJ);\n\n        if ( Math.max(Math.abs(JtWdy)) < epsilon_1 ){\n            console.log(' *** Your Initial Guess is Extremely Close to Optimal ***')\n            console.log(' *** epsilon_1 = ', epsilon_1);\n            stop = true;\n        }\n\n\n        switch(Update_Type){\n            case 1: // Marquardt: init'l lambda\n                lambda  = lambda_0;\n                break;\n            default:    // Quadratic and Nielsen\n                lambda  = lambda_0 * Math.max(math.diag(JtWJ));\n                nu=2;\n        }\n        //console.log(X2);\n        X2_old = X2; // previous value of X2\n        //console.log(MaxIter+\" \"+Npar);\n        var cvg_hst = new Matrix.ones(MaxIter,Npar+3);\t\t// initialize convergence history\n        var h = null;\n        while ( !stop && iteration <= MaxIter ) {\t\t// --- Main Loop\n            iteration = iteration + 1;\n            // incremental change in parameters\n            switch(Update_Type){\n                case 1:\t\t\t\t\t// Marquardt\n                    //h = ( JtWJ + lambda * math.diag(math.diag(JtWJ)) ) \\ JtWdy;\n                    //h = math.multiply(math.inv(JtWdy),math.add(JtWJ,math.multiply(lambda,math.diag(math.diag(Npar)))));\n                    h = math.solve(math.add(JtWJ,math.multiply(math.diag(math.diag(JtWJ)),lambda)),JtWdy);\n                    break;\n                default:\t\t\t\t\t// Quadratic and Nielsen\n                    //h = ( JtWJ + lambda * math.eye(Npar) ) \\ JtWdy;\n\n                    h = math.solve(math.add(JtWJ,math.multiply(new Matrix.eye(Npar),lambda)),JtWdy);\n            }\n\n            /*for(var k=0;k< h.length;k++){\n                h[k]=[h[k]];\n            }*/\n            //console.log(\"h \"+h);\n            //h=math.matrix(h);\n            //  big = max(abs(h./p)) > 2;\n            //this is a big step\n            // --- Are parameters [p+h] much better than [p] ?\n            var hidx = new Array(idx.length);\n            for(var k=0;k<idx.length;k++){\n                hidx[k]=h[idx[k]];\n            }\n            var p_try = math.add(p, hidx);// update the [idx] elements\n\n            for(var k=0;k<p_try.length;k++){\n                p_try[k][0]=Math.min(Math.max(p_min[k][0],p_try[k][0]),p_max[k][0]);\n            }\n            // p_try = Math.min(Math.max(p_min,p_try),p_max);           // apply constraints\n\n            var delta_y = math.subtract(y_dat, func(t,p_try,c));       // residual error using p_try\n            //func_calls = func_calls + 1;\n            //X2_try = delta_y' * ( delta_y .* weight_sq );  // Chi-squared error criteria\n\n            var X2_try = math.multiply(math.transpose(delta_y),math.dotMultiply(delta_y,weight_sq));\n\n            if ( Update_Type == 2 ){  \t\t\t  // Quadratic\n                //    One step of quadratic line update in the h direction for minimum X2\n                //var alpha =  JtWdy'*h / ( (X2_try - X2)/2 + 2*JtWdy'*h ) ;\n                var JtWdy_th = math.multiply(math.transpose(JtWdy),h);\n                var alpha =  math.multiply(JtWdy_th,math.inv(math.add(math.multiply(math.subtract(X2_try - X2),1/2)),math.multiply(JtWdy_th,2)));//JtWdy'*h / ( (X2_try - X2)/2 + 2*JtWdy'*h ) ;\n\n                h = math.multiply(alpha, h);\n                for(var k=0;k<idx.length;k++){\n                    hidx[k]=h[idx[k]];\n                }\n\n                p_try = math.add(p ,hidx);                     // update only [idx] elements\n                p_try = math.min(math.max(p_min,p_try),p_max);          // apply constraints\n\n                delta_y = math.subtract(y_dat, func(t,p_try,c));      // residual error using p_try\n                // func_calls = func_calls + 1;\n                //X2_try = delta_y' * ( delta_y .* weight_sq ); // Chi-squared error criteria\n                X2_try = math.multiply(math.transpose(delta_y), mat.dotMultiply(delta_y, weight_sq));\n            }\n\n            //rho = (X2 - X2_try) / ( 2*h' * (lambda * h + JtWdy) ); // Nielsen\n            var rho = (X2-X2_try)/math.multiply(math.multiply(math.transpose(h),2),math.add(math.multiply(lambda, h),JtWdy));\n            //console.log(\"rho \"+rho);\n            if ( rho > epsilon_4 ) {\t\t// it IS significantly better\n                //console.log(\"Here\");\n                dX2 = X2 - X2_old;\n                X2_old = X2;\n                p_old = p;\n                y_old = y_hat;\n                p = p_try;\t\t\t// accept p_try\n\n                result = this.lm_matx(func, t, p_old, y_old, dX2, J, p, y_dat, weight_sq, dp, c);\n                JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n                // decrease lambda ==> Gauss-Newton method\n\n                switch (Update_Type) {\n                    case 1:\t\t\t\t\t\t\t// Levenberg\n                        lambda = Math.max(lambda / lambda_DN_fac, 1.e-7);\n                        break;\n                    case 2:\t\t\t\t\t\t\t// Quadratic\n                        lambda = Math.max(lambda / (1 + alpha), 1.e-7);\n                        break;\n                    case 3:\t\t\t\t\t\t\t// Nielsen\n                        lambda = math.multiply(Math.max(1 / 3, 1 - (2 * rho - 1) ^ 3),lambda);\n                        nu = 2;\n                        break;\n                }\n            }\n            else {\t\t\t\t\t// it IS NOT better\n                X2 = X2_old;\t\t\t// do not accept p_try\n                if (iteration%(2 * Npar)==0) {\t// rank-1 update of Jacobian\n                    result = this.lm_matx(func, t, p_old, y_old, -1, J, p, y_dat, weight_sq, dp, c);\n                    JtWJ = result.JtWJ,JtWdy=result.JtWdy,dX2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n                }\n\n                // increase lambda  ==> gradient descent method\n                switch (Update_Type) {\n                    case 1:\t\t\t\t\t\t\t// Levenberg\n                        lambda = Math.min(lambda * lambda_UP_fac, 1.e7);\n                        break;\n                    case 2:\t\t\t\t\t\t\t// Quadratic\n                        lambda = lambda + Math.abs((X2_try - X2) / 2 / alpha);\n                        break;\n                    case 3:\t\t\t\t\t\t// Nielsen\n                        lambda = lambda * nu;\n                        nu = 2 * nu;\n                        break;\n                }\n                if (DEBUG) {\n                    /*fprintf('>//3d://3d | chi_sq=//10.3e | lambda=//8.1e \\n', iteration,func_calls,X2,lambda );\n                     fprintf('    param:  ');\n                     for pn=1:Npar\n                     fprintf(' //10.3e', p(pn) );\n                     end\n                     fprintf('\\n');\n                     fprintf('    dp/p :  ');\n                     for pn=1:Npar\n                     fprintf(' //10.3e', h(pn) / p(pn) );\n                     end\n                     fprintf('\\n');\n                     end\n\n\n                     cvg_hst(iteration,:) = [ func_calls  p'  X2/2  lambda ];\t// update convergence history\n\n\n                     if ( max(abs(JtWdy)) < epsilon_1  &  iteration > 2 )\n                     fprintf(' **** Convergence in r.h.s. (\"JtWdy\")  **** \\n')\n                     fprintf(' **** epsilon_1 = //e\\n', epsilon_1);\n                     stop = 1;\n                     end\n                     if ( max(abs(h./p)) < epsilon_2  &  iteration > 2 )\n                     fprintf(' **** Convergence in Parameters **** \\n')\n                     fprintf(' **** epsilon_2 = //e\\n', epsilon_2);\n                     stop = 1;\n                     end\n                     if ( X2/(Npnt-Npar+1) < epsilon_3  &  iteration > 2 )\n                     fprintf(' **** Convergence in Chi-square  **** \\n')\n                     fprintf(' **** epsilon_3 = //e\\n', epsilon_3);\n                     stop = 1;\n                     end\n                     if ( iteration == MaxIter )\n                     disp(' !! Maximum Number of Iterations Reached Without Convergence !!')\n                     stop = 1;\n                     end*/\n                }\n            }\n        }// --- End of Main Loop\n\n        // --- convergence achieved, find covariance and confidence intervals\n\n        // equal weights for paramter error analysis\n        weight_sq = math.multiply(math.multiply(math.transpose(delta_y),delta_y), new Matrix.ones(Npnt,1));\n\n        //console.log(\"XX \"+(Npnt-Nfit+1));\n        //console.log(delta_y);\n\n        weight_sq.apply(function(i,j){\n            weight_sq[i][j] = (Npnt-Nfit+1)/weight_sq[i][j];\n        });\n        //console.log(weight_sq);\n        result = this.lm_matx(func,t,p_old,y_old,-1,J,p,y_dat,weight_sq,dp,c);\n        JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n\n        /*if nargout > 2\t\t\t\t// standard error of parameters\n         covar = inv(JtWJ);\n         sigma_p = sqrt(diag(covar));\n         end\n\n         if nargout > 3\t\t\t\t// standard error of the fit\n         //  sigma_y = sqrt(diag(J * covar * J'));\t// slower version of below\n         sigma_y = zeros(Npnt,1);\n         for i=1:Npnt\n         sigma_y(i) = J(i,:) * covar * J(i,:)';\n         end\n         sigma_y = sqrt(sigma_y);\n         end\n\n         if nargout > 4\t\t\t\t// parameter correlation matrix\n         corr = covar ./ [sigma_p*sigma_p'];\n         end\n\n         if nargout > 5\t\t\t\t// coefficient of multiple determination\n         R_sq = corrcoef([y_dat y_hat]);\n         R_sq = R_sq(1,2).^2;\n         end\n\n         if nargout > 6\t\t\t\t// convergence history\n         cvg_hst = cvg_hst(1:iteration,:);\n         end*/\n\n        // endfunction  # ---------------------------------------------------------- LM\n\n        return p;\n    },\n\n    lm_FD_J:function(func,t,p,y,dp,c) {\n        // J = lm_FD_J(func,t,p,y,{dp},{c})\n        //\n        // partial derivatives (Jacobian) dy/dp for use with lm.m\n        // computed via Finite Differences\n        // Requires n or 2n function evaluations, n = number of nonzero values of dp\n        // -------- INPUT VARIABLES ---------\n        // func = function of independent variables, 't', and parameters, 'p',\n        //        returning the simulated model: y_hat = func(t,p,c)\n        // t  = m-vector of independent variables (used as arg to func)\n        // p  = n-vector of current parameter values\n        // y  = func(t,p,c) n-vector initialised by user before each call to lm_FD_J\n        // dp = fractional increment of p for numerical derivatives\n        //      dp(j)>0 central differences calculated\n        //      dp(j)<0 one sided differences calculated\n        //      dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n        //      Default:  0.001;\n        // c  = optional vector of constants passed to y_hat = func(t,p,c)\n        //---------- OUTPUT VARIABLES -------\n        // J  = Jacobian Matrix J(i,j)=dy(i)/dp(j)\ti=1:n; j=1:m\n\n        //   Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. November 2005\n        //   modified from: ftp://fly.cnuce.cnr.it/pub/software/octave/leasqr/\n        //   Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\n        var m = y.length;\t\t\t// number of data points\n        var n = p.length;\t\t\t// number of parameters\n\n        dp = dp || math.multiply(new Matrix.ones(1, n), 0.001);\n\n        var ps = p.clone();//JSON.parse(JSON.stringify(p));\n        //var ps = $.extend(true, [], p);\n        var J = new Matrix(m,n), del =new Array(n);         // initialize Jacobian to Zero\n\n        for (var j = 0;j < n; j++) {\n            //console.log(j+\" \"+dp[j]+\" \"+p[j]+\" \"+ps[j]+\" \"+del[j]);\n            del[j] = dp[j]*(1+Math.abs(p[j][0]));  // parameter perturbation\n            p[j] = [ps[j][0]+del[j]];\t      // perturb parameter p(j)\n            //console.log(j+\" \"+dp[j]+\" \"+p[j]+\" \"+ps[j]+\" \"+del[j]);\n\n            if (del[j] != 0){\n                y1 = func(t, p, c);\n                //func_calls = func_calls + 1;\n                if (dp[j][0] < 0) {\t\t// backwards difference\n                    //J(:,j) = math.dotDivide(math.subtract(y1, y),del[j]);//. / del[j];\n                    //console.log(del[j]);\n                    //console.log(y);\n                    var column = math.dotDivide(math.subtract(y1, y),del[j]);\n                    for(var k=0;k< m;k++){\n                        J[k][j]=column[k][0];\n                    }\n                    //console.log(column);\n                }\n                else{\n                    p[j][0] = ps[j][0] - del[j];\n                    //J(:,j) = (y1 - feval(func, t, p, c)). / (2. * del[j]);\n                    var column = math.dotDivide(math.subtract(y1,func(t,p,c)),2*del[j]);\n                    for(var k=0;k< m;k++){\n                        J[k][j]=column[k][0];\n                    }\n\n                }\t\t\t// central difference, additional func call\n            }\n\n            p[j] = ps[j];\t\t// restore p(j)\n\n        }\n        //console.log(\"lm_FD_J: \"+ JSON.stringify(J));\n        return J;\n\n    },\n\n    // endfunction # -------------------------------------------------- LM_FD_J\n    lm_Broyden_J: function(p_old,y_old,J,p,y){\n        // J = lm_Broyden_J(p_old,y_old,J,p,y)\n        // carry out a rank-1 update to the Jacobian matrix using Broyden's equation\n        //---------- INPUT VARIABLES -------\n        // p_old = previous set of parameters\n        // y_old = model evaluation at previous set of parameters, y_hat(t;p_old)\n        // J  = current version of the Jacobian matrix\n        // p     = current  set of parameters\n        // y     = model evaluation at current  set of parameters, y_hat(t;p)\n        //---------- OUTPUT VARIABLES -------\n        // J = rank-1 update to Jacobian Matrix J(i,j)=dy(i)/dp(j)\ti=1:n; j=1:m\n        //console.log(p+\" X \"+ p_old)\n        var h  = math.subtract(p, p_old);\n\n        //console.log(\"hhh \"+h);\n        var h_t = math.transpose(h);\n        h_t.div(math.multiply(h_t,h));\n\n        //console.log(h_t);\n        //J = J + ( y - y_old - J*h )*h' / (h'*h);\t// Broyden rank-1 update eq'n\n        J = math.add(J, math.multiply(math.subtract(y, math.add(y_old,math.multiply(J,h))),h_t));\n        return J;\n        // endfunction # ---------------------------------------------- LM_Broyden_J\n    },\n\n    lm_matx : function (func,t,p_old,y_old,dX2,J,p,y_dat,weight_sq,dp,c,iteration){\n        // [JtWJ,JtWdy,Chi_sq,y_hat,J] = this.lm_matx(func,t,p_old,y_old,dX2,J,p,y_dat,weight_sq,{da},{c})\n        //\n        // Evaluate the linearized fitting matrix, JtWJ, and vector JtWdy,\n        // and calculate the Chi-squared error function, Chi_sq\n        // Used by Levenberg-Marquard algorithm, lm.m\n        // -------- INPUT VARIABLES ---------\n        // func   = function ofpn independent variables, p, and m parameters, p,\n        //         returning the simulated model: y_hat = func(t,p,c)\n        // t      = m-vectors or matrix of independent variables (used as arg to func)\n        // p_old  = n-vector of previous parameter values\n        // y_old  = m-vector of previous model ... y_old = y_hat(t;p_old);\n        // dX2    = previous change in Chi-squared criteria\n        // J   = m-by-n Jacobian of model, y_hat, with respect to parameters, p\n        // p      = n-vector of current  parameter values\n        // y_dat  = n-vector of data to be fit by func(t,p,c)\n        // weight_sq = square of the weighting vector for least squares fit ...\n        //\t    inverse of the standard measurement errors\n        // dp     = fractional increment of 'p' for numerical derivatives\n        //          dp(j)>0 central differences calculated\n        //          dp(j)<0 one sided differences calculated\n        //          dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n        //          Default:  0.001;\n        // c      = optional vector of constants passed to y_hat = func(t,p,c)\n        //---------- OUTPUT VARIABLES -------\n        // JtWJ\t = linearized Hessian matrix (inverse of covariance matrix)\n        // JtWdy   = linearized fitting vector\n        // Chi_sq = Chi-squared criteria: weighted sum of the squared residuals WSSR\n        // y_hat  = model evaluated with parameters 'p'\n        // J   = m-by-n Jacobian of model, y_hat, with respect to parameters, p\n\n        //   Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. November 2005\n        //   modified from: ftp://fly.cnuce.cnr.it/pub/software/octave/leasqr/\n        //   Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\n\n        var Npnt = y_dat.length;\t\t// number of data points\n        var Npar = p.length;\t\t// number of parameters\n\n        dp = dp || 0.001;\n\n\n        //var JtWJ = new Matrix.zeros(Npar);\n        //var JtWdy  = new Matrix.zeros(Npar,1);\n\n        var y_hat = func(t,p,c);\t// evaluate model using parameters 'p'\n        //func_calls = func_calls + 1;\n        //console.log(J);\n        if ( (iteration%(2*Npar))==0 || dX2 > 0 ) {\n            //console.log(\"Par\");\n            J = this.lm_FD_J(func, t, p, y_hat, dp, c);\t\t// finite difference\n        }\n        else{\n            //console.log(\"ImPar\");\n            J = this.lm_Broyden_J(p_old, y_old, J, p, y_hat); // rank-1 update\n        }\n        var delta_y = math.subtract(y_dat, y_hat);\t// residual error between model and data\n        //console.log(delta_y[0][0]);\n        //console.log(delta_y.rows+\" \"+delta_y.columns+\" \"+JSON.stringify(weight_sq));\n        //var Chi_sq = delta_y' * ( delta_y .* weight_sq ); \t// Chi-squared error criteria\n        var Chi_sq = math.multiply(math.transpose(delta_y),math.dotMultiply(delta_y,weight_sq));\n        //JtWJ  = J' * ( J .* ( weight_sq * ones(1,Npar) ) );\n        var Jt = math.transpose(J);\n\n        //console.log(weight_sq);\n\n        var JtWJ = math.multiply(Jt, math.dotMultiply(J,math.multiply(weight_sq,new Matrix.ones(1,Npar))));\n\n        //JtWdy = J' * ( weight_sq .* delta_y );\n        var JtWdy = math.multiply(Jt, math.dotMultiply(weight_sq,delta_y));\n\n\n        return {JtWJ:JtWJ,JtWdy:JtWdy,Chi_sq:Chi_sq,y_hat:y_hat,J:J};\n        // endfunction  # ------------------------------------------------------ LM_MATX\n    }\n\n\n\n};\n\nmodule.exports = LM;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/curve-fitting/src/LM.js\n ** module id = 8\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = require('./matrix');\nmodule.exports.Decompositions = module.exports.DC = require('./decompositions');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/curve-fitting/~/ml-matrix/src/index.js\n ** module id = 9\n ** module chunks = 0\n **/","'use strict';\n\nvar Asplice = Array.prototype.splice,\n    Aconcat = Array.prototype.concat;\n\n// For performance : http://jsperf.com/clone-array-slice-vs-while-vs-for\nfunction slice(arr) {\n    var i = 0,\n        ii = arr.length,\n        result = new Array(ii);\n    for (; i < ii; i++) {\n        result[i] = arr[i];\n    }\n    return result;\n}\n\n/**\n * Real matrix.\n * @constructor\n * @param {number|Array} nRows - Number of rows of the new matrix or a 2D array containing the data.\n * @param {number|boolean} [nColumns] - Number of columns of the new matrix or a boolean specifying if the input array should be cloned\n */\nfunction Matrix(nRows, nColumns) {\n    var i = 0, rows, columns, matrix, newInstance;\n    if (Array.isArray(nRows)) {\n        newInstance = nColumns;\n        matrix = newInstance ? slice(nRows) : nRows;\n        nRows = matrix.length;\n        nColumns = matrix[0].length;\n        if (typeof nColumns === 'undefined') {\n            throw new TypeError('Data must be a 2D array');\n        }\n        if (nRows > 0 && nColumns > 0) {\n            for (; i < nRows; i++) {\n                if (matrix[i].length !== nColumns) {\n                    throw new RangeError('Inconsistent array dimensions');\n                } else if (newInstance) {\n                    matrix[i] = slice(matrix[i]);\n                }\n            }\n        } else {\n            throw new RangeError('Invalid dimensions: ' + nRows + 'x' + nColumns);\n        }\n    } else if (typeof nRows === 'number') { // Create empty matrix\n        if (nRows > 0 && nColumns > 0) {\n            matrix = new Array(nRows);\n            for (; i < nRows; i++) {\n                matrix[i] = new Array(nColumns);\n            }\n        } else {\n            throw new RangeError('Invalid dimensions: ' + nRows + 'x' + nColumns);\n        }\n    } else {\n        throw new TypeError('Invalid arguments');\n    }\n\n    Object.defineProperty(matrix, 'rows', {writable: true, value: nRows});\n    Object.defineProperty(matrix, 'columns', {writable: true, value: nColumns});\n\n    matrix.__proto__ = Matrix.prototype;\n\n    return matrix;\n}\n\n/**\n * Constructs a Matrix with the chosen dimensions from a 1D array.\n * @param {number} newRows - Number of rows\n * @param {number} newColumns - Number of columns\n * @param {Array} newData - A 1D array containing data for the matrix\n * @returns {Matrix} - The new matrix\n */\nMatrix.from1DArray = function from1DArray(newRows, newColumns, newData) {\n    var length, data, i = 0;\n\n    length = newRows * newColumns;\n    if (length !== newData.length)\n        throw new RangeError('Data length does not match given dimensions');\n\n    data = new Array(newRows);\n    for (; i < newRows; i++) {\n        data[i] = newData.slice(i * newColumns, (i + 1) * newColumns);\n    }\n    return new Matrix(data);\n};\n\n/**\n * Creates a row vector, a matrix with only one row.\n * @param {Array} newData - A 1D array containing data for the vector\n * @returns {Matrix} - The new matrix\n */\nMatrix.rowVector = function rowVector(newData) {\n    return new Matrix([newData]);\n};\n\n/**\n * Creates a column vector, a matrix with only one column.\n * @param {Array} newData - A 1D array containing data for the vector\n * @returns {Matrix} - The new matrix\n */\nMatrix.columnVector = function columnVector(newData) {\n    var l = newData.length, vector = new Array(l);\n    for (var i = 0; i < l; i++)\n        vector[i] = [newData[i]];\n    return new Matrix(vector);\n};\n\n/**\n * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.empty = function empty(rows, columns) {\n    return new Matrix(rows, columns);\n};\n\n/**\n * Creates a matrix with the given dimensions. Values will be set to zero.\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.zeros = function zeros(rows, columns) {\n    return Matrix.empty(rows, columns).fill(0);\n};\n\n/**\n * Creates a matrix with the given dimensions. Values will be set to one.\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.ones = function ones(rows, columns) {\n    return Matrix.empty(rows, columns).fill(1);\n};\n\n/**\n * Creates a matrix with the given dimensions. Values will be randomly set using Math.random().\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} The new matrix\n */\nMatrix.rand = function rand(rows, columns) {\n    var matrix = Matrix.empty(rows, columns);\n    for (var i = 0, ii = matrix.rows; i < ii; i++) {\n        for (var j = 0, jj = matrix.columns; j < jj; j++) {\n            matrix[i][j] = Math.random();\n        }\n    }\n    return matrix;\n};\n\n/**\n * Creates an identity matrix with the given dimension. Values of the diagonal will be 1 and other will be 0.\n * @param {number} n - Number of rows and columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.eye = function eye(n) {\n    var matrix = Matrix.zeros(n, n), l = matrix.rows;\n    for (var i = 0; i < l; i++) {\n        matrix[i][i] = 1;\n    }\n    return matrix;\n};\n\n/**\n * Creates a diagonal matrix based on the given array.\n * @param {Array} data - Array containing the data for the diagonal\n * @returns {Matrix} - The new matrix\n */\nMatrix.diag = function diag(data) {\n    var l = data.length, matrix = Matrix.zeros(l, l);\n    for (var i = 0; i < l; i++) {\n        matrix[i][i] = data[i];\n    }\n    return matrix;\n};\n\n/**\n * Creates an array of indices between two values\n * @param {number} from\n * @param {number} to\n * @returns {Array}\n */\nMatrix.indices = function indices(from, to) {\n    var vector = new Array(to - from);\n    for (var i = 0; i < vector.length; i++)\n        vector[i] = from++;\n    return vector;\n};\n\n// TODO DOC\nMatrix.stack = function stack(arg1) {\n    var i, j, k;\n    if (Matrix.isMatrix(arg1)) {\n        var rows = 0,\n            cols = 0;\n        for (i = 0; i < arguments.length; i++) {\n            rows += arguments[i].rows;\n            if (arguments[i].columns > cols)\n                cols = arguments[i].columns;\n        }\n\n        var r = Matrix.zeros(rows, cols);\n        var c = 0;\n        for (i = 0; i < arguments.length; i++) {\n            var current = arguments[i];\n            for (j = 0; j < current.rows; j++) {\n                for (k = 0; k < current.columns; k++)\n                    r[c][k] = current[j][k];\n                c++;\n            }\n        }\n        return r;\n    }\n    else if (Array.isArray(arg1)) {\n        var matrix = Matrix.empty(arguments.length, arg1.length);\n        for (i = 0; i < arguments.length; i++)\n            matrix.setRow(i, arguments[i]);\n        return matrix;\n    }\n};\n\n// TODO DOC\nMatrix.expand = function expand(base, count) {\n    var expansion = [];\n    for (var i = 0; i < count.length; i++)\n        for (var j = 0; j < count[i]; j++)\n            expansion.push(base[i]);\n    return new Matrix(expansion);\n};\n\n/**\n * Check that the provided value is a Matrix and tries to instantiate one if not\n * @param value - The value to check\n * @returns {Matrix}\n * @throws {TypeError}\n */\nMatrix.checkMatrix = function checkMatrix(value) {\n    if (!value) {\n        throw new TypeError('Argument has to be a matrix');\n    }\n    if (value.klass !== 'Matrix') {\n        value = new Matrix(value);\n    }\n    return value;\n};\n\n/**\n * Returns true if the argument is a Matrix, false otherwise\n * @param value - The value to check\n * @returns {boolean}\n */\nMatrix.isMatrix = function isMatrix(value) {\n    return value ? value.klass === 'Matrix' : false;\n};\n\n/**\n * @property {string} - The name of this class.\n */\nObject.defineProperty(Matrix.prototype, 'klass', {\n    get: function klass() {\n        return 'Matrix';\n    }\n});\n\n/**\n * @property {number} - The number of elements in the matrix.\n */\nObject.defineProperty(Matrix.prototype, 'size', {\n    get: function size() {\n        return this.rows * this.columns;\n    }\n});\n\n/**\n * @private\n * Internal check that a row index is not out of bounds\n * @param {number} index\n */\nMatrix.prototype.checkRowIndex = function checkRowIndex(index) {\n    if (index < 0 || index > this.rows - 1)\n        throw new RangeError('Row index out of range.');\n};\n\n/**\n * @private\n * Internal check that a column index is not out of bounds\n * @param {number} index\n */\nMatrix.prototype.checkColumnIndex = function checkColumnIndex(index) {\n    if (index < 0 || index > this.columns - 1)\n        throw new RangeError('Column index out of range.');\n};\n\n/**\n * @private\n * Internal check that two matrices have the same dimensions\n * @param {Matrix} otherMatrix\n */\nMatrix.prototype.checkDimensions = function checkDimensions(otherMatrix) {\n    if ((this.rows !== otherMatrix.rows) || (this.columns !== otherMatrix.columns))\n        throw new RangeError('Matrices dimensions must be equal.');\n};\n\n/**\n * Applies a callback for each element of the matrix. The function is called in the matrix (this) context.\n * @param {function} callback - Function that will be called with two parameters : i (row) and j (column)\n * @returns {Matrix} this\n */\nMatrix.prototype.apply = function apply(callback) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            callback.call(this, i, j);\n        }\n    }\n    return this;\n};\n\n/**\n * Creates an exact and independent copy of the matrix\n * @returns {Matrix}\n */\nMatrix.prototype.clone = function clone() {\n    return new Matrix(this.to2DArray());\n};\n\n/**\n * Returns a new 1D array filled row by row with the matrix values\n * @returns {Array}\n */\nMatrix.prototype.to1DArray = function to1DArray() {\n    return Aconcat.apply([], this);\n};\n\n/**\n * Returns a 2D array containing a copy of the data\n * @returns {Array}\n */\nMatrix.prototype.to2DArray = function to2DArray() {\n    var l = this.rows, copy = new Array(l);\n    for (var i = 0; i < l; i++) {\n        copy[i] = slice(this[i]);\n    }\n    return copy;\n};\n\n/**\n * @returns {boolean} true if the matrix has one row\n */\nMatrix.prototype.isRowVector = function isRowVector() {\n    return this.rows === 1;\n};\n\n/**\n * @returns {boolean} true if the matrix has one column\n */\nMatrix.prototype.isColumnVector = function isColumnVector() {\n    return this.columns === 1;\n};\n\n/**\n * @returns {boolean} true if the matrix has one row or one column\n */\nMatrix.prototype.isVector = function isVector() {\n    return (this.rows === 1) || (this.columns === 1);\n};\n\n/**\n * @returns {boolean} true if the matrix has the same number of rows and columns\n */\nMatrix.prototype.isSquare = function isSquare() {\n    return this.rows === this.columns;\n};\n\n/**\n * @returns {boolean} true if the matrix is square and has the same values on both sides of the diagonal\n */\nMatrix.prototype.isSymmetric = function isSymmetric() {\n    if (this.isSquare()) {\n        var l = this.rows;\n        for (var i = 0; i < l; i++) {\n            for (var j = 0; j <= i; j++) {\n                if (this[i][j] !== this[j][i]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\n/**\n * Sets a given element of the matrix. mat.set(3,4,1) is equivalent to mat[3][4]=1\n * @param {number} rowIndex - Index of the row\n * @param {number} columnIndex - Index of the column\n * @param {number} value - The new value for the element\n * @returns {Matrix} this\n */\nMatrix.prototype.set = function set(rowIndex, columnIndex, value) {\n    this[rowIndex][columnIndex] = value;\n    return this;\n};\n\n/**\n * Returns the given element of the matrix. mat.get(3,4) is equivalent to matrix[3][4]\n * @param {number} rowIndex - Index of the row\n * @param {number} columnIndex - Index of the column\n * @returns {number}\n */\nMatrix.prototype.get = function get(rowIndex, columnIndex) {\n    return this[rowIndex][columnIndex];\n};\n\n/**\n * Fills the matrix with a given value. All elements will be set to this value.\n * @param {number} value - New value\n * @returns {Matrix} this\n */\nMatrix.prototype.fill = function fill(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] = value;\n        }\n    }\n    return this;\n};\n\n/**\n * Negates the matrix. All elements will be multiplied by (-1)\n * @returns {Matrix} this\n */\nMatrix.prototype.neg = function neg() {\n    return this.mulS(-1);\n};\n\n/**\n * Adds a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.add = function add(value) {\n    if (typeof value === 'number')\n        return this.addS(value);\n    value = Matrix.checkMatrix(value);\n        return this.addM(value);\n};\n\n/**\n * Adds a scalar to each element of the matrix\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.addS = function addS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += value;\n        }\n    }\n    return this;\n};\n\n/**\n * Adds the value of each element of matrix to the corresponding element of this\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.addM = function addM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.sub = function sub(value) {\n    if (typeof value === 'number')\n        return this.subS(value);\n    value = Matrix.checkMatrix(value);\n        return this.subM(value);\n};\n\n/**\n * Subtracts a scalar from each element of the matrix\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.subS = function subS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= value;\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts the value of each element of matrix from the corresponding element of this\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.subM = function subM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mul = function mul(value) {\n    if (typeof value === 'number')\n        return this.mulS(value);\n    value = Matrix.checkMatrix(value);\n        return this.mulM(value);\n};\n\n/**\n * Multiplies a scalar with each element of the matrix\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mulS = function mulS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= value;\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the value of each element of matrix with the corresponding element of this\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.mulM = function mulM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Divides by a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.div = function div(value) {\n    if (typeof value === 'number')\n        return this.divS(value);\n    value = Matrix.checkMatrix(value);\n        return this.divM(value);\n};\n\n/**\n * Divides each element of the matrix by a scalar\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.divS = function divS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= value;\n        }\n    }\n    return this;\n};\n\n/**\n * Divides each element of this by the corresponding element of matrix\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.divM = function divM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Returns a new array from the given row index\n * @param {number} index - Row index\n * @returns {Array}\n */\nMatrix.prototype.getRow = function getRow(index) {\n    this.checkRowIndex(index);\n    return slice(this[index]);\n};\n\n/**\n * Returns a new row vector from the given row index\n * @param {number} index - Row index\n * @returns {Matrix}\n */\nMatrix.prototype.getRowVector = function getRowVector(index) {\n    return Matrix.rowVector(this.getRow(index));\n};\n\n/**\n * Sets a row at the given index\n * @param {number} index - Row index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.setRow = function setRow(index, array) {\n    this.checkRowIndex(index);\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    if (array.length !== this.columns)\n        throw new RangeError('Invalid row size');\n    this[index] = slice(array);\n    return this;\n};\n\n/**\n * Removes a row from the given index\n * @param {number} index - Row index\n * @returns {Matrix} this\n */\nMatrix.prototype.removeRow = function removeRow(index) {\n    this.checkRowIndex(index);\n    if (this.rows === 1)\n        throw new RangeError('A matrix cannot have less than one row');\n    Asplice.call(this, index, 1);\n    this.rows -= 1;\n    return this;\n};\n\n/**\n * Adds a row at the given index\n * @param {number} [index = this.rows] - Row index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addRow = function addRow(index, array) {\n    if (typeof array === 'undefined') {\n        array = index;\n        index = this.rows;\n    }\n    if (index < 0 || index > this.rows)\n        throw new RangeError('Row index out of range.');\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    if (array.length !== this.columns)\n        throw new RangeError('Invalid row size');\n    Asplice.call(this, index, 0, slice(array));\n    this.rows += 1;\n    return this;\n};\n\n/**\n * Swaps two rows\n * @param {number} row1 - First row index\n * @param {number} row2 - Second row index\n * @returns {Matrix} this\n */\nMatrix.prototype.swapRows = function swapRows(row1, row2) {\n    this.checkRowIndex(row1);\n    this.checkRowIndex(row2);\n    var temp = this[row1];\n    this[row1] = this[row2];\n    this[row2] = temp;\n    return this;\n};\n\n/**\n * Returns a new array from the given column index\n * @param {number} index - Column index\n * @returns {Array}\n */\nMatrix.prototype.getColumn = function getColumn(index) {\n    this.checkColumnIndex(index);\n    var l = this.rows, column = new Array(l);\n    for (var i = 0; i < l; i++) {\n        column[i] = this[i][index];\n    }\n    return column;\n};\n\n/**\n * Returns a new column vector from the given column index\n * @param {number} index - Column index\n * @returns {Matrix}\n */\nMatrix.prototype.getColumnVector = function getColumnVector(index) {\n    return Matrix.columnVector(this.getColumn(index));\n};\n\n/**\n * Sets a column at the given index\n * @param {number} index - Column index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.setColumn = function setColumn(index, array) {\n    this.checkColumnIndex(index);\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    var l = this.rows;\n    if (array.length !== l)\n        throw new RangeError('Invalid column size');\n    for (var i = 0; i < l; i++) {\n        this[i][index] = array[i];\n    }\n    return this;\n};\n\n/**\n * Removes a column from the given index\n * @param {number} index - Column index\n * @returns {Matrix} this\n */\nMatrix.prototype.removeColumn = function removeColumn(index) {\n    this.checkColumnIndex(index);\n    if (this.columns === 1)\n        throw new RangeError('A matrix cannot have less than one column');\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        this[i].splice(index, 1);\n    }\n    this.columns -= 1;\n    return this;\n};\n\n/**\n * Adds a column at the given index\n * @param {number} [index = this.columns] - Column index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addColumn = function addColumn(index, array) {\n    if (typeof array === 'undefined') {\n        array = index;\n        index = this.columns;\n    }\n    if (index < 0 || index > this.columns)\n        throw new RangeError('Column index out of range.');\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    var l = this.rows;\n    if (array.length !== l)\n        throw new RangeError('Invalid column size');\n    for (var i = 0; i < l; i++) {\n        this[i].splice(index, 0, array[i]);\n    }\n    this.columns += 1;\n    return this;\n};\n\n/**\n * Swaps two columns\n * @param {number} column1 - First column index\n * @param {number} column2 - Second column index\n * @returns {Matrix} this\n */\nMatrix.prototype.swapColumns = function swapColumns(column1, column2) {\n    this.checkRowIndex(column1);\n    this.checkRowIndex(column2);\n    var l = this.rows, temp, row;\n    for (var i = 0; i < l; i++) {\n        row = this[i];\n        temp = row[column1];\n        row[column1] = row[column2];\n        row[column2] = temp;\n    }\n    return this;\n};\n\n/**\n * @private\n * Internal check that the provided vector is an array with the right length\n * @param {Array|Matrix} vector\n * @returns {Array}\n * @throws {RangeError}\n */\nMatrix.prototype.checkRowVector = function checkRowVector(vector) {\n    if (Matrix.isMatrix(vector))\n        vector = vector.to1DArray();\n    if (vector.length !== this.columns)\n        throw new RangeError('vector size must be the same as the number of columns');\n    return vector;\n};\n\n/**\n * @private\n * Internal check that the provided vector is an array with the right length\n * @param {Array|Matrix} vector\n * @returns {Array}\n * @throws {RangeError}\n */\nMatrix.prototype.checkColumnVector = function checkColumnVector(vector) {\n    if (Matrix.isMatrix(vector))\n        vector = vector.to1DArray();\n    if (vector.length !== this.rows)\n        throw new RangeError('vector size must be the same as the number of rows');\n    return vector;\n};\n\n/**\n * Adds the values of a vector to each row\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addRowVector = function addRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts the values of a vector from each row\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.subRowVector = function subRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a vector with each row\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.mulRowVector = function mulRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Divides the values of each row by those of a vector\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.divRowVector = function divRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Adds the values of a vector to each column\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addColumnVector = function addColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts the values of a vector from each column\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.subColumnVector = function subColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a vector with each column\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.mulColumnVector = function mulColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Divides the values of each column by those of a vector\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.divColumnVector = function divColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a row with a scalar\n * @param {number} index - Row index\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mulRow = function mulRow(index, value) {\n    this.checkRowIndex(index);\n    var i = 0, l = this.columns;\n    for (; i < l; i++) {\n        this[index][i] *= value;\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a column with a scalar\n * @param {number} index - Column index\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mulColumn = function mulColumn(index, value) {\n    this.checkColumnIndex(index);\n    var i = 0, l = this.rows;\n    for (; i < l; i++) {\n        this[i][index] *= value;\n    }\n};\n\n/**\n * A matrix index\n * @typedef {Object} MatrixIndex\n * @property {number} row\n * @property {number} column\n */\n\n/**\n * Returns the maximum value of the matrix\n * @returns {number}\n */\nMatrix.prototype.max = function max() {\n    var v = -Infinity;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] > v) {\n                v = this[i][j];\n            }\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value\n * @returns {MatrixIndex}\n */\nMatrix.prototype.maxIndex = function maxIndex() {\n    var v = -Infinity;\n    var idx = {};\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] > v) {\n                v = this[i][j];\n                idx.row = i;\n                idx.column = j;\n            }\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the minimum value of the matrix\n * @returns {number}\n */\nMatrix.prototype.min = function min() {\n    var v = Infinity;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] < v) {\n                v = this[i][j];\n            }\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the minimum value\n * @returns {MatrixIndex}\n */\nMatrix.prototype.minIndex = function minIndex() {\n    var v = Infinity;\n    var idx = {};\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] < v) {\n                v = this[i][j];\n                idx.row = i;\n                idx.column = j;\n            }\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the maximum value of one row\n * @param {number} index - Row index\n * @returns {number}\n */\nMatrix.prototype.maxRow = function maxRow(index) {\n    this.checkRowIndex(index);\n    var v = -Infinity;\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] > v) {\n            v = this[index][i];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value of one row\n * @param {number} index - Row index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.maxRowIndex = function maxRowIndex(index) {\n    this.checkRowIndex(index);\n    var v = -Infinity;\n    var idx = {\n            row: index\n        };\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] > v) {\n            v = this[index][i];\n            idx.column = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the minimum value of one row\n * @param {number} index - Row index\n * @returns {number}\n */\nMatrix.prototype.minRow = function minRow(index) {\n    this.checkRowIndex(index);\n    var v = Infinity;\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] < v) {\n            v = this[index][i];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value of one row\n * @param {number} index - Row index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.minRowIndex = function minRowIndex(index) {\n    this.checkRowIndex(index);\n    var v = Infinity;\n    var idx = {\n        row: index,\n        column: 0\n    };\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] < v) {\n            v = this[index][i];\n            idx.column = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the maximum value of one column\n * @param {number} index - Column index\n * @returns {number}\n */\nMatrix.prototype.maxColumn = function maxColumn(index) {\n    this.checkColumnIndex(index);\n    var v = -Infinity;\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] > v) {\n            v = this[i][index];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value of one column\n * @param {number} index - Column index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.maxColumnIndex = function maxColumnIndex(index) {\n    this.checkColumnIndex(index);\n    var v = -Infinity;\n    var idx = {\n        row: 0,\n        column: index\n    };\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] > v) {\n            v = this[i][index];\n            idx.row = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the minimum value of one column\n * @param {number} index - Column index\n * @returns {number}\n */\nMatrix.prototype.minColumn = function minColumn(index) {\n    this.checkColumnIndex(index);\n    var v = Infinity;\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] < v) {\n            v = this[i][index];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the minimum value of one column\n * @param {number} index - Column index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.minColumnIndex = function minColumnIndex(index) {\n    this.checkColumnIndex(index);\n    var v = Infinity;\n    var idx = {\n        row: 0,\n        column: index\n    };\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] < v) {\n            v = this[i][index];\n            idx.row = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns an array containing the diagonal values of the matrix\n * @returns {Array}\n */\nMatrix.prototype.diag = function diag() {\n    if (!this.isSquare())\n        throw new TypeError('Only square matrices have a diagonal.');\n    var diag = new Array(this.rows);\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        diag[i] = this[i][i];\n    }\n    return diag;\n};\n\n/**\n * Returns the sum of all elements of the matrix\n * @returns {number}\n */\nMatrix.prototype.sum = function sum() {\n    var v = 0;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            v += this[i][j];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the mean of all elements of the matrix\n * @returns {number}\n */\nMatrix.prototype.mean = function mean() {\n    return this.sum() / this.size;\n};\n\n/**\n * Returns the product of all elements of the matrix\n * @returns {number}\n */\nMatrix.prototype.prod = function prod() {\n    var prod = 1;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            prod *= this[i][j];\n        }\n    }\n    return prod;\n};\n\n/**\n * Computes the cumulative sum of the matrix elements (in place, row by row)\n * @returns {Matrix} this\n */\nMatrix.prototype.cumulativeSum = function cumulativeSum() {\n    var sum = 0;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            sum += this[i][j];\n            this[i][j] = sum;\n        }\n    }\n    return this;\n};\n\n/**\n * Computes the dot (scalar) product between the matrix and another\n * @param {Matrix} other vector\n * @returns {number}\n */\nMatrix.prototype.dot = function dot(other) {\n    if (this.size !== other.size)\n        throw new RangeError('vectors do not have the same size');\n    var vector1 = this.to1DArray();\n    var vector2 = other.to1DArray();\n    var dot = 0, l = vector1.length;\n    for (var i = 0; i < l; i++) {\n        dot += vector1[i] * vector2[i];\n    }\n    return dot;\n};\n\n/**\n * Returns the matrix product between this and other\n * @returns {Matrix}\n */\nMatrix.prototype.mmul = function mmul(other) {\n    if (!Matrix.isMatrix(other))\n        throw new TypeError('parameter \"other\" must be a matrix');\n    if (this.columns !== other.rows)\n        console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');\n\n    var m = this.rows, n = this.columns, p = other.columns;\n    var result = new Matrix(m, p);\n\n    var Bcolj = new Array(n);\n    var i, j, k;\n    for (j = 0; j < p; j++) {\n        for (k = 0; k < n; k++)\n            Bcolj[k] = other[k][j];\n\n        for (i = 0; i < m; i++) {\n            var Arowi = this[i];\n\n            var s = 0;\n            for (k = 0; k < n; k++)\n                s += Arowi[k] * Bcolj[k];\n\n            result[i][j] = s;\n        }\n    }\n    return result;\n};\n\n/**\n * Sorts the rows (in place)\n * @param {function} compareFunction - usual Array.prototype.sort comparison function\n * @returns {Matrix} this\n */\nMatrix.prototype.sortRows = function sortRows(compareFunction) {\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        this[i].sort(compareFunction);\n    }\n    return this;\n};\n\n/**\n * Sorts the columns (in place)\n * @param {function} compareFunction - usual Array.prototype.sort comparison function\n * @returns {Matrix} this\n */\nMatrix.prototype.sortColumns = function sortColumns(compareFunction) {\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        this.setColumn(i, this.getColumn(i).sort(compareFunction));\n    }\n    return this;\n};\n\n/**\n * Transposes the matrix and returns a new one containing the result\n * @returns {Matrix}\n */\nMatrix.prototype.transpose = function transpose() {\n    var result = new Matrix(this.columns, this.rows);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[j][i] = this[i][j];\n        }\n    }\n    return result;\n};\n\n/**\n * Returns a subset of the matrix\n * @param {number} startRow - First row index\n * @param {number} endRow - Last row index\n * @param {number} startColumn - First column index\n * @param {number} endColumn - Last column index\n * @returns {Matrix}\n */\nMatrix.prototype.subMatrix = function subMatrix(startRow, endRow, startColumn, endColumn) {\n    if ((startRow > endRow) || (startColumn > endColumn) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns))\n        throw new RangeError('Argument out of range');\n    var newMatrix = new Matrix(endRow - startRow + 1, endColumn - startColumn + 1);\n    for (var i = startRow; i <= endRow; i++) {\n        for (var j = startColumn; j <= endColumn; j++) {\n            newMatrix[i - startRow][j - startColumn] = this[i][j];\n        }\n    }\n    return newMatrix;\n};\n\n/**\n * Returns a subset of the matrix based on an array of row indices\n * @param {Array} indices - Array containing the row indices\n * @param {number} [startColumn = 0] - First column index\n * @param {number} [endColumn = this.columns-1] - Last column index\n * @returns {Matrix}\n */\nMatrix.prototype.subMatrixRow = function subMatrixRow(indices, startColumn, endColumn) {\n    if (typeof startColumn === 'undefined') {\n        startColumn = 0;\n        endColumn = this.columns - 1;\n    } else if (typeof endColumn === 'undefined') {\n        endColumn = this.columns - 1;\n    }\n    if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns))\n        throw new RangeError('Argument out of range.');\n    var l = indices.length, rows = this.rows,\n        X = new Matrix(l, endColumn - startColumn + 1);\n    for (var i = 0; i < l; i++) {\n        for (var j = startColumn; j <= endColumn; j++) {\n            if ((indices[i] < 0) || (indices[i] >= rows))\n                throw new RangeError('Argument out of range.');\n            X[i][j - startColumn] = this[indices[i]][j];\n        }\n    }\n    return X;\n};\n\n/**\n * Returns a subset of the matrix based on an array of column indices\n * @param {Array} indices - Array containing the column indices\n * @param {number} [startRow = 0] - First row index\n * @param {number} [endRow = this.rows-1] - Last row index\n * @returns {Matrix}\n */\nMatrix.prototype.subMatrixColumn = function subMatrixColumn(indices, startRow, endRow) {\n    if (typeof startRow === 'undefined') {\n        startRow = 0;\n        endRow = this.rows - 1;\n    } else if (typeof endRow === 'undefined') {\n        endRow = this.rows - 1;\n    }\n    if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows))\n        throw new RangeError('Argument out of range.');\n    var l = indices.length, columns = this.columns,\n        X = new Matrix(endRow - startRow + 1, l);\n    for (var i = 0; i < l; i++) {\n        for (var j = startRow; j <= endRow; j++) {\n            if ((indices[i] < 0) || (indices[i] >= columns))\n                throw new RangeError('Argument out of range.');\n            X[j - startRow][i] = this[j][indices[i]];\n        }\n    }\n    return X;\n};\n\n/**\n * Returns the trace of the matrix (sum of the diagonal elements)\n * @returns {number}\n */\nMatrix.prototype.trace = function trace() {\n    if (!this.isSquare())\n        throw new TypeError('The matrix is not square');\n    var trace = 0, i = 0, l = this.rows;\n    for (; i < l; i++) {\n        trace += this[i][i];\n    }\n    return trace;\n};\n\n/**\n * Sets each element of the matrix to its absolute value\n * @returns {Matrix} this\n */\nMatrix.prototype.abs = function abs() {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] = Math.abs(this[i][j]);\n        }\n    }\n};\n\nmodule.exports = Matrix;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/curve-fitting/~/ml-matrix/src/matrix.js\n ** module id = 10\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('./matrix');\n\nvar SingularValueDecomposition = require('./dc/svd');\nvar EigenvalueDecomposition = require('./dc/evd');\nvar LuDecomposition = require('./dc/lu');\nvar QrDecomposition = require('./dc/qr');\nvar CholeskyDecomposition = require('./dc/cholesky');\n\nfunction inverse(matrix) {\n    return solve(matrix, Matrix.eye(matrix.rows));\n}\n\nMatrix.prototype.inverse = function () {\n    return inverse(this);\n};\n\nfunction solve(leftHandSide, rightHandSide) {\n    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).solve(rightHandSide);\n}\n\nMatrix.prototype.solve = function (other) {\n    return solve(this, other);\n};\n\nmodule.exports = {\n    SingularValueDecomposition: SingularValueDecomposition,\n    SVD: SingularValueDecomposition,\n    EigenvalueDecomposition: EigenvalueDecomposition,\n    EVD: EigenvalueDecomposition,\n    LuDecomposition: LuDecomposition,\n    LU: LuDecomposition,\n    QrDecomposition: QrDecomposition,\n    QR: QrDecomposition,\n    CholeskyDecomposition: CholeskyDecomposition,\n    CHO: CholeskyDecomposition,\n    inverse: inverse,\n    solve: solve\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/curve-fitting/~/ml-matrix/src/decompositions.js\n ** module id = 11\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\nvar hypotenuse = require('./util').hypotenuse;\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/SingularValueDecomposition.cs\nfunction SingularValueDecomposition(value, options) {\n    if (!(this instanceof SingularValueDecomposition)) {\n        return new SingularValueDecomposition(value, options);\n    }\n    value = Matrix.checkMatrix(value);\n\n    options = options || {};\n\n    var a = value.clone(),\n        m = value.rows,\n        n = value.columns,\n        nu = Math.min(m, n);\n\n    var wantu = true, wantv = true;\n    if (options.computeLeftSingularVectors === false)\n        wantu = false;\n    if (options.computeRightSingularVectors === false)\n        wantv = false;\n    var autoTranspose = options.autoTranspose === true;\n\n    var swapped = false;\n    if (m < n) {\n        if (!autoTranspose) {\n            console.warn('Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose');\n        } else {\n            a = a.transpose();\n            m = a.rows;\n            n = a.columns;\n            swapped = true;\n            var aux = wantu;\n            wantu = wantv;\n            wantv = aux;\n        }\n    }\n\n    var s = new Array(Math.min(m + 1, n)),\n        U = Matrix.zeros(m, nu),\n        V = Matrix.zeros(n, n),\n        e = new Array(n),\n        work = new Array(m);\n\n    var nct = Math.min(m - 1, n);\n    var nrt = Math.max(0, Math.min(n - 2, m));\n\n    var i, j, k, p, t, ks, f, cs, sn, max, kase,\n        scale, sp, spm1, epm1, sk, ek, b, c, shift, g;\n\n    for (k = 0, max = Math.max(nct, nrt); k < max; k++) {\n        if (k < nct) {\n            s[k] = 0;\n            for (i = k; i < m; i++) {\n                s[k] = hypotenuse(s[k], a[i][k]);\n            }\n            if (s[k] !== 0) {\n                if (a[k][k] < 0) {\n                    s[k] = -s[k];\n                }\n                for (i = k; i < m; i++) {\n                    a[i][k] /= s[k];\n                }\n                a[k][k] += 1;\n            }\n            s[k] = -s[k];\n        }\n\n        for (j = k + 1; j < n; j++) {\n            if ((k < nct) && (s[k] !== 0)) {\n                t = 0;\n                for (i = k; i < m; i++) {\n                    t += a[i][k] * a[i][j];\n                }\n                t = -t / a[k][k];\n                for (i = k; i < m; i++) {\n                    a[i][j] += t * a[i][k];\n                }\n            }\n            e[j] = a[k][j];\n        }\n\n        if (wantu && (k < nct)) {\n            for (i = k; i < m; i++) {\n                U[i][k] = a[i][k];\n            }\n        }\n\n        if (k < nrt) {\n            e[k] = 0;\n            for (i = k + 1; i < n; i++) {\n                e[k] = hypotenuse(e[k], e[i]);\n            }\n            if (e[k] !== 0) {\n                if (e[k + 1] < 0)\n                    e[k] = -e[k];\n                for (i = k + 1; i < n; i++) {\n                    e[i] /= e[k];\n                }\n                e[k + 1] += 1;\n            }\n            e[k] = -e[k];\n            if ((k + 1 < m) && (e[k] !== 0)) {\n                for (i = k + 1; i < m; i++) {\n                    work[i] = 0;\n                }\n                for (j = k + 1; j < n; j++) {\n                    for (i = k + 1; i < m; i++) {\n                        work[i] += e[j] * a[i][j];\n                    }\n                }\n                for (j = k + 1; j < n; j++) {\n                    t = -e[j] / e[k + 1];\n                    for (i = k + 1; i < m; i++) {\n                        a[i][j] += t * work[i];\n                    }\n                }\n            }\n            if (wantv) {\n                for (i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n    }\n\n    p = Math.min(n, m + 1);\n    if (nct < n) {\n        s[nct] = a[nct][nct];\n    }\n    if (m < p) {\n        s[p - 1] = 0;\n    }\n    if (nrt + 1 < p) {\n        e[nrt] = a[nrt][p - 1];\n    }\n    e[p - 1] = 0;\n\n    if (wantu) {\n        for (j = nct; j < nu; j++) {\n            for (i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (k = nct - 1; k >= 0; k--) {\n            if (s[k] !== 0) {\n                for (j = k + 1; j < nu; j++) {\n                    t = 0;\n                    for (i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n    }\n\n    if (wantv) {\n        for (k = n - 1; k >= 0; k--) {\n            if ((k < nrt) && (e[k] !== 0)) {\n                for (j = k + 1; j < n; j++) {\n                    t = 0;\n                    for (i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n    }\n\n    var pp = p - 1,\n        iter = 0,\n        eps = Math.pow(2, -52);\n    while (p > 0) {\n        for (k = p - 2; k >= -1; k--) {\n            if (k === -1) {\n                break;\n            }\n            if (Math.abs(e[k]) <= eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {\n                e[k] = 0;\n                break;\n            }\n        }\n        if (k === p - 2) {\n            kase = 4;\n        } else {\n            for (ks = p - 1; ks >= k; ks--) {\n                if (ks === k) {\n                    break;\n                }\n                t = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);\n                if (Math.abs(s[ks]) <= eps * t) {\n                    s[ks] = 0;\n                    break;\n                }\n            }\n            if (ks === k) {\n                kase = 3;\n            } else if (ks === p - 1) {\n                kase = 1;\n            } else {\n                kase = 2;\n                k = ks;\n            }\n        }\n\n        k++;\n\n        switch (kase) {\n            case 1: {\n                f = e[p - 2];\n                e[p - 2] = 0;\n                for (j = p - 2; j >= k; j--) {\n                    t = hypotenuse(s[j], f);\n                    cs = s[j] / t;\n                    sn = f / t;\n                    s[j] = t;\n                    if (j !== k) {\n                        f = -sn * e[j - 1];\n                        e[j - 1] = cs * e[j - 1];\n                    }\n                    if (wantv) {\n                        for (i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n            }\n            case 2 : {\n                f = e[k - 1];\n                e[k - 1] = 0;\n                for (j = k; j < p; j++) {\n                    t = hypotenuse(s[j], f);\n                    cs = s[j] / t;\n                    sn = f / t;\n                    s[j] = t;\n                    f = -sn * e[j];\n                    e[j] = cs * e[j];\n                    if (wantu) {\n                        for (i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n            }\n            case 3 : {\n                scale = Math.max(Math.max(Math.max(Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2])), Math.abs(e[p - 2])), Math.abs(s[k])), Math.abs(e[k]));\n                sp = s[p - 1] / scale;\n                spm1 = s[p - 2] / scale;\n                epm1 = e[p - 2] / scale;\n                sk = s[k] / scale;\n                ek = e[k] / scale;\n                b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;\n                c = (sp * epm1) * (sp * epm1);\n                shift = 0;\n                if ((b !== 0) || (c !== 0)) {\n                    shift = Math.sqrt(b * b + c);\n                    if (b < 0) {\n                        shift = -shift;\n                    }\n                    shift = c / (b + shift);\n                }\n                f = (sk + sp) * (sk - sp) + shift;\n                g = sk * ek;\n                for (j = k; j < p - 1; j++) {\n                    t = hypotenuse(f, g);\n                    cs = f / t;\n                    sn = g / t;\n                    if (j !== k) {\n                        e[j - 1] = t;\n                    }\n                    f = cs * s[j] + sn * e[j];\n                    e[j] = cs * e[j] - sn * s[j];\n                    g = sn * s[j + 1];\n                    s[j + 1] = cs * s[j + 1];\n                    if (wantv) {\n                        for (i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                    }\n                    t = hypotenuse(f, g);\n                    cs = f / t;\n                    sn = g / t;\n                    s[j] = t;\n                    f = cs * e[j] + sn * s[j + 1];\n                    s[j + 1] = -sn * e[j] + cs * s[j + 1];\n                    g = sn * e[j + 1];\n                    e[j + 1] = cs * e[j + 1];\n                    if (wantu && (j < m - 1)) {\n                        for (i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][j + 1];\n                            U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                e[p - 2] = f;\n                iter = iter + 1;\n                break;\n            }\n            case 4: {\n                if (s[k] <= 0) {\n                    s[k] = (s[k] < 0 ? -s[k] : 0);\n                    if (wantv) {\n                        for (i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                }\n                while (k < pp) {\n                    if (s[k] >= s[k + 1]) {\n                        break;\n                    }\n                    t = s[k];\n                    s[k] = s[k + 1];\n                    s[k + 1] = t;\n                    if (wantv && (k < n - 1)) {\n                        for (i = 0; i < n; i++) {\n                            t = V[i][k + 1];\n                            V[i][k + 1] = V[i][k];\n                            V[i][k] = t;\n                        }\n                    }\n                    if (wantu && (k < m - 1)) {\n                        for (i = 0; i < m; i++) {\n                            t = U[i][k + 1];\n                            U[i][k + 1] = U[i][k];\n                            U[i][k] = t;\n                        }\n                    }\n                    k++;\n                }\n                iter = 0;\n                p--;\n                break;\n            }\n        }\n    }\n\n    if (swapped) {\n        var tmp = V;\n        V = U;\n        U = tmp;\n    }\n\n    this.m = m;\n    this.n = n;\n    this.s = s;\n    this.U = U;\n    this.V = V;\n}\n\nSingularValueDecomposition.prototype = {\n    get condition() {\n        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];\n    },\n    get norm2() {\n        return this.s[0];\n    },\n    get rank() {\n        var eps = Math.pow(2, -52),\n            tol = Math.max(this.m, this.n) * this.s[0] * eps,\n            r = 0,\n            s = this.s;\n        for (var i = 0, ii = s.length; i < ii; i++) {\n            if (s[i] > tol) {\n                r++;\n            }\n        }\n        return r;\n    },\n    get diagonal() {\n        return this.s;\n    },\n    // https://github.com/accord-net/framework/blob/development/Sources/Accord.Math/Decompositions/SingularValueDecomposition.cs\n    get threshold() {\n        return (Math.pow(2, -52) / 2) * Math.max(this.m, this.n) * this.s[0];\n    },\n    get leftSingularVectors() {\n        return this.U;\n    },\n    get rightSingularVectors() {\n        return this.V;\n    },\n    get diagonalMatrix() {\n        return Matrix.diag(this.s);\n    },\n    solve: function (value) {\n\n        var Y = value,\n            e = this.threshold,\n            scols = this.s.length,\n            Ls = Matrix.zeros(scols, scols),\n            i;\n\n        for (i = 0; i < scols; i++) {\n            if (Math.abs(this.s[i]) <= e) {\n                Ls[i][i] = 0;\n            } else {\n                Ls[i][i] = 1 / this.s[i];\n            }\n        }\n\n\n        var VL = this.V.mmul(Ls),\n            vrows = this.V.rows,\n            urows = this.U.rows,\n            VLU = Matrix.zeros(vrows, urows),\n            j, k, sum;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < urows; j++) {\n                sum = 0;\n                for (k = 0; k < scols; k++) {\n                    sum += VL[i][k] * this.U[j][k];\n                }\n                VLU[i][j] = sum;\n            }\n        }\n\n        return VLU.mmul(Y);\n    },\n    solveForDiagonal: function (value) {\n        return this.solve(Matrix.diag(value));\n    },\n    inverse: function () {\n        var e = this.threshold,\n            vrows = this.V.rows,\n            vcols = this.V.columns,\n            X = new Matrix(vrows, this.s.length),\n            i, j;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < vcols; j++) {\n                if (Math.abs(this.s[j]) > e) {\n                    X[i][j] = this.V[i][j] / this.s[j];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n\n        var urows = this.U.rows,\n            ucols = this.U.columns,\n            Y = new Matrix(vrows, urows),\n            k, sum;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < urows; j++) {\n                sum = 0;\n                for (k = 0; k < ucols; k++) {\n                    sum += X[i][k] * this.U[j][k];\n                }\n                Y[i][j] = sum;\n            }\n        }\n\n        return Y;\n    }\n};\n\nmodule.exports = SingularValueDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/curve-fitting/~/ml-matrix/src/dc/svd.js\n ** module id = 12\n ** module chunks = 0\n **/","'use strict';\n\nexports.hypotenuse = function hypotenuse(a, b) {\n    var r;\n    if (Math.abs(a) > Math.abs(b)) {\n        r = b / a;\n        return Math.abs(a) * Math.sqrt(1 + r * r);\n    }\n    if (b !== 0) {\n        r = a / b;\n        return Math.abs(b) * Math.sqrt(1 + r * r);\n    }\n    return 0;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/curve-fitting/~/ml-matrix/src/dc/util.js\n ** module id = 13\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\nvar hypotenuse = require('./util').hypotenuse;\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/EigenvalueDecomposition.cs\nfunction EigenvalueDecomposition(matrix) {\n    if (!(this instanceof EigenvalueDecomposition)) {\n        return new EigenvalueDecomposition(matrix);\n    }\n    matrix = Matrix.checkMatrix(matrix);\n    if (!matrix.isSquare()) {\n        throw new Error('Matrix is not a square matrix');\n    }\n\n    var n = matrix.columns,\n        V = Matrix.zeros(n, n),\n        d = new Array(n),\n        e = new Array(n),\n        value = matrix,\n        i, j;\n\n    if (matrix.isSymmetric()) {\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                V[i][j] = value[i][j];\n            }\n        }\n        tred2(n, e, d, V);\n        tql2(n, e, d, V);\n    }\n    else {\n        var H = Matrix.zeros(n, n),\n            ort = new Array(n);\n        for (j = 0; j < n; j++) {\n            for (i = 0; i < n; i++) {\n                H[i][j] = value[i][j];\n            }\n        }\n        orthes(n, H, ort, V);\n        hqr2(n, e, d, V, H);\n    }\n\n    this.n = n;\n    this.e = e;\n    this.d = d;\n    this.V = V;\n}\n\nEigenvalueDecomposition.prototype = {\n    get realEigenvalues() {\n        return this.d;\n    },\n    get imaginaryEigenvalues() {\n        return this.e;\n    },\n    get eigenvectorMatrix() {\n        return this.V;\n    },\n    get diagonalMatrix() {\n        var n = this.n,\n            e = this.e,\n            d = this.d,\n            X = new Matrix(n, n),\n            i, j;\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                X[i][j] = 0;\n            }\n            X[i][i] = d[i];\n            if (e[i] > 0) {\n                X[i][i + 1] = e[i];\n            }\n            else if (e[i] < 0) {\n                X[i][i - 1] = e[i];\n            }\n        }\n        return X;\n    }\n};\n\nfunction tred2(n, e, d, V) {\n\n    var f, g, h, i, j, k,\n        hh, scale;\n\n    for (j = 0; j < n; j++) {\n        d[j] = V[n - 1][j];\n    }\n\n    for (i = n - 1; i > 0; i--) {\n        scale = 0;\n        h = 0;\n        for (k = 0; k < i; k++) {\n            scale = scale + Math.abs(d[k]);\n        }\n\n        if (scale === 0) {\n            e[i] = d[i - 1];\n            for (j = 0; j < i; j++) {\n                d[j] = V[i - 1][j];\n                V[i][j] = 0;\n                V[j][i] = 0;\n            }\n        } else {\n            for (k = 0; k < i; k++) {\n                d[k] /= scale;\n                h += d[k] * d[k];\n            }\n\n            f = d[i - 1];\n            g = Math.sqrt(h);\n            if (f > 0) {\n                g = -g;\n            }\n\n            e[i] = scale * g;\n            h = h - f * g;\n            d[i - 1] = f - g;\n            for (j = 0; j < i; j++) {\n                e[j] = 0;\n            }\n\n            for (j = 0; j < i; j++) {\n                f = d[j];\n                V[j][i] = f;\n                g = e[j] + V[j][j] * f;\n                for (k = j + 1; k <= i - 1; k++) {\n                    g += V[k][j] * d[k];\n                    e[k] += V[k][j] * f;\n                }\n                e[j] = g;\n            }\n\n            f = 0;\n            for (j = 0; j < i; j++) {\n                e[j] /= h;\n                f += e[j] * d[j];\n            }\n\n            hh = f / (h + h);\n            for (j = 0; j < i; j++) {\n                e[j] -= hh * d[j];\n            }\n\n            for (j = 0; j < i; j++) {\n                f = d[j];\n                g = e[j];\n                for (k = j; k <= i - 1; k++) {\n                    V[k][j] -= (f * e[k] + g * d[k]);\n                }\n                d[j] = V[i - 1][j];\n                V[i][j] = 0;\n            }\n        }\n        d[i] = h;\n    }\n\n    for (i = 0; i < n - 1; i++) {\n        V[n - 1][i] = V[i][i];\n        V[i][i] = 1;\n        h = d[i + 1];\n        if (h !== 0) {\n            for (k = 0; k <= i; k++) {\n                d[k] = V[k][i + 1] / h;\n            }\n\n            for (j = 0; j <= i; j++) {\n                g = 0;\n                for (k = 0; k <= i; k++) {\n                    g += V[k][i + 1] * V[k][j];\n                }\n                for (k = 0; k <= i; k++) {\n                    V[k][j] -= g * d[k];\n                }\n            }\n        }\n\n        for (k = 0; k <= i; k++) {\n            V[k][i + 1] = 0;\n        }\n    }\n\n    for (j = 0; j < n; j++) {\n        d[j] = V[n - 1][j];\n        V[n - 1][j] = 0;\n    }\n\n    V[n - 1][n - 1] = 1;\n    e[0] = 0;\n}\n\nfunction tql2(n, e, d, V) {\n\n    var g, h, i, j, k, l, m, p, r,\n        dl1, c, c2, c3, el1, s, s2,\n        iter;\n\n    for (i = 1; i < n; i++) {\n        e[i - 1] = e[i];\n    }\n\n    e[n - 1] = 0;\n\n    var f = 0,\n        tst1 = 0,\n        eps = Math.pow(2, -52);\n\n    for (l = 0; l < n; l++) {\n        tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));\n        m = l;\n        while (m < n) {\n            if (Math.abs(e[m]) <= eps * tst1) {\n                break;\n            }\n            m++;\n        }\n\n        if (m > l) {\n            iter = 0;\n            do {\n                iter = iter + 1;\n\n                g = d[l];\n                p = (d[l + 1] - g) / (2 * e[l]);\n                r = hypotenuse(p, 1);\n                if (p < 0) {\n                    r = -r;\n                }\n\n                d[l] = e[l] / (p + r);\n                d[l + 1] = e[l] * (p + r);\n                dl1 = d[l + 1];\n                h = g - d[l];\n                for (i = l + 2; i < n; i++) {\n                    d[i] -= h;\n                }\n\n                f = f + h;\n\n                p = d[m];\n                c = 1;\n                c2 = c;\n                c3 = c;\n                el1 = e[l + 1];\n                s = 0;\n                s2 = 0;\n                for (i = m - 1; i >= l; i--) {\n                    c3 = c2;\n                    c2 = c;\n                    s2 = s;\n                    g = c * e[i];\n                    h = c * p;\n                    r = hypotenuse(p, e[i]);\n                    e[i + 1] = s * r;\n                    s = e[i] / r;\n                    c = p / r;\n                    p = c * d[i] - s * g;\n                    d[i + 1] = h + s * (c * g + s * d[i]);\n\n                    for (k = 0; k < n; k++) {\n                        h = V[k][i + 1];\n                        V[k][i + 1] = s * V[k][i] + c * h;\n                        V[k][i] = c * V[k][i] - s * h;\n                    }\n                }\n\n                p = -s * s2 * c3 * el1 * e[l] / dl1;\n                e[l] = s * p;\n                d[l] = c * p;\n\n            }\n            while (Math.abs(e[l]) > eps * tst1);\n        }\n        d[l] = d[l] + f;\n        e[l] = 0;\n    }\n\n    for (i = 0; i < n - 1; i++) {\n        k = i;\n        p = d[i];\n        for (j = i + 1; j < n; j++) {\n            if (d[j] < p) {\n                k = j;\n                p = d[j];\n            }\n        }\n\n        if (k !== i) {\n            d[k] = d[i];\n            d[i] = p;\n            for (j = 0; j < n; j++) {\n                p = V[j][i];\n                V[j][i] = V[j][k];\n                V[j][k] = p;\n            }\n        }\n    }\n}\n\nfunction orthes(n, H, ort, V) {\n\n    var low = 0,\n        high = n - 1,\n        f, g, h, i, j, m,\n        scale;\n\n    for (m = low + 1; m <= high - 1; m++) {\n        scale = 0;\n        for (i = m; i <= high; i++) {\n            scale = scale + Math.abs(H[i][m - 1]);\n        }\n\n        if (scale !== 0) {\n            h = 0;\n            for (i = high; i >= m; i--) {\n                ort[i] = H[i][m - 1] / scale;\n                h += ort[i] * ort[i];\n            }\n\n            g = Math.sqrt(h);\n            if (ort[m] > 0) {\n                g = -g;\n            }\n\n            h = h - ort[m] * g;\n            ort[m] = ort[m] - g;\n\n            for (j = m; j < n; j++) {\n                f = 0;\n                for (i = high; i >= m; i--) {\n                    f += ort[i] * H[i][j];\n                }\n\n                f = f / h;\n                for (i = m; i <= high; i++) {\n                    H[i][j] -= f * ort[i];\n                }\n            }\n\n            for (i = 0; i <= high; i++) {\n                f = 0;\n                for (j = high; j >= m; j--) {\n                    f += ort[j] * H[i][j];\n                }\n\n                f = f / h;\n                for (j = m; j <= high; j++) {\n                    H[i][j] -= f * ort[j];\n                }\n            }\n\n            ort[m] = scale * ort[m];\n            H[m][m - 1] = scale * g;\n        }\n    }\n\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            V[i][j] = (i === j ? 1 : 0);\n        }\n    }\n\n    for (m = high - 1; m >= low + 1; m--) {\n        if (H[m][m - 1] !== 0) {\n            for (i = m + 1; i <= high; i++) {\n                ort[i] = H[i][m - 1];\n            }\n\n            for (j = m; j <= high; j++) {\n                g = 0;\n                for (i = m; i <= high; i++) {\n                    g += ort[i] * V[i][j];\n                }\n\n                g = (g / ort[m]) / H[m][m - 1];\n                for (i = m; i <= high; i++) {\n                    V[i][j] += g * ort[i];\n                }\n            }\n        }\n    }\n}\n\nfunction hqr2(nn, e, d, V, H) {\n    var n = nn - 1,\n        low = 0,\n        high = nn - 1,\n        eps = Math.pow(2, -52),\n        exshift = 0,\n        norm = 0,\n        p = 0,\n        q = 0,\n        r = 0,\n        s = 0,\n        z = 0,\n        iter = 0,\n        i, j, k, l, m, t, w, x, y,\n        ra, sa, vr, vi,\n        notlast, cdivres;\n\n    for (i = 0; i < nn; i++) {\n        if (i < low || i > high) {\n            d[i] = H[i][i];\n            e[i] = 0;\n        }\n\n        for (j = Math.max(i - 1, 0); j < nn; j++) {\n            norm = norm + Math.abs(H[i][j]);\n        }\n    }\n\n    while (n >= low) {\n        l = n;\n        while (l > low) {\n            s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);\n            if (s === 0) {\n                s = norm;\n            }\n            if (Math.abs(H[l][l - 1]) < eps * s) {\n                break;\n            }\n            l--;\n        }\n\n        if (l === n) {\n            H[n][n] = H[n][n] + exshift;\n            d[n] = H[n][n];\n            e[n] = 0;\n            n--;\n            iter = 0;\n        } else if (l === n - 1) {\n            w = H[n][n - 1] * H[n - 1][n];\n            p = (H[n - 1][n - 1] - H[n][n]) / 2;\n            q = p * p + w;\n            z = Math.sqrt(Math.abs(q));\n            H[n][n] = H[n][n] + exshift;\n            H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;\n            x = H[n][n];\n\n            if (q >= 0) {\n                z = (p >= 0) ? (p + z) : (p - z);\n                d[n - 1] = x + z;\n                d[n] = d[n - 1];\n                if (z !== 0) {\n                    d[n] = x - w / z;\n                }\n                e[n - 1] = 0;\n                e[n] = 0;\n                x = H[n][n - 1];\n                s = Math.abs(x) + Math.abs(z);\n                p = x / s;\n                q = z / s;\n                r = Math.sqrt(p * p + q * q);\n                p = p / r;\n                q = q / r;\n\n                for (j = n - 1; j < nn; j++) {\n                    z = H[n - 1][j];\n                    H[n - 1][j] = q * z + p * H[n][j];\n                    H[n][j] = q * H[n][j] - p * z;\n                }\n\n                for (i = 0; i <= n; i++) {\n                    z = H[i][n - 1];\n                    H[i][n - 1] = q * z + p * H[i][n];\n                    H[i][n] = q * H[i][n] - p * z;\n                }\n\n                for (i = low; i <= high; i++) {\n                    z = V[i][n - 1];\n                    V[i][n - 1] = q * z + p * V[i][n];\n                    V[i][n] = q * V[i][n] - p * z;\n                }\n            } else {\n                d[n - 1] = x + p;\n                d[n] = x + p;\n                e[n - 1] = z;\n                e[n] = -z;\n            }\n\n            n = n - 2;\n            iter = 0;\n        } else {\n            x = H[n][n];\n            y = 0;\n            w = 0;\n            if (l < n) {\n                y = H[n - 1][n - 1];\n                w = H[n][n - 1] * H[n - 1][n];\n            }\n\n            if (iter === 10) {\n                exshift += x;\n                for (i = low; i <= n; i++) {\n                    H[i][i] -= x;\n                }\n                s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);\n                x = y = 0.75 * s;\n                w = -0.4375 * s * s;\n            }\n\n            if (iter === 30) {\n                s = (y - x) / 2;\n                s = s * s + w;\n                if (s > 0) {\n                    s = Math.sqrt(s);\n                    if (y < x) {\n                        s = -s;\n                    }\n                    s = x - w / ((y - x) / 2 + s);\n                    for (i = low; i <= n; i++) {\n                        H[i][i] -= s;\n                    }\n                    exshift += s;\n                    x = y = w = 0.964;\n                }\n            }\n\n            iter = iter + 1;\n\n            m = n - 2;\n            while (m >= l) {\n                z = H[m][m];\n                r = x - z;\n                s = y - z;\n                p = (r * s - w) / H[m + 1][m] + H[m][m + 1];\n                q = H[m + 1][m + 1] - z - r - s;\n                r = H[m + 2][m + 1];\n                s = Math.abs(p) + Math.abs(q) + Math.abs(r);\n                p = p / s;\n                q = q / s;\n                r = r / s;\n                if (m === l) {\n                    break;\n                }\n                if (Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) < eps * (Math.abs(p) * (Math.abs(H[m - 1][m - 1]) + Math.abs(z) + Math.abs(H[m + 1][m + 1])))) {\n                    break;\n                }\n                m--;\n            }\n\n            for (i = m + 2; i <= n; i++) {\n                H[i][i - 2] = 0;\n                if (i > m + 2) {\n                    H[i][i - 3] = 0;\n                }\n            }\n\n            for (k = m; k <= n - 1; k++) {\n                notlast = (k !== n - 1);\n                if (k !== m) {\n                    p = H[k][k - 1];\n                    q = H[k + 1][k - 1];\n                    r = (notlast ? H[k + 2][k - 1] : 0);\n                    x = Math.abs(p) + Math.abs(q) + Math.abs(r);\n                    if (x !== 0) {\n                        p = p / x;\n                        q = q / x;\n                        r = r / x;\n                    }\n                }\n\n                if (x === 0) {\n                    break;\n                }\n\n                s = Math.sqrt(p * p + q * q + r * r);\n                if (p < 0) {\n                    s = -s;\n                }\n\n                if (s !== 0) {\n                    if (k !== m) {\n                        H[k][k - 1] = -s * x;\n                    } else if (l !== m) {\n                        H[k][k - 1] = -H[k][k - 1];\n                    }\n\n                    p = p + s;\n                    x = p / s;\n                    y = q / s;\n                    z = r / s;\n                    q = q / p;\n                    r = r / p;\n\n                    for (j = k; j < nn; j++) {\n                        p = H[k][j] + q * H[k + 1][j];\n                        if (notlast) {\n                            p = p + r * H[k + 2][j];\n                            H[k + 2][j] = H[k + 2][j] - p * z;\n                        }\n\n                        H[k][j] = H[k][j] - p * x;\n                        H[k + 1][j] = H[k + 1][j] - p * y;\n                    }\n\n                    for (i = 0; i <= Math.min(n, k + 3); i++) {\n                        p = x * H[i][k] + y * H[i][k + 1];\n                        if (notlast) {\n                            p = p + z * H[i][k + 2];\n                            H[i][k + 2] = H[i][k + 2] - p * r;\n                        }\n\n                        H[i][k] = H[i][k] - p;\n                        H[i][k + 1] = H[i][k + 1] - p * q;\n                    }\n\n                    for (i = low; i <= high; i++) {\n                        p = x * V[i][k] + y * V[i][k + 1];\n                        if (notlast) {\n                            p = p + z * V[i][k + 2];\n                            V[i][k + 2] = V[i][k + 2] - p * r;\n                        }\n\n                        V[i][k] = V[i][k] - p;\n                        V[i][k + 1] = V[i][k + 1] - p * q;\n                    }\n                }\n            }\n        }\n    }\n\n    if (norm === 0) {\n        return;\n    }\n\n    for (n = nn - 1; n >= 0; n--) {\n        p = d[n];\n        q = e[n];\n\n        if (q === 0) {\n            l = n;\n            H[n][n] = 1;\n            for (i = n - 1; i >= 0; i--) {\n                w = H[i][i] - p;\n                r = 0;\n                for (j = l; j <= n; j++) {\n                    r = r + H[i][j] * H[j][n];\n                }\n\n                if (e[i] < 0) {\n                    z = w;\n                    s = r;\n                } else {\n                    l = i;\n                    if (e[i] === 0) {\n                        H[i][n] = (w !== 0) ? (-r / w) : (-r / (eps * norm));\n                    } else {\n                        x = H[i][i + 1];\n                        y = H[i + 1][i];\n                        q = (d[i] - p) * (d[i] - p) + e[i] * e[i];\n                        t = (x * s - z * r) / q;\n                        H[i][n] = t;\n                        H[i + 1][n] = (Math.abs(x) > Math.abs(z)) ? ((-r - w * t) / x) : ((-s - y * t) / z);\n                    }\n\n                    t = Math.abs(H[i][n]);\n                    if ((eps * t) * t > 1) {\n                        for (j = i; j <= n; j++) {\n                            H[j][n] = H[j][n] / t;\n                        }\n                    }\n                }\n            }\n        } else if (q < 0) {\n            l = n - 1;\n\n            if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {\n                H[n - 1][n - 1] = q / H[n][n - 1];\n                H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];\n            } else {\n                cdivres = cdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);\n                H[n - 1][n - 1] = cdivres[0];\n                H[n - 1][n] = cdivres[1];\n            }\n\n            H[n][n - 1] = 0;\n            H[n][n] = 1;\n            for (i = n - 2; i >= 0; i--) {\n                ra = 0;\n                sa = 0;\n                for (j = l; j <= n; j++) {\n                    ra = ra + H[i][j] * H[j][n - 1];\n                    sa = sa + H[i][j] * H[j][n];\n                }\n\n                w = H[i][i] - p;\n\n                if (e[i] < 0) {\n                    z = w;\n                    r = ra;\n                    s = sa;\n                } else {\n                    l = i;\n                    if (e[i] === 0) {\n                        cdivres = cdiv(-ra, -sa, w, q);\n                        H[i][n - 1] = cdivres[0];\n                        H[i][n] = cdivres[1];\n                    } else {\n                        x = H[i][i + 1];\n                        y = H[i + 1][i];\n                        vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;\n                        vi = (d[i] - p) * 2 * q;\n                        if (vr === 0 && vi === 0) {\n                            vr = eps * norm * (Math.abs(w) + Math.abs(q) + Math.abs(x) + Math.abs(y) + Math.abs(z));\n                        }\n                        cdivres = cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);\n                        H[i][n - 1] = cdivres[0];\n                        H[i][n] = cdivres[1];\n                        if (Math.abs(x) > (Math.abs(z) + Math.abs(q))) {\n                            H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;\n                            H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;\n                        } else {\n                            cdivres = cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);\n                            H[i + 1][n - 1] = cdivres[0];\n                            H[i + 1][n] = cdivres[1];\n                        }\n                    }\n\n                    t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));\n                    if ((eps * t) * t > 1) {\n                        for (j = i; j <= n; j++) {\n                            H[j][n - 1] = H[j][n - 1] / t;\n                            H[j][n] = H[j][n] / t;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < nn; i++) {\n        if (i < low || i > high) {\n            for (j = i; j < nn; j++) {\n                V[i][j] = H[i][j];\n            }\n        }\n    }\n\n    for (j = nn - 1; j >= low; j--) {\n        for (i = low; i <= high; i++) {\n            z = 0;\n            for (k = low; k <= Math.min(j, high); k++) {\n                z = z + V[i][k] * H[k][j];\n            }\n            V[i][j] = z;\n        }\n    }\n}\n\nfunction cdiv(xr, xi, yr, yi) {\n    var r, d;\n    if (Math.abs(yr) > Math.abs(yi)) {\n        r = yi / yr;\n        d = yr + r * yi;\n        return [(xr + r * xi) / d, (xi - r * xr) / d];\n    }\n    else {\n        r = yr / yi;\n        d = yi + r * yr;\n        return [(r * xr + xi) / d, (r * xi - xr) / d];\n    }\n}\n\nmodule.exports = EigenvalueDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/curve-fitting/~/ml-matrix/src/dc/evd.js\n ** module id = 14\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/LuDecomposition.cs\nfunction LuDecomposition(matrix) {\n    if (!(this instanceof LuDecomposition)) {\n        return new LuDecomposition(matrix);\n    }\n    matrix = Matrix.checkMatrix(matrix);\n\n    var lu = matrix.clone(),\n        rows = lu.rows,\n        columns = lu.columns,\n        pivotVector = new Array(rows),\n        pivotSign = 1,\n        i, j, k, p, s, t, v,\n        LUrowi, LUcolj, kmax;\n\n    for (i = 0; i < rows; i++) {\n        pivotVector[i] = i;\n    }\n\n    LUcolj = new Array(rows);\n\n    for (j = 0; j < columns; j++) {\n\n        for (i = 0; i < rows; i++) {\n            LUcolj[i] = lu[i][j];\n        }\n\n        for (i = 0; i < rows; i++) {\n            LUrowi = lu[i];\n            kmax = Math.min(i, j);\n            s = 0;\n            for (k = 0; k < kmax; k++) {\n                s += LUrowi[k] * LUcolj[k];\n            }\n            LUrowi[j] = LUcolj[i] -= s;\n        }\n\n        p = j;\n        for (i = j + 1; i < rows; i++) {\n            if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {\n                p = i;\n            }\n        }\n\n        if (p !== j) {\n            for (k = 0; k < columns; k++) {\n                t = lu[p][k];\n                lu[p][k] = lu[j][k];\n                lu[j][k] = t;\n            }\n\n            v = pivotVector[p];\n            pivotVector[p] = pivotVector[j];\n            pivotVector[j] = v;\n\n            pivotSign = -pivotSign;\n        }\n\n        if (j < rows && lu[j][j] !== 0) {\n            for (i = j + 1; i < rows; i++) {\n                lu[i][j] /= lu[j][j];\n            }\n        }\n    }\n\n    this.LU = lu;\n    this.pivotVector = pivotVector;\n    this.pivotSign = pivotSign;\n}\n\nLuDecomposition.prototype = {\n    isSingular: function () {\n        var data = this.LU,\n            col = data.columns;\n        for (var j = 0; j < col; j++) {\n            if (data[j][j] === 0) {\n                return true;\n            }\n        }\n        return false;\n    },\n    get determinant() {\n        var data = this.LU;\n        if (!data.isSquare())\n            throw new Error('Matrix must be square');\n        var determinant = this.pivotSign, col = data.columns;\n        for (var j = 0; j < col; j++)\n            determinant *= data[j][j];\n        return determinant;\n    },\n    get lowerTriangularFactor() {\n        var data = this.LU,\n            rows = data.rows,\n            columns = data.columns,\n            X = new Matrix(rows, columns);\n        for (var i = 0; i < rows; i++) {\n            for (var j = 0; j < columns; j++) {\n                if (i > j) {\n                    X[i][j] = data[i][j];\n                } else if (i === j) {\n                    X[i][j] = 1;\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get upperTriangularFactor() {\n        var data = this.LU,\n            rows = data.rows,\n            columns = data.columns,\n            X = new Matrix(rows, columns);\n        for (var i = 0; i < rows; i++) {\n            for (var j = 0; j < columns; j++) {\n                if (i <= j) {\n                    X[i][j] = data[i][j];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get pivotPermutationVector() {\n        return this.pivotVector.slice();\n    },\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var lu = this.LU,\n            rows = lu.rows;\n\n        if (rows !== value.rows)\n            throw new Error('Invalid matrix dimensions');\n        if (this.isSingular())\n            throw new Error('LU matrix is singular');\n\n        var count = value.columns,\n            X = value.subMatrixRow(this.pivotVector, 0, count - 1),\n            columns = lu.columns,\n            i, j, k;\n\n        for (k = 0; k < columns; k++) {\n            for (i = k + 1; i < columns; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * lu[i][k];\n                }\n            }\n        }\n        for (k = columns - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                X[k][j] /= lu[k][k];\n            }\n            for (i = 0; i < k; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * lu[i][k];\n                }\n            }\n        }\n        return X;\n    }\n};\n\nmodule.exports = LuDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/curve-fitting/~/ml-matrix/src/dc/lu.js\n ** module id = 15\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\nvar hypotenuse = require('./util').hypotenuse;\n\n//https://github.com/lutzroeder/Mapack/blob/master/Source/QrDecomposition.cs\nfunction QrDecomposition(value) {\n    if (!(this instanceof QrDecomposition)) {\n        return new QrDecomposition(value);\n    }\n    value = Matrix.checkMatrix(value);\n\n    var qr = value.clone(),\n        m = value.rows,\n        n = value.columns,\n        rdiag = new Array(n),\n        i, j, k, s;\n\n    for (k = 0; k < n; k++) {\n        var nrm = 0;\n        for (i = k; i < m; i++) {\n            nrm = hypotenuse(nrm, qr[i][k]);\n        }\n        if (nrm !== 0) {\n            if (qr[k][k] < 0) {\n                nrm = -nrm;\n            }\n            for (i = k; i < m; i++) {\n                qr[i][k] /= nrm;\n            }\n            qr[k][k] += 1;\n            for (j = k + 1; j < n; j++) {\n                s = 0;\n                for (i = k; i < m; i++) {\n                    s += qr[i][k] * qr[i][j];\n                }\n                s = -s / qr[k][k];\n                for (i = k; i < m; i++) {\n                    qr[i][j] += s * qr[i][k];\n                }\n            }\n        }\n        rdiag[k] = -nrm;\n    }\n\n    this.QR = qr;\n    this.Rdiag = rdiag;\n}\n\nQrDecomposition.prototype = {\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var qr = this.QR,\n            m = qr.rows;\n\n        if (value.rows !== m)\n            throw new Error('Matrix row dimensions must agree');\n        if (!this.isFullRank())\n            throw new Error('Matrix is rank deficient');\n\n        var count = value.columns,\n            X = value.clone(),\n            n = qr.columns,\n            i, j, k, s;\n\n        for (k = 0; k < n; k++) {\n            for (j = 0; j < count; j++) {\n                s = 0;\n                for (i = k; i < m; i++) {\n                    s += qr[i][k] * X[i][j];\n                }\n                s = -s / qr[k][k];\n                for (i = k; i < m; i++) {\n                    X[i][j] += s * qr[i][k];\n                }\n            }\n        }\n        for (k = n - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                X[k][j] /= this.Rdiag[k];\n            }\n            for (i = 0; i < k; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * qr[i][k];\n                }\n            }\n        }\n\n        return X.subMatrix(0, n - 1, 0, count - 1);\n    },\n    isFullRank: function () {\n        var columns = this.QR.columns;\n        for (var i = 0; i < columns; i++) {\n            if (this.Rdiag[i] === 0) {\n                return false;\n            }\n        }\n        return true;\n    },\n    get upperTriangularFactor() {\n        var qr = this.QR,\n            n = qr.columns,\n            X = new Matrix(n, n),\n            i, j;\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                if (i < j) {\n                    X[i][j] = qr[i][j];\n                } else if (i === j) {\n                    X[i][j] = this.Rdiag[i];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get orthogonalFactor() {\n        var qr = this.QR,\n            rows = qr.rows,\n            columns = qr.columns,\n            X = new Matrix(rows, columns),\n            i, j, k, s;\n\n        for (k = columns - 1; k >= 0; k--) {\n            for (i = 0; i < rows; i++) {\n                X[i][k] = 0;\n            }\n            X[k][k] = 1;\n            for (j = k; j < columns; j++) {\n                if (qr[k][k] !== 0) {\n                    s = 0;\n                    for (i = k; i < rows; i++) {\n                        s += qr[i][k] * X[i][j];\n                    }\n\n                    s = -s / qr[k][k];\n\n                    for (i = k; i < rows; i++) {\n                        X[i][j] += s * qr[i][k];\n                    }\n                }\n            }\n        }\n        return X;\n    }\n};\n\nmodule.exports = QrDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/curve-fitting/~/ml-matrix/src/dc/qr.js\n ** module id = 16\n ** module chunks = 0\n **/","'use strict';\n\nvar Matrix = require('../matrix');\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/CholeskyDecomposition.cs\nfunction CholeskyDecomposition(value) {\n    if (!(this instanceof CholeskyDecomposition)) {\n        return new CholeskyDecomposition(value);\n    }\n    value = Matrix.checkMatrix(value);\n    if (!value.isSymmetric())\n        throw new Error('Matrix is not symmetric');\n\n    var a = value,\n        dimension = a.rows,\n        l = new Matrix(dimension, dimension),\n        positiveDefinite = true,\n        i, j, k;\n\n    for (j = 0; j < dimension; j++) {\n        var Lrowj = l[j];\n        var d = 0;\n        for (k = 0; k < j; k++) {\n            var Lrowk = l[k];\n            var s = 0;\n            for (i = 0; i < k; i++) {\n                s += Lrowk[i] * Lrowj[i];\n            }\n            Lrowj[k] = s = (a[j][k] - s) / l[k][k];\n            d = d + s * s;\n        }\n\n        d = a[j][j] - d;\n\n        positiveDefinite &= (d > 0);\n        l[j][j] = Math.sqrt(Math.max(d, 0));\n        for (k = j + 1; k < dimension; k++) {\n            l[j][k] = 0;\n        }\n    }\n\n    if (!positiveDefinite) {\n        throw new Error('Matrix is not positive definite');\n    }\n\n    this.L = l;\n}\n\nCholeskyDecomposition.prototype = {\n    get leftTriangularFactor() {\n        return this.L;\n    },\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var l = this.L,\n            dimension = l.rows;\n\n        if (value.rows !== dimension) {\n            throw new Error('Matrix dimensions do not match');\n        }\n\n        var count = value.columns,\n            B = value.clone(),\n            i, j, k;\n\n        for (k = 0; k < dimension; k++) {\n            for (j = 0; j < count; j++) {\n                for (i = 0; i < k; i++) {\n                    B[k][j] -= B[i][j] * l[k][i];\n                }\n                B[k][j] /= l[k][k];\n            }\n        }\n\n        for (k = dimension - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                for (i = k + 1; i < dimension; i++) {\n                    B[k][j] -= B[i][j] * l[i][k];\n                }\n                B[k][j] /= l[k][k];\n            }\n        }\n\n        return B;\n    }\n};\n\nmodule.exports = CholeskyDecomposition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/curve-fitting/~/ml-matrix/src/dc/cholesky.js\n ** module id = 17\n ** module chunks = 0\n **/","/**\n * Created by acastillo on 8/24/15.\n */\n/**\n * Non in-place function definitions, compatible with mathjs code *\n */\n\n'use strict';\n\nvar Matrix = require('ml-matrix');\n\nfunction transpose(A){\n    if(typeof A == 'number')\n        return A;\n    var result = A.clone();\n    return result.transpose();\n}\n\nfunction add(A, B){\n    if(typeof A == 'number'&&typeof B === 'number')\n        return A+B;\n    if(typeof A == 'number')\n        return this.add(B,A);\n\n    var result = A.clone();\n    return result.add(B);\n\n}\n\nfunction subtract(A, B){\n    if(typeof A == 'number'&&typeof B === 'number')\n        return A-B;\n    if(typeof A == 'number')\n        return this.subtract(B,A);\n    var result = A.clone();\n    return result.sub(B);\n}\n\nfunction multiply(A, B){\n    if(typeof A == 'number'&&typeof B === 'number')\n        return A*B;\n    if(typeof A == 'number')\n        return this.multiply(B,A);\n\n    var result = A.clone();\n\n    if(typeof B === 'number')\n        result.mul(B);\n    else\n        result = result.mmul(B);\n\n    if(result.rows==1&&result.columns==1)\n        return result[0][0];\n    else\n        return result;\n\n}\n\nfunction dotMultiply(A, B){\n    var result = A.clone();\n    return result.mul(B);\n}\n\nfunction dotDivide(A, B){\n    var result = A.clone();\n    return result.div(B);\n}\n\nfunction diag(A){\n    var diag = null;\n    var rows = A.rows, cols = A.columns, j, r;\n    //It is an array\n    if(typeof cols === \"undefined\" && (typeof A)=='object'){\n        if(A[0]&&A[0].length){\n            rows = A.length;\n            cols = A[0].length;\n            r = Math.min(rows,cols);\n            diag = new Matrix.zeros(cols, cols);\n            for (j = 0; j < cols; j++) {\n                diag[j][j]=A[j][j];\n            }\n        }\n        else{\n            cols = A.length;\n            diag = new Matrix.zeros(cols, cols);\n            for (j = 0; j < cols; j++) {\n                diag[j][j]=A[j];\n            }\n        }\n\n    }\n    if(rows == 1){\n        diag = new Matrix.zeros(cols, cols);\n        for (j = 0; j < cols; j++) {\n            diag[j][j]=A[0][j];\n        }\n    }\n    else{\n        if(rows>0 && cols > 0){\n            r = Math.min(rows,cols);\n            diag = new Array(r);\n            for (j = 0; j < r; j++) {\n                diag[j] = A[j][j];\n            }\n        }\n    }\n    return diag;\n}\n\nfunction min(A, B){\n    if(typeof A==='number' && typeof B ==='number')\n        return Math.min(A,B);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (A[i][j] < B[i][j]) {\n                result[i][j] = A[i][j];\n            }\n            else{\n                result[i][j] = B[i][j];\n            }\n        }\n    }\n    return result;\n}\n\nfunction max(A, B){\n    if(typeof A==='number' && typeof B ==='number')\n        return Math.max(A,B);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (A[i][j] > B[i][j]) {\n                result[i][j] = A[i][j];\n            }\n            else{\n                result[i][j] = B[i][j];\n            }\n        }\n    }\n    return result;\n}\n\nfunction sqrt(A){\n    if(typeof A==='number' )\n        return Math.sqrt(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.sqrt(A[i][j]);\n\n        }\n    }\n    return result;\n}\n\nfunction abs(A){\n    if(typeof A==='number' )\n        return Math.abs(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.abs(A[i][j]);\n\n        }\n    }\n    return result;\n}\n\nfunction exp(A){\n    if(typeof A==='number' )\n        return Math.sqrt(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.exp(A[i][j]);\n        }\n    }\n    return result;\n}\n\nfunction dotPow(A, b){\n    if(typeof A==='number' )\n        return Math.pow(A,b);\n    //console.log(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.pow(A[i][j],b);\n        }\n    }\n    return result;\n}\n\nfunction solve(A, B){\n    return A.solve(B);\n}\n\nfunction inv(A){\n    if(typeof A ===\"number\")\n        return 1/A;\n    return A.inverse();\n}\n\nmodule.exports = {\n    transpose:transpose,\n    add:add,\n    subtract:subtract,\n    multiply:multiply,\n    dotMultiply:dotMultiply,\n    dotDivide:dotDivide,\n    diag:diag,\n    min:min,\n    max:max,\n    solve:solve,\n    inv:inv,\n    sqrt:sqrt,\n    exp:exp,\n    dotPow:dotPow,\n    abs:abs\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/curve-fitting/src/algebra.js\n ** module id = 18\n ** module chunks = 0\n **/","var SD = require('./SD');\nvar PeakPicking2D = require('./PeakPicking2D');\nvar JcampConverter=require(\"jcampconverter\");\n\nfunction NMR2D(sd) {\n    SD.call(this, sd); // Héritage\n}\n\nNMR2D.prototype = Object.create(SD.prototype);\nNMR2D.prototype.constructor = NMR2D;\n\nNMR2D.fromJcamp = function(jcamp,options) {\n    options = options || {xy:true,keepSpectra:true,keepRecordsRegExp:/^.+$/};\n    var spectrum= JcampConverter.convert(jcamp,options);\n    return new NMR2D(spectrum);\n}\n\nNMR2D.prototype.isHomoNuclear=function(){\n    return this.sd.xType==this.sd.yType;\n}\n\n//Returns the observe frequency in the direct dimension\nNMR2D.prototype.observeFrequencyX=function(){\n    return this.sd.spectra[0].observeFrequency;\n}\n\n//Returns the observe frequency in the indirect dimension\nNMR2D.prototype.observeFrequencyY=function(){\n    return this.sd.indirectFrequency;\n}\n\n/**\n * Returns the solvent name\n */\nNMR2D.prototype.getSolventName=function(){\n    return (this.sd.info[\".SOLVENTNAME\"]||this.sd.info[\"$SOLVENT\"]).replace(\"<\",\"\").replace(\">\",\"\");\n}\n\n/**\n * This function returns the units of the direct dimension. It overrides the SD getXUnits function\n * @returns {ntuples.units|*|b.units}\n */\nNMR2D.prototype.getXUnits = function(){\n    return this.sd.ntuples[1].units;\n}\n/**\n * This function returns the units of the indirect dimension. It overrides the SD getYUnits function\n * @returns {ntuples.units|*|b.units}\n */\nNMR2D.prototype.getYUnits = function(){\n    return this.sd.ntuples[0].units;\n}\n/**\n * Returns the units of the dependent variable\n * @returns {ntuples.units|*|b.units}\n */\nNMR2D.prototype.getZUnits = function(){\n    return this.sd.ntuples[2].units;\n}\n/**\n * Overwrite this function. Now, the Y axe refers to the indirect dimension\n * @returns {sd.minMax.maxY}\n */\nNMR2D.prototype.getLastY = function(){\n    return this.sd.minMax.maxY;\n}\n/**\n * * Overwrite this function. Now, the Y axe refers to the indirect dimension\n * @returns {sd.minMax.minY}\n */\nNMR2D.prototype.getFirstY = function(){\n    return this.sd.minMax.minY;\n}\n\n//Returns the separation between 2 consecutive points in the indirect domain\nNMR2D.prototype.getDeltaY=function(){\n    return ( this.getLastY()-this.getFirstY()) / (this.getNbSubSpectra()-1);\n}\n\n/**\n * @function nmrPeakDetection2D(options)\n * This function process the given spectraData and tries to determine the NMR signals. \n + Returns an NMRSignal2D array containing all the detected 2D-NMR Signals\n * @param\toptions:+Object\t\t\tObject containing the options\n * @option\tthresholdFactor:number\tA factor to scale the automatically determined noise threshold.\n * @returns\t+Object\tset of NMRSignal2D\n */\nNMR2D.prototype.nmrPeakDetection2D=function(options){\n    options = options||{};\n    if(!options.thresholdFactor)\n        options.thresholdFactor=1;\n    var id = Math.round(Math.random()*255);\n    if(!options.id){\n        id=options.id;\n    }\n    var peakList = PeakPicking2D.findPeaks2D(this, options.thresholdFactor);\n\n    //lets add an unique ID for each peak.\n    for(var i=0;i<peakList.length;i++){\n        peakList[i]._highlight=[id+\"_\"+i];\n    }\n    return peakList;\n}\n\n/**\n* Returns the noise factor depending on the nucleus.\n*/\nNMR2D.prototype.getNMRPeakThreshold=function(nucleus) {\n    if (nucleus == \"1H\")\n        return 3.0;\n    if (nucleus ==\"13C\")\n        return 5.0;\n    return 1.0;\n}\n\n/**\n* Returns the nucleus in the specified dimension\n*/\nNMR2D.prototype.getNucleus=function(dim){\n    if(dim==1)\n        return this.sd.xType;\n    if(dim==2)\n        return this.sd.yType;\n    return this.sd.xType;\n}\n\nmodule.exports = NMR2D;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/NMR2D.js\n ** module id = 19\n ** module chunks = 0\n **/","var FFTUtils = require(\"./FFTUtils\");\nvar PeakOptimizer = require(\"./PeakOptimizer\");\nvar SimpleClustering =  require(\"./SimpleClustering\");\nvar StatArray = require('ml-stat/array');\n\nvar PeakPicking2D= {\n    DEBUG : false,\n    smallFilter : [\n        [0, 0, 1, 2, 2, 2, 1, 0, 0],\n        [0, 1, 4, 7, 7, 7, 4, 1, 0],\n        [1, 4, 5, 3, 0, 3, 5, 4, 1],\n        [2, 7, 3, -12, -23, -12, 3, 7, 2],\n        [2, 7, 0, -23, -40, -23, 0, 7, 2],\n        [2, 7, 3, -12, -23, -12, 3, 7, 2],\n        [1, 4, 5, 3, 0, 3, 5, 4, 1],\n        [0, 1, 3, 7, 7, 7, 3, 1, 0],\n        [0, 0, 1, 2, 2, 2, 1, 0, 0]],\n\n\n    //How noisy is the spectrum depending on the kind of experiment.\n    getLoGnStdDevNMR : function(spectraData) {\n    if (spectraData.isHomoNuclear())\n        return 1.5\n    else\n        return 3;\n    },\n\n    findPeaks2D : function(spectraData, thresholdFactor){\n        if(thresholdFactor==0)\n            thresholdFactor=1;\n        if(thresholdFactor<0)\n            thresholdFactor=-thresholdFactor;\n        var nbPoints = spectraData.getNbPoints();\n        var nbSubSpectra = spectraData.getNbSubSpectra();\n\n        var data = new Array(nbPoints * nbSubSpectra);\n        //var data = new Array(nbPoints * nbSubSpectra/2);\n\n        var isHomonuclear = spectraData.isHomoNuclear();\n\n        //var sum = new Array(nbPoints);\n\n        for (var iSubSpectra = 0; iSubSpectra < nbSubSpectra; iSubSpectra++) {\n            var spectrum = spectraData.getYData(iSubSpectra);\n            for (var iCol = 0; iCol < nbPoints; iCol++) {\n                if(isHomonuclear){\n                    data[iSubSpectra * nbPoints + iCol] =(spectrum[iCol]>0?spectrum[iCol]:0);\n                }\n                else{\n                    data[iSubSpectra * nbPoints + iCol] =Math.abs(spectrum[iCol]);\n                }\n            }\n        }\n\n        var nStdDev = this.getLoGnStdDevNMR(spectraData);\n        if(isHomonuclear){\n            var convolutedSpectrum = this.convoluteWithLoG(data, nbSubSpectra, nbPoints);\n            var peaksMC1 = this.findPeaks2DLoG(data, convolutedSpectrum, nbSubSpectra, nbPoints, nStdDev*thresholdFactor);//)1.5);\n            var peaksMax1 = this.findPeaks2DMax(data, convolutedSpectrum, nbSubSpectra, nbPoints, (nStdDev+0.5)*thresholdFactor);//2.0);\n            for(var i=0;i<peaksMC1.length;i++)\n                peaksMax1.push(peaksMC1[i]);\n            //console.log(peaksMax1);\n            return PeakOptimizer.enhanceSymmetry(this.createSignals2D(peaksMax1,spectraData,24));\n\n        }\n        else{\n            var convolutedSpectrum = this.convoluteWithLoG(data, nbSubSpectra, nbPoints);\n            var peaksMC1 = this.findPeaks2DLoG(data, convolutedSpectrum, nbSubSpectra, nbPoints, nStdDev*thresholdFactor);\n            //Peak2D[] peaksMC1 = PeakPicking2D.findPeaks2DMax(data, nbSubSpectra, nbPoints, (nStdDev+0.5)*thresholdFactor);\n            //Remove peaks with less than 3% of the intensity of the highest peak\n            return this.createSignals2D(PeakOptimizer.clean(peaksMC1, 0.05), spectraData,24);\n        }\n\n    },\n    /**\n     Calculates the 1st derivative of the 2D matrix, using the LoG kernel approximation\n     */\n    convoluteWithLoG : function(inputSpectrum, nRows, nCols){\n        var ftSpectrum = new Array(nCols * nRows);\n        for (var i = nRows * nCols-1; i >=0; i--){\n            ftSpectrum[i] = inputSpectrum[i];\n        }\n\n        ftSpectrum = FFTUtils.fft2DArray(ftSpectrum, nRows, nCols);\n\n        var dim = this.smallFilter.length;\n        var ftFilterData = new Array(nCols * nRows);\n        for(var i=nCols * nRows-1;i>=0;i--){\n            ftFilterData[i]=0;\n        }\n\n        var iRow, iCol;\n        var shift = (dim - 1) / 2;\n        //console.log(dim);\n        for (var ir = 0; ir < dim; ir++) {\n            iRow = (ir - shift + nRows) % nRows;\n            for (var ic = 0; ic < dim; ic++) {\n                iCol = (ic - shift + nCols) % nCols;\n                ftFilterData[iRow * nCols + iCol] = this.smallFilter[ir][ic];\n            }\n        }\n\n        ftFilterData = FFTUtils.fft2DArray(ftFilterData, nRows, nCols);\n\n        var ftRows = nRows * 2;\n        var ftCols = nCols / 2 + 1;\n        FFTUtils.convolute2DI(ftSpectrum, ftFilterData, ftRows, ftCols);\n\n        return  FFTUtils.ifft2DArray(ftSpectrum, ftRows, ftCols);\n    },\n    /**\n     Detects all the 2D-peaks in the given spectrum based on center of mass logic.\n     */\n    findPeaks2DLoG : function(inputSpectrum, convolutedSpectrum, nRows, nCols, nStdDev) {\n        var threshold = 0;\n        for(var i=nCols*nRows-2;i>=0;i--)\n            threshold+=Math.pow(convolutedSpectrum[i]-convolutedSpectrum[i+1],2);\n        threshold=-Math.sqrt(threshold);\n        threshold*=nStdDev/nRows;\n\n        var bitmask = new Array(nCols * nRows);\n        for(var i=nCols * nRows-1;i>=0;i--){\n            bitmask[i]=0;\n        }\n        var nbDetectedPoints = 0;\n        var lasti=-1;\n        for (var i = convolutedSpectrum.length-1; i >=0 ; i--) {\n            if (convolutedSpectrum[i] < threshold) {\n                bitmask[i] = 1;\n                nbDetectedPoints++;\n            }\n        }\n        var iStart = 0;\n        //int ranges = 0;\n        var peakList = [];\n\n        while (nbDetectedPoints != 0) {\n            for (iStart; iStart < bitmask.length && bitmask[iStart]==0; iStart++){};\n            //\n            if (iStart == bitmask.length)\n                break;\n\n            nbDetectedPoints -= this.extractArea(inputSpectrum, convolutedSpectrum,\n                bitmask, iStart, nRows, nCols, peakList, threshold);\n        }\n\n        if (peakList.length > 0&&this.DEBUG) {\n            console.log(\"No peak found\");\n        }\n        return peakList;\n    },\n    /**\n     Detects all the 2D-peaks in the given spectrum based on the Max logic.\n     */\n    findPeaks2DMax : function(inputSpectrum, cs, nRows, nCols, nStdDev) {\n        var threshold = 0;\n        for(var i=nCols*nRows-2;i>=0;i--)\n            threshold+=Math.pow(cs[i]-cs[i+1],2);\n        threshold=-Math.sqrt(threshold);\n        threshold*=nStdDev/nRows;\n\n        var rowI,colI;\n        var peakListMax = [];\n        var tmpIndex = 0;\n        for (var i = 0; i < cs.length; i++) {\n            if (cs[i] < threshold) {\n                //It is a peak?\n                rowI=Math.floor(i/nCols);\n                colI=i%nCols;\n                //Verifies if this point is a peak;\n                if(rowI>0&&rowI+1<nRows&&colI+1<nCols&&colI>0){\n                    //It is the minimum in the same row\n                    if(cs[i]<cs[i+1]&&cs[i]<cs[i-1]){\n                        //It is the minimum in the previous row\n                        tmpIndex=(rowI-1)*nCols+colI;\n                        if(cs[i]<cs[tmpIndex-1]&&cs[i]<cs[tmpIndex]&&cs[i]<cs[tmpIndex+1]){\n                            //It is the minimum in the next row\n                            tmpIndex=(rowI+1)*nCols+colI;\n                            if(cs[i]<cs[tmpIndex-1]&&cs[i]<cs[tmpIndex]&&cs[i]<cs[tmpIndex+1]){\n                                peakListMax.push({x:colI,y:rowI,z:inputSpectrum[i]});\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return peakListMax;\n    },\n    /*\n     This function detects the peaks\n     */\n    extractArea : function(spectrum, convolutedSpectrum, bitmask, iStart,\n                                                   nRows, nCols, peakList, threshold) {\n        var iRow = Math.floor(iStart / nCols);\n        var iCol = iStart % nCols;\n        var peakPoints =[];\n        //console.log(iStart+\" \"+iRow+\" \"+iCol);\n        // scanBitmask(bitmask, convolutedSpectrum, nRows, nCols, iRow, iCol,\n        // peakPoints);\n        this.scanBitmask(bitmask, nRows, nCols, iRow, iCol, peakPoints);\n        //console.log(\"extractArea.lng \"+peakPoints.length);\n        var x = new Array(peakPoints.length);\n        var y = new Array(peakPoints.length);\n        var z = new Array(peakPoints.length);\n        var nValues = peakPoints.length;\n        var xAverage = 0.0;\n        var yAverage = 0.0;\n        var zSum = 0.0;\n        if (nValues >= 9) {\n            if (this.DEBUG)\n                console.log(\"nValues=\" + nValues);\n            var maxValue = Number.NEGATIVE_INFINITY;\n            var maxIndex = -1;\n            for (var i = 0; i < nValues; i++) {\n                var pt = (peakPoints.splice(0,1))[0];\n                x[i] = pt[0];\n                y[i] = pt[1];\n                z[i] = spectrum[pt[1] * nCols + pt[0]];\n                xAverage += x[i] * z[i];\n                yAverage += y[i] * z[i];\n                zSum += z[i];\n                if (z[i] > maxValue) {\n                    maxValue = z[i];\n                    maxIndex = i;\n                }\n            }\n            if (maxIndex != -1) {\n                xAverage /= zSum;\n                yAverage /= zSum;\n                var newPeak = {x:xAverage, y:yAverage, z:zSum};\n                var minmax;\n                minmax =StatArray.minMax(x);\n                newPeak.minX=minmax.min;\n                newPeak.maxX=minmax.max;\n                minmax = StatArray.minMax(y);\n                newPeak.minY=minmax.min;\n                newPeak.maxY=minmax.max;\n                peakList.push(newPeak);\n            }\n        }\n        return nValues;\n    },\n    /*\n     Return all the peaks(x,y points) that composes a signal.\n     */\n    scanBitmask : function(bitmask, nRows, nCols, iRow, iCol, peakPoints) {\n        //console.log(nRows+\" \"+iRow+\" \"+nCols+\" \"+iCol);\n        if (iRow < 0 || iCol < 0 || iCol == nCols || iRow == nRows)\n            return;\n        if (bitmask[iRow * nCols + iCol]) {\n            bitmask[iRow * nCols + iCol] = 0;\n            peakPoints.push([iCol, iRow]);\n            this.scanBitmask(bitmask, nRows, nCols, iRow + 1, iCol, peakPoints);\n            this.scanBitmask(bitmask, nRows, nCols, iRow - 1, iCol, peakPoints);\n            this.scanBitmask(bitmask, nRows, nCols, iRow, iCol + 1, peakPoints);\n            this.scanBitmask(bitmask, nRows, nCols, iRow, iCol - 1, peakPoints);\n        }\n    },\n    /**\n     This function converts a set of 2D-peaks in 2D-signals. Each signal could be composed\n     of many 2D-peaks, and it has some additional information related to the NMR spectrum.\n     */\n    createSignals2D : function(peaks, spectraData, tolerance){\n        //console.log(peaks.length);\n        var signals=[];\n        var nbSubSpectra = spectraData.getNbSubSpectra();\n\n        var bf1=spectraData.observeFrequencyX();\n        var bf2=spectraData.observeFrequencyY();\n\n        var firstY = spectraData.getFirstY();\n        var lastY = spectraData.getLastY();\n        var dy = spectraData.getDeltaY();\n\n        //console.log(firstY+\" \"+lastY+\" \"+dy+\" \"+nbSubSpectra);\n        //spectraData.setActiveElement(0);\n        var noValid=0;\n        for (var i = peaks.length-1; i >=0 ; i--) {\n            //console.log(peaks[i].x+\" \"+spectraData.arrayPointToUnits(peaks[i].x));\n            //console.log(peaks[i].y+\" \"+(firstY + dy * (peaks[i].y)));\n            peaks[i].x=(spectraData.arrayPointToUnits(peaks[i].x));\n            peaks[i].y=(firstY + dy * (peaks[i].y));\n\n            //console.log(peaks[i])\n            //Still having problems to correctly detect peaks on those areas. So I'm removing everything there.\n            if(peaks[i].y<-1||peaks[i].y>=210){\n                peaks.splice(i,1);\n            }\n        }\n        //console.log(peaks);\n        //The connectivity matrix is an square and symmetric matrix, so we'll only store the upper diagonal in an\n        //array like form\n        var connectivity = [];\n        var tmp=0;\n        tolerance*=tolerance;\n        //console.log(tolerance);\n        for (var i = 0; i < peaks.length; i++) {\n            for (var j = i; j < peaks.length; j++) {\n                tmp=Math.pow((peaks[i].x-peaks[j].x)*bf1,2)+Math.pow((peaks[i].y-peaks[j].y)*bf2,2);\n                //Console.log(peaks[i].getX()+\" \"+peaks[j].getX()+\" \"+tmp);\n                if(tmp<tolerance){//30*30Hz We cannot distinguish peaks with less than 20 Hz of separation\n                    connectivity.push(1);\n                }\n                else{\n                    connectivity.push(0);\n                }\n            }\n        }\n\n        //console.log(connectivity);\n\n        var clusters = SimpleClustering.fullClusterGenerator(connectivity);\n\n        //console.log(clusters)\n\n        var signals = [];\n        if (peaks != null) {\n            var xValue, yValue;\n            for (var iCluster = 0; iCluster < clusters.length; iCluster++) {\n                var signal={nucleusX:spectraData.getNucleus(1),nucleusY:spectraData.getNucleus(2)};\n                signal.resolutionX=( spectraData.getLastX()-spectraData.getFirstX()) / spectraData.getNbPoints();\n                signal.resolutionY=dy;\n                var peaks2D = [];\n                signal.shiftX = 0;\n                signal.shiftY = 0;\n                var sumZ = 0;\n                for(var jPeak = clusters[iCluster].length-1;jPeak>=0;jPeak--){\n                    if(clusters[iCluster][jPeak]==1){\n                        peaks2D.push(peaks[jPeak]);\n                        signal.shiftX+=peaks[jPeak].x*peaks[jPeak].z;\n                        signal.shiftY+=peaks[jPeak].y*peaks[jPeak].z;\n                        sumZ+=peaks[jPeak].z;\n                    }\n                }\n                signal.shiftX/=sumZ;\n                signal.shiftY/=sumZ;\n                signal.peaks = peaks2D;\n                signals.push(signal);\n            }\n        }\n        //console.log(signals);\n        return signals;\n    }\n}\n\nmodule.exports = PeakPicking2D;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/PeakPicking2D.js\n ** module id = 20\n ** module chunks = 0\n **/","var FFT = require('./fftlib');\n\nvar FFTUtils= {\n    DEBUG : false,\n\n    /**\n     * Calculates the inverse of a 2D Fourier transform\n     *\n     * @param ft\n     * @param ftRows\n     * @param ftCols\n     * @return\n     */\n    ifft2DArray : function(ft, ftRows, ftCols){\n        var tempTransform = new Array(ftRows * ftCols);\n        var nRows = ftRows / 2;\n        var nCols = (ftCols - 1) * 2;\n        // reverse transform columns\n        FFT.init(nRows);\n        var tmpCols = {re: new Array(nRows), im: new Array(nRows)};\n        for (var iCol = 0; iCol < ftCols; iCol++) {\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                tmpCols.re[iRow] = ft[(iRow * 2) * ftCols + iCol];\n                tmpCols.im[iRow] = ft[(iRow * 2 + 1) * ftCols + iCol];\n            }\n            //Unnormalized inverse transform\n            FFT.bt(tmpCols.re, tmpCols.im);\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                tempTransform[(iRow * 2) * ftCols + iCol] = tmpCols.re[iRow];\n                tempTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n            }\n        }\n\n        // reverse row transform\n        var finalTransform = new Array(nRows * nCols);\n        FFT.init(nCols);\n        var tmpRows = {re: new Array(nCols), im: new Array(nCols)};\n        var scale = nCols * nRows;\n        for (var iRow = 0; iRow < ftRows; iRow += 2) {\n            tmpRows.re[0] = tempTransform[iRow * ftCols];\n            tmpRows.im[0] = tempTransform[(iRow + 1) * ftCols];\n            for (var iCol = 1; iCol < ftCols; iCol++) {\n                tmpRows.re[iCol] = tempTransform[iRow * ftCols + iCol];\n                tmpRows.im[iCol] = tempTransform[(iRow + 1) * ftCols + iCol];\n                tmpRows.re[nCols - iCol] = tempTransform[iRow * ftCols + iCol];\n                tmpRows.im[nCols - iCol] = -tempTransform[(iRow + 1) * ftCols + iCol];\n            }\n            //Unnormalized inverse transform\n            FFT.bt(tmpRows.re, tmpRows.im);\n\n            var indexB = (iRow / 2) * nCols;\n            for (var iCol = nCols - 1; iCol >= 0; iCol--) {\n                finalTransform[indexB + iCol] = tmpRows.re[iCol] / scale;\n            }\n        }\n        return finalTransform;\n    },\n    /**\n     * Calculates the fourier transform of a matrix of size (nRows,nCols) It is\n     * assumed that both nRows and nCols are a power of two\n     *\n     * On exit the matrix has dimensions (nRows * 2, nCols / 2 + 1) where the\n     * even rows contain the real part and the odd rows the imaginary part of the\n     * transform\n     * @param data\n     * @param nRows\n     * @param nCols\n     * @return\n     */\n    fft2DArray:function(data, nRows, nCols) {\n        var ftCols = (nCols / 2 + 1);\n        var ftRows = nRows * 2;\n        var tempTransform = new Array(ftRows * ftCols);\n        FFT.init(nCols);\n        // transform rows\n        var tmpRows = {re: new Array(nCols), im: new Array(nCols)};\n        var row1 = {re: new Array(nCols), im: new Array(nCols)}\n        var row2 = {re: new Array(nCols), im: new Array(nCols)}\n        var index, iRow0, iRow1, iRow2, iRow3;\n        for (var iRow = 0; iRow < nRows / 2; iRow++) {\n            index = (iRow * 2) * nCols;\n            tmpRows.re = data.slice(index, index + nCols);\n\n            index = (iRow * 2 + 1) * nCols;\n            tmpRows.im = data.slice(index, index + nCols);\n\n            FFT.fft1d(tmpRows.re, tmpRows.im);\n\n            this.reconstructTwoRealFFT(tmpRows, row1, row2);\n            //Now lets put back the result into the output array\n            iRow0 = (iRow * 4) * ftCols;\n            iRow1 = (iRow * 4 + 1) * ftCols;\n            iRow2 = (iRow * 4 + 2) * ftCols;\n            iRow3 = (iRow * 4 + 3) * ftCols;\n            for (var k = ftCols - 1; k >= 0; k--) {\n                tempTransform[iRow0 + k] = row1.re[k];\n                tempTransform[iRow1 + k] = row1.im[k];\n                tempTransform[iRow2 + k] = row2.re[k];\n                tempTransform[iRow3 + k] = row2.im[k];\n            }\n        }\n\n        //console.log(tempTransform);\n        row1 = null;\n        row2 = null;\n        // transform columns\n        var finalTransform = new Array(ftRows * ftCols);\n        FFT.init(nRows);\n        var tmpCols = {re: new Array(nRows), im: new Array(nRows)};\n        for (var iCol = ftCols - 1; iCol >= 0; iCol--) {\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                tmpCols.re[iRow] = tempTransform[(iRow * 2) * ftCols + iCol];\n                tmpCols.im[iRow] = tempTransform[(iRow * 2 + 1) * ftCols + iCol];\n            }\n            FFT.fft1d(tmpCols.re, tmpCols.im);\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                finalTransform[(iRow * 2) * ftCols + iCol] = tmpCols.re[iRow];\n                finalTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n            }\n        }\n\n        //console.log(finalTransform);\n        return finalTransform;\n\n    },\n    /**\n     *\n     * @param fourierTransform\n     * @param realTransform1\n     * @param realTransform2\n     *\n     * Reconstructs the individual Fourier transforms of two simultaneously\n     * transformed series. Based on the Symmetry relationships (the asterisk\n     * denotes the complex conjugate)\n     *\n     * F_{N-n} = F_n^{*} for a purely real f transformed to F\n     *\n     * G_{N-n} = G_n^{*} for a purely imaginary g transformed to G\n     *\n     */\n    reconstructTwoRealFFT:function(fourierTransform, realTransform1, realTransform2) {\n        var length = fourierTransform.re.length;\n\n        // the components n=0 are trivial\n        realTransform1.re[0] = fourierTransform.re[0];\n        realTransform1.im[0] = 0.0;\n        realTransform2.re[0] = fourierTransform.im[0];\n        realTransform2.im[0] = 0.0;\n        var rm, rp, im, ip, j;\n        for (var i = length / 2; i > 0; i--) {\n            j = length - i;\n            rm = 0.5 * (fourierTransform.re[i] - fourierTransform.re[j]);\n            rp = 0.5 * (fourierTransform.re[i] + fourierTransform.re[j]);\n            im = 0.5 * (fourierTransform.im[i] - fourierTransform.im[j]);\n            ip = 0.5 * (fourierTransform.im[i] + fourierTransform.im[j]);\n            realTransform1.re[i] = rp;\n            realTransform1.im[i] = im;\n            realTransform1.re[j] = rp;\n            realTransform1.im[j] = -im;\n            realTransform2.re[i] = ip;\n            realTransform2.im[i] = -rm;\n            realTransform2.re[j] = ip;\n            realTransform2.im[j] = rm;\n        }\n    },\n\n    /**\n     * In place version of convolute 2D\n     *\n     * @param ftSignal\n     * @param ftFilter\n     * @param ftRows\n     * @param ftCols\n     * @return\n     */\n    convolute2DI:function(ftSignal, ftFilter, ftRows, ftCols) {\n        var re, im;\n        for (var iRow = 0; iRow < ftRows / 2; iRow++) {\n            for (var iCol = 0; iCol < ftCols; iCol++) {\n                //\n                re = ftSignal[(iRow * 2) * ftCols + iCol]\n                * ftFilter[(iRow * 2) * ftCols + iCol]\n                - ftSignal[(iRow * 2 + 1) * ftCols + iCol]\n                * ftFilter[(iRow * 2 + 1) * ftCols + iCol];\n                im = ftSignal[(iRow * 2) * ftCols + iCol]\n                * ftFilter[(iRow * 2 + 1) * ftCols + iCol]\n                + ftSignal[(iRow * 2 + 1) * ftCols + iCol]\n                * ftFilter[(iRow * 2) * ftCols + iCol];\n                //\n                ftSignal[(iRow * 2) * ftCols + iCol] = re;\n                ftSignal[(iRow * 2 + 1) * ftCols + iCol] = im;\n            }\n        }\n    }\n}\n\nmodule.exports = FFTUtils;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/FFTUtils.js\n ** module id = 21\n ** module chunks = 0\n **/","/**\n * Fast Fourier Transform module\n * 1D-FFT/IFFT, 2D-FFT/IFFT (radix-2)\n */\nvar FFT = (function(){\n  var FFT;  \n  \n  if(typeof exports !== 'undefined') {\n    FFT = exports;   // for CommonJS\n  } else {\n    FFT = {};\n  }\n  \n  var version = {\n    release: '0.3.0',\n    date: '2013-03'\n  };\n  FFT.toString = function() {\n    return \"version \" + version.release + \", released \" + version.date;\n  };\n\n  // core operations\n  var _n = 0,          // order\n      _bitrev = null,  // bit reversal table\n      _cstb = null;    // sin/cos table\n\n  var core = {\n    init : function(n) {\n      if(n !== 0 && (n & (n - 1)) === 0) {\n        _n = n;\n        core._initArray();\n        core._makeBitReversalTable();\n        core._makeCosSinTable();\n      } else {\n        throw new Error(\"init: radix-2 required\");\n      }\n    },\n    // 1D-FFT\n    fft1d : function(re, im) {\n      core.fft(re, im, 1);\n    },\n    // 1D-IFFT\n    ifft1d : function(re, im) {\n      var n = 1/_n;\n      core.fft(re, im, -1);\n      for(var i=0; i<_n; i++) {\n        re[i] *= n;\n        im[i] *= n;\n      }\n    },\n     // 1D-IFFT\n    bt1d : function(re, im) {\n      core.fft(re, im, -1);\n    },\n    // 2D-FFT Not very useful if the number of rows have to be equal to cols\n    fft2d : function(re, im) {\n      var tre = [],\n          tim = [],\n          i = 0;\n      // x-axis\n      for(var y=0; y<_n; y++) {\n        i = y*_n;\n        for(var x1=0; x1<_n; x1++) {\n          tre[x1] = re[x1 + i];\n          tim[x1] = im[x1 + i];\n        }\n        core.fft1d(tre, tim);\n        for(var x2=0; x2<_n; x2++) {\n          re[x2 + i] = tre[x2];\n          im[x2 + i] = tim[x2];\n        }\n      }\n      // y-axis\n      for(var x=0; x<_n; x++) {\n        for(var y1=0; y1<_n; y1++) {\n          i = x + y1*_n;\n          tre[y1] = re[i];\n          tim[y1] = im[i];\n        }\n        core.fft1d(tre, tim);\n        for(var y2=0; y2<_n; y2++) {\n          i = x + y2*_n;\n          re[i] = tre[y2];\n          im[i] = tim[y2];\n        }\n      }\n    },\n    // 2D-IFFT\n    ifft2d : function(re, im) {\n      var tre = [],\n          tim = [],\n          i = 0;\n      // x-axis\n      for(var y=0; y<_n; y++) {\n        i = y*_n;\n        for(var x1=0; x1<_n; x1++) {\n          tre[x1] = re[x1 + i];\n          tim[x1] = im[x1 + i];\n        }\n        core.ifft1d(tre, tim);\n        for(var x2=0; x2<_n; x2++) {\n          re[x2 + i] = tre[x2];\n          im[x2 + i] = tim[x2];\n        }\n      }\n      // y-axis\n      for(var x=0; x<_n; x++) {\n        for(var y1=0; y1<_n; y1++) {\n          i = x + y1*_n;\n          tre[y1] = re[i];\n          tim[y1] = im[i];\n        }\n        core.ifft1d(tre, tim);\n        for(var y2=0; y2<_n; y2++) {\n          i = x + y2*_n;\n          re[i] = tre[y2];\n          im[i] = tim[y2];\n        }\n      }\n    },\n    // core operation of FFT\n    fft : function(re, im, inv) {\n      var d, h, ik, m, tmp, wr, wi, xr, xi,\n          n4 = _n >> 2;\n      // bit reversal\n      for(var l=0; l<_n; l++) {\n        m = _bitrev[l];\n        if(l < m) {\n          tmp = re[l];\n          re[l] = re[m];\n          re[m] = tmp;\n          tmp = im[l];\n          im[l] = im[m];\n          im[m] = tmp;\n        }\n      }\n      // butterfly operation\n      for(var k=1; k<_n; k<<=1) {\n        h = 0;\n        d = _n/(k << 1);\n        for(var j=0; j<k; j++) {\n          wr = _cstb[h + n4];\n          wi = inv*_cstb[h];\n          for(var i=j; i<_n; i+=(k<<1)) {\n            ik = i + k;\n            xr = wr*re[ik] + wi*im[ik];\n            xi = wr*im[ik] - wi*re[ik];\n            re[ik] = re[i] - xr;\n            re[i] += xr;\n            im[ik] = im[i] - xi;\n            im[i] += xi;\n          }\n          h += d;\n        }\n      }\n    },\n    // initialize the array (supports TypedArray)\n    _initArray : function() {\n      if(typeof Uint32Array !== 'undefined') {\n        _bitrev = new Uint32Array(_n);\n      } else {\n        _bitrev = [];\n      }\n      if(typeof Float64Array !== 'undefined') {\n        _cstb = new Float64Array(_n*1.25);\n      } else {\n        _cstb = [];\n      }\n    },\n    // zero padding\n    _paddingZero : function() {\n      // TODO\n    },\n    // makes bit reversal table\n    _makeBitReversalTable : function() {\n      var i = 0,\n          j = 0,\n          k = 0;\n      _bitrev[0] = 0;\n      while(++i < _n) {\n        k = _n >> 1;\n        while(k <= j) {\n          j -= k;\n          k >>= 1;\n        }\n        j += k;\n        _bitrev[i] = j;\n      }\n    },\n    // makes trigonometiric function table\n    _makeCosSinTable : function() {\n      var n2 = _n >> 1,\n          n4 = _n >> 2,\n          n8 = _n >> 3,\n          n2p4 = n2 + n4,\n          t = Math.sin(Math.PI/_n),\n          dc = 2*t*t,\n          ds = Math.sqrt(dc*(2 - dc)),\n          c = _cstb[n4] = 1,\n          s = _cstb[0] = 0;\n      t = 2*dc;\n      for(var i=1; i<n8; i++) {\n        c -= dc;\n        dc += t*c;\n        s += ds;\n        ds -= t*s;\n        _cstb[i] = s;\n        _cstb[n4 - i] = c;\n      }\n      if(n8 !== 0) {\n        _cstb[n8] = Math.sqrt(0.5);\n      }\n      for(var j=0; j<n4; j++) {\n        _cstb[n2 - j]  = _cstb[j];\n      }\n      for(var k=0; k<n2p4; k++) {\n        _cstb[k + n2] = -_cstb[k];\n      }\n    }\n  };\n  // aliases (public APIs)\n  var apis = ['init', 'fft1d', 'ifft1d', 'fft2d', 'ifft2d'];\n  for(var i=0; i<apis.length; i++) {\n    FFT[apis[i]] = core[apis[i]];\n  }\n  FFT.bt = core.bt1d;\n  FFT.fft = core.fft1d;\n  FFT.ifft = core.ifft1d;\n  \n  return FFT;\n}).call(this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/fftlib.js\n ** module id = 22\n ** module chunks = 0\n **/","var PeakOptimizer={\n\tdiagonalError:0.05,\n\ttolerance:0.05,\n\tDEBUG:false,\n    toleranceX : 0.025,\n    toleranceY : 0.5,\n\n    clean: function(peaks, threshold){\n        var max = Number.NEGATIVE_INFINITY;\n        var i,peak;\n        //double min = Double.MAX_VALUE;\n        for(i=peaks.length-1;i>=0;i--){\n            if(Math.abs(peaks[i].z)>max)\n                max=Math.abs(peaks[i].z);\n        }\n        max*=threshold;\n        for(i=peaks.length-1;i>=0;i--){\n            if(Math.abs(peaks[i].z)<max)\n                peaks.splice(i,1);\n        }\n        return peaks;\n    },\n\t\n\tenhanceSymmetry: function(signals){\n\t\t\n\t\tvar properties = this.initializeProperties(signals);\n\t\tvar output = signals;\n\n\t\tif(this.DEBUG)\n\t\t\tconsole.log(\"Before optimization size: \"+output.size());\n\t\t\n\t\t//First step of the optimization: Symmetry validation\n\t\tvar i,hits,index;\n\t\tvar signal;\n\t\tfor(i=output.length-1;i>=0;i--){\n\t\t\tsignal = output[i];\n\t\t\tif(signal.peaks.length>1)\n\t\t\t\tproperties[i][1]++;\n\t\t\tif(properties[i][0]==1){\n\t\t\t\tindex = this.exist(output, properties, signal,-1,true);\n\t\t\t\tif(index>=0){\n\t\t\t\t\tproperties[i][1]+=2;\n\t\t\t\t\tproperties[index][1]+=2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//Second step of the optimization: Diagonal image existence\n\t\tfor(i=output.length-1;i>=0;i--){\n\t\t\tsignal = output[i];\n\t\t\tif(properties[i][0]==0){\n\t\t\t\thits = this.checkCrossPeaks(output, properties, signal, true);\n\t\t\t\tproperties[i][1]+=hits;\n\t\t\t\t//checkCrossPeaks(output, properties, signal, false);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Now, each peak have a score between 0 and 4, we can complete the patterns which\n\t\t//contains peaks with high scores, and finally, we can remove peaks with scores 0 and 1\n\t\tvar count = 0;\n\t\tfor(i=output.length-1;i>=0;i--){\n\t\t\tif(properties[i][0]!==0&&properties[i][1]>2){\n\t\t\t\tcount++;\n\t\t\t\tcount+=this.completeMissingIfNeeded(output,properties,output[i],properties[i]);\n\t\t\t}\n\t\t\tif(properties[i][1]>=2&&properties[i][0]===0)\n\t\t\t\tcount++;\n\t\t}\n\t\t\n\t\tif(this.DEBUG)\n\t\t\tconsole.log(\"After optimization size: \"+count);\n\t\tvar  toReturn = new Array(count);\n\t\tcount--;\n\t\tfor(i=output.length-1;i>=0;i--){\n\t\t\tif(properties[i][0]!==0&&properties[i][1]>2\n\t\t\t\t\t||properties[i][0]===0&&properties[i][1]>1){\n\t\t\t\ttoReturn[count--]=output[i];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tconsole.log(\"Removed \"+i+\" \"+output[i].peaks.length);\n\t\t\t}\n\t\t\t//if(properties.get(i)[1]>=2)\n\t\t\t//\ttoReturn[count--]=output.get(i);\n\t\t}\n\t\treturn toReturn;\n\t},\n\t\n\tcompleteMissingIfNeeded: function(output, properties, thisSignal, thisProp) {\n\t\t//Check for symmetry\n\t\tvar index = this.exist(output, properties, thisSignal,-thisProp[0],true);\n\t\tvar addedPeaks=0;\n\t\tvar newSignal = null, tmpProp=null;\n\t\tif(index<0){//If this signal have no a symmetry image, we have to include it\n\t\t\tnewSignal = {nucleusX:thisSignal.nucleusX,nucleusY:thisSignal.nucleusY};\n\t\t\tnewSignal.resolutionX=thisSignal.resolutionX;\n\t\t\tnewSignal.resolutionY=thisSignal.resolutionY;\n\t\t\tnewSignal.shiftX=thisSignal.shiftY;\n\t\t\tnewSignal.shiftY=thisSignal.shiftX;\n\t\t\tnewSignal.peaks = [{x:thisSignal.shiftY,y:thisSignal.shiftX,z:1}];\n\t\t\toutput.push(newSignal);\n\t\t\ttmpProp = [-thisProp[0],thisProp[1]];\n\t\t\tproperties.push(tmpProp);\n\t\t\taddedPeaks++;\n\t\t}\n\t\t//Check for diagonal peaks\n\t\tvar j=0;\n\t\tvar diagX=false, diagY=false;\n\t\tvar signal;\n\t\tfor(j=output.length-1;j>=0;j--){\n\t\t\tsignal = output[j];\n\t\t\tif(properties[j][0]===0){\n\t\t\t\tif(Math.abs(signal.shiftX-thisSignal.shiftX)<this.diagonalError)\n\t\t\t\t\tdiagX=true;\n\t\t\t\tif(Math.abs(signal.shiftY-thisSignal.shiftY)<this.diagonalError)\n\t\t\t\t\tdiagY=true;\n\t\t\t}\n\t\t}\n\t\tif(diagX===false){\n\t\t\tnewSignal = {nucleusX:thisSignal.nucleusX,nucleusY:thisSignal.nucleusY};\n\t\t\tnewSignal.resolutionX=thisSignal.resolutionX;\n\t\t\tnewSignal.resolutionY=thisSignal.resolutionY;\n\t\t\tnewSignal.shiftX=thisSignal.shiftX;\n\t\t\tnewSignal.shiftY=thisSignal.shiftX;\n\t\t\tnewSignal.peaks = [{x:thisSignal.shiftX,y:thisSignal.shiftX,z:1}];\n\t\t\toutput.push(newSignal);\n\t\t\ttmpProp = [0,thisProp[1]];\n\t\t\tproperties.push(tmpProp);\n\t\t\taddedPeaks++;\n\t\t}\n\t\tif(diagY===false){\n\t\t\tnewSignal = {nucleusX:thisSignal.nucleusX,nucleusY:thisSignal.nucleusY};\n\t\t\tnewSignal.resolutionX=thisSignal.resolutionX;\n\t\t\tnewSignal.resolutionY=thisSignal.resolutionY;\n\t\t\tnewSignal.shiftX=thisSignal.shiftY;\n\t\t\tnewSignal.shiftY=thisSignal.shiftY;\n\t\t\tnewSignal.peaks = [{x:thisSignal.shiftY,y:thisSignal.shiftY,z:1}];\n\t\t\toutput.push(newSignal);\n\t\t\ttmpProp = [0,thisProp[1]];\n\t\t\tproperties.push(tmpProp);\n\t\t\taddedPeaks++;\n\t\t}\n\t\treturn addedPeaks;\n\t\t\n\t},\n\t\n\t//Check for any diagonal peak that match this cross peak\n\tcheckCrossPeaks: function(output, properties, signal, updateProperties) {\n\t\tvar hits = 0, i=0, shift=signal.shiftX*4;\n\t\tvar crossPeaksX = [],crossPeaksY = [];\n\t\tvar cross;\n\t\tfor(i=output.length-1;i>=0;i--){\n\t\t\tcross = output[i];\n\t\t\tif(properties[i][0]!==0){\n\t\t\t\tif(Math.abs(cross.shiftX-signal.shiftX)<this.diagonalError){\n\t\t\t\t\thits++;\n\t\t\t\t\tif(updateProperties)\n\t\t\t\t\t\tproperties[i][1]++;\n\t\t\t\t\tcrossPeaksX.push(i);\n\t\t\t\t\tshift+=cross.shiftX;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(Math.abs(cross.shiftY-signal.shiftY)<this.diagonalError){\n\t\t\t\t\t\thits++;\n\t\t\t\t\t\tif(updateProperties)\n\t\t\t\t\t\t\tproperties[i][1]++;\n\t\t\t\t\t\tcrossPeaksY.push(i);\n\t\t\t\t\t\tshift+=cross.shiftY;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//Update found crossPeaks and diagonal peak\n\t\tshift/=(crossPeaksX.length+crossPeaksY.length+4);\n\t\tif(crossPeaksX.length>0){\n\t\t\tfor( i=crossPeaksX.length-1;i>=0;i--){\n\t\t\t\toutput[crossPeaksX[i]].shiftX=shift;\n\t\t\t}\n\t\t}\n\t\tif(crossPeaksY.length>0){\n\t\t\tfor( i=crossPeaksY.length-1;i>=0;i--){\n\t\t\t\toutput[crossPeaksY[i]].shiftY=shift;\n\t\t\t}\n\t\t}\n\t\tsignal.shiftX=shift;\n\t\tsignal.shiftY=shift;\n\t\treturn hits;\n\t},\n\n\texist: function(output, properties, signal, type, symmetricSearch) {\n\t\tfor(var i=output.length-1;i>=0;i--){\n\t\t\tif(properties[i][0]==type){\n\t\t\t\tif(this.distanceTo(signal, output[i], symmetricSearch)<this.tolerance){\n\t\t\t\t\tif(!symmetricSearch){\n\t\t\t\t\t\tvar shiftX=(output[i].shiftX+signal.shiftX)/2.0;\n\t\t\t\t\t\tvar shiftY=(output[i].shiftY+signal.shiftY)/2.0;\n\t\t\t\t\t\toutput[i].shiftX=shiftX;\n\t\t\t\t\t\toutput[i].shiftY=shiftY;\n\t\t\t\t\t\tsignal.shiftX=shiftX;\n\t\t\t\t\t\tsignal.shiftY=shiftY;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tvar shiftX=signal.shiftX;\n\t\t\t\t\t\tvar shiftY=output[i].shiftX;\n\t\t\t\t\t\toutput[i].shiftY=shiftX;\n\t\t\t\t\t\tsignal.shiftY=shiftY;\n\t\t\t\t\t}\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\t/**\n\t * We try to determine the position of each signal within the spectrum matrix.\n\t * Peaks could be of 3 types: upper diagonal, diagonal or under diagonal 1,0,-1\n\t * respectively.\n\t * @param Signals\n\t * @return A matrix containing the properties of each signal\n\t */\n\tinitializeProperties: function(signals){\n\t\tvar signalsProperties = new Array(signals.length);\n\t\tfor(var i=signals.length-1;i>=0;i--){\n\t\t\tsignalsProperties[i]=[0,0];\n\t\t\t//We check if it is a diagonal peak\n\t\t\tif(Math.abs(signals[i].shiftX-signals[i].shiftY)<=this.diagonalError){\n\t\t\t\tsignalsProperties[i][1]=1;\n\t\t\t\t//We adjust the x and y value to be symmetric.\n\t\t\t\t//In general chemical shift in the direct dimension is better than in the other one,\n\t\t\t\t//so, we believe more to the shiftX than to the shiftY.\n\t\t\t\tvar shift = (signals[i].shiftX*2+signals[i].shiftY)/3.0;\n\t\t\t\tsignals[i].shiftX=shift;\n\t\t\t\tsignals[i].shiftY=shift;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(signals[i].shiftX-signals[i].shiftY>0)\n\t\t\t\t\tsignalsProperties[i][0]=1;\n\t\t\t\telse\n\t\t\t\t\tsignalsProperties[i][0]=-1;\n\t\t\t}\n\t\t}\n\t\treturn signalsProperties;\n\t},\n\t\n\t/**\n\t * This function calculates the distance between 2 nmr signals . If toImage is true, \n\t * it will interchange x by y in the distance calculation for the second signal.\n\t */\n\tdistanceTo: function(a, b, toImage){\n\t\tif(!toImage){\n\t\t\treturn Math.sqrt(Math.pow(a.shiftX-b.shiftX, 2)\n\t\t\t\t\t+Math.pow(a.shiftY-b.shiftY, 2));\n\t\t}\n\t\telse{\n\t\t\treturn Math.sqrt(Math.pow(a.shiftX-b.shiftY, 2)\n\t\t\t\t\t+Math.pow(a.shiftY-b.shiftX, 2));\n\t\t}\n\t}\n};\n\nmodule.exports = PeakOptimizer;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/PeakOptimizer.js\n ** module id = 23\n ** module chunks = 0\n **/","var SimpleClustering={\n\n\t/*This function returns the cluster list for a given connectivity matrix.\n\t*To improve the performance, the connectivity(square and symmetric) matrix \n\t*is given as a single vector containing  the upper diagonal of the matrix\n\t*Note: This algorithm is O(n*n) complexity. I wonder if there is something better. \n\t*acastillo\n\t*/\n\tfullClusterGenerator:function(conn){\n\t\tvar nRows = Math.sqrt(conn.length*2+0.25)-0.5;\n\t\t//console.log(\"nRows: \"+nRows+\" - \"+conn.length);\n\t\tvar clusterList = [];\n\t\tvar available = new Array(nRows);\n\t\tvar remaining = nRows, i=0;\n\t\tvar cluster = [];\n\t\t//Mark all the elements as available\n\t\tfor(i=nRows-1;i>=0;i--){\n\t\t\tavailable[i]=1;\n\t\t}\n\t\tvar nextAv=-1;\n\t\tvar toInclude = [];\n\t\twhile(remaining>0){\n\t\t\tif(toInclude.length===0){\n\t\t\t\t//If there is no more elements to include. Start a new cluster\n\t\t\t\tcluster = new Array(nRows);\n\t\t\t\tfor(i=nRows-1;i>=0;i--)\n\t\t\t\t\tcluster[i]=0;\n\t\t\t\tclusterList.push(cluster);\n\t\t    \tfor(nextAv = nRows-1;available[nextAv]==0;nextAv--){};\n\t\t    }\n\t\t    else{\n\t\t    \tnextAv=toInclude.splice(0,1);\n\t\t    }\n\t\t    //console.log(\"row: \"+nextAv);\n\t\t    cluster[nextAv]=1;\n\t\t    available[nextAv]=0;\n\t\t    remaining--;\n\t\t    //Copy the next available row\n\t\t    var row = new Array(nRows);\n\t\t\tfor(i=nRows-1;i>=0;i--){\n\t\t\t\tvar c=Math.max(nextAv,i);\n\t\t\t\tvar r=Math.min(nextAv,i);\n\t\t\t\t//The element in the conn matrix\n\t\t\t\t//console.log(\"index: \"+r*(2*nRows-r-1)/2+c)\n\t\t\t\trow[i]=conn[r*(2*nRows-r-1)/2+c];\n\t\t\t\t//console.log(\"col: \"+i+\":\"+row[i]);\n\t\t\t\t//There is new elements to include in this row?\n\t\t\t\t//Then, include it to the current cluster\n\t\t\t\tif(row[i]==1&&available[i]==1&&cluster[i]==0){\n\t\t\t\t\ttoInclude.push(i);\n\t\t\t\t\tcluster[i]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn clusterList;\n\t}\n}\n\nmodule.exports = SimpleClustering;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/SimpleClustering.js\n ** module id = 24\n ** module chunks = 0\n **/","/**\n * This library formats a set of nmr1D signals to the ACS format.\n * Created by acastillo on 3/11/15. p\n */\nvar ACS=ACS || {};\nACS.formater =(function() {\n    var acsString=\"\";\n    var parenthesis=\"\";\n    var spectro=\"\";\n    rangeForMultiplet=false;\n\n    function fromNMRSignal1D2ACS(spectrum, options){\n        acsString=\"\";\n        parenthesis=\"\";\n        spectro=\"\";\n        var solvent = null;\n        if(options&&options.solvent)\n            solvent = options.solvent;\n        //options.rangeForMultiplet=false;\n        if(options&&options.rangeForMultiplet!=undefined)\n            rangeForMultiplet = options.rangeForMultiplet;\n\n        //console.log(\"Range1: \"+options.rangeForMultiplet);\n\n        spectrum.type=\"NMR SPEC\";\n        if (spectrum[0][\"nucleus\"]==\"1H\") {\n            formatAcs_default(spectrum, false, 2, 1, solvent);\n        } else if (spectrum[0][\"nucleus\"]==\"13C\") {\n            formatAcs_default(spectrum, false, 1, 0, solvent);\n        }\n\n        if (acsString.length>0) acsString+=\".\";\n\n        return acsString;\n    }\n\n    /*function formatAcs_default_IR(spectra, ascending, decimalValue, smw) {\n     appendSeparator();\n     appendSpectroInformation(spectra);\n     if (spectra[\"peakLabels\"]) {\n     var numberPeakLabels=spectra[\"peakLabels\"].length;\n     var minIntensity= 9999999;\n     var maxIntensity=-9999999;\n     for (var i=0; i<numberPeakLabels; i++) {\n     if (spectra[\"peakLabels\"][i].intensity<minIntensity) minIntensity=spectra[\"peakLabels\"][i].intensity;\n     if (spectra[\"peakLabels\"][i].intensity>maxIntensity) maxIntensity=spectra[\"peakLabels\"][i].intensity;\n     }\n     for (var i=0; i<numberPeakLabels; i++) {\n     if (ascending) {\n     var peakLabel=spectra[\"peakLabels\"][i];\n     } else {\n     var peakLabel=spectra[\"peakLabels\"][numberPeakLabels-i-1];\n     }\n     if (peakLabel) {\n     appendSeparator();\n     appendValue(peakLabel,decimalValue);\n     if (smw) { // we need to add small / medium / strong\n     if (peakLabel.intensity<((maxIntensity-minIntensity)/3+minIntensity)) acsString+=\" (s)\";\n     else if (peakLabel.intensity>(maxIntensity-(maxIntensity-minIntensity)/3)) acsString+=\" (w)\";\n     else acsString+=\" (m)\";\n     }\n     }\n     }\n     }\n     }*/\n\n    function formatAcs_default(spectra, ascending, decimalValue, decimalJ, solvent) {\n        appendSeparator();\n        appendSpectroInformation(spectra, solvent);\n        var numberSmartPeakLabels=spectra.length;\n        //console.log(\"SP \"+spectra);\n        //console.log(\"# \"+numberSmartPeakLabels);\n        for (var i=0; i<numberSmartPeakLabels; i++) {\n            if (ascending) {\n                var signal=spectra[i];\n            } else {\n                var signal=spectra[numberSmartPeakLabels-i-1];\n            }\n            if (signal) {\n                //console.log(\"X2X\"+i+JSON.stringify(signal));\n                appendSeparator();\n                appendDelta(signal,decimalValue);\n                appendParenthesis(signal,decimalJ);\n                //console.log(\"S2S\"+i);\n            }\n        }\n    }\n\n    function appendSpectroInformation(spectrum, solvent) {\n        if (spectrum.type==\"NMR SPEC\") {\n            if (spectrum[0].nucleus) {\n                acsString+=formatNucleus(spectrum[0].nucleus);\n            }\n            acsString+=\" NMR\";\n            if ((solvent) || (spectrum[0].observe)) {\n                acsString+=\" (\";\n                if (spectrum[0].observe) {\n                    acsString+=(spectrum[0].observe*1).toFixed(0)+\" MHz\";\n                    if (solvent) acsString+=\", \";\n                }\n                if (solvent) {\n                    acsString+=formatMF(solvent);\n                }\n                acsString+=\")\";\n            }\n            acsString+=\" δ \";\n        } else if (spectrum.type==\"IR\") {\n            acsString+=\" IR \";\n        } else if (spectrum.type==\"MASS\") {\n            acsString+=\" MASS \";\n        }\n    }\n\n    function appendDelta(line, nbDecimal) {\n        //console.log(\"appendDelta1\");\n        var startX = 0,stopX=0,delta1=0;\n        if(line.startX){\n            if((typeof line.startX)==\"string\"){\n                startX=parseFloat(line.startX);\n            }\n            else\n                startX=line.startX;\n        }\n        if(line.stopX){\n            if((typeof line.stopX)==\"string\"){\n                stopX=parseFloat(line.stopX);\n            }\n            else\n                stopX=line.stopX;\n        }\n        if(line.delta1){\n            if((typeof line.delta1)==\"string\"){\n                delta1=parseFloat(line.delta1);\n            }\n            else\n                delta1=line.delta1;\n\n        }\n        //console.log(\"Range2: \"+rangeForMultiplet+\" \"+line.multiplicity);\n        if (line.asymmetric===true||(line.multiplicity==\"m\"&&rangeForMultiplet===true)) {//Is it massive??\n            if (line.startX&&line.stopX) {\n                if (startX<stopX) {\n                    acsString+=startX.toFixed(nbDecimal)+\"-\"+stopX.toFixed(nbDecimal);\n                } else {\n                    acsString+=stopX.toFixed(nbDecimal)+\"-\"+startX.toFixed(nbDecimal);\n                }\n            } else {\n                if(line.delta1)\n                    acsString+=delta1.toFixed(nbDecimal);\n            }\n        }\n        else{\n            if(line.delta1)\n                acsString+=delta1.toFixed(nbDecimal);\n            else{\n                if(line.startX&&line.stopX){\n                    acsString+=((startX+stopX)/2).toFixed(nbDecimal);\n                }\n            }\n        }\n    }\n\n    function appendValue(line, nbDecimal) {\n        if (line.xPosition) {\n            acsString+=line.xPosition.toFixed(nbDecimal);\n        }\n    }\n\n    function appendParenthesis(line, nbDecimal) {\n        //console.log(\"appendParenthesis1\");\n        // need to add assignment - coupling - integration\n        parenthesis=\"\";\n        appendMultiplicity(line);\n        appendIntegration(line);\n        appendCoupling(line,nbDecimal);\n        appendAssignment(line);\n\n\n        if (parenthesis.length>0) {\n            acsString+=\" (\"+parenthesis+\")\";\n        }\n        //console.log(\"appendParenthesis2\");\n    }\n\n    function appendIntegration(line) {\n        if (line.pubIntegration) {\n            appendParenthesisSeparator();\n            parenthesis+=line.pubIntegration;\n        } else if (line.integralData) {\n            appendParenthesisSeparator();\n            parenthesis+=line.integralData.value.toFixed(0)+\" H\";\n        }\n    }\n\n    function appendAssignment(line) {\n        if (line.pubAssignment) {\n            appendParenthesisSeparator();\n            parenthesis+=formatAssignment(line.pubAssignment);\n        }\n        else{\n            if (line.assignment) {\n                appendParenthesisSeparator();\n                parenthesis+=formatAssignment(line.assignment);\n            }\n        }\n    }\n\n    function appendMultiplicity(line) {\n        if (line.pubMultiplicity) {\n            appendParenthesisSeparator();\n            parenthesis+=line.pubMultiplicity;\n        } else if (line.multiplicity) {\n            appendParenthesisSeparator();\n            parenthesis+=line.multiplicity;\n        }\n    }\n\n    function appendCoupling(line, nbDecimal) {\n        if (line.nmrJs) {\n            var j=\"<i>J</i> = \";\n            for (var i=0; i<line.nmrJs.length; i++) {\n                var coupling=line.nmrJs[i].coupling;\n                if (j.length>11) j+=\", \";\n                j+=coupling.toFixed(nbDecimal);\n            }\n            appendParenthesisSeparator();\n            parenthesis+=j+\" Hz\";\n        }\n\n    }\n\n    function formatAssignment(assignment) {\n        assignment=assignment.replace(/([0-9])/g,\"<sub>$1</sub>\");\n        assignment=assignment.replace(/\\\"([^\\\"]*)\\\"/g,\"<i>$1</i>\");\n        return assignment;\n    }\n\n    function formatMF(mf) {\n        mf=mf.replace(/([0-9])/g,\"<sub>$1</sub>\");\n        return mf;\n    }\n\n    function formatNucleus(nucleus) {\n        nucleus=nucleus.replace(/([0-9])/g,\"<sup>$1</sup>\");\n        return nucleus;\n    }\n\n    function appendSeparator() {\n        if ((acsString.length>0) && (! acsString.match(/ $/))) {\n            acsString+=\", \";\n        }\n    }\n\n    function appendParenthesisSeparator() {\n        if ((parenthesis.length>0) && (! parenthesis.match(\", $\"))) parenthesis+=\", \";\n    }\n\n    function fromACS2NMRSignal1D(acsString){\n        return JSON.parse(SDAPI.AcsParserAsJSONString(acsString));\n    }\n\n    return {\n        toACS:fromNMRSignal1D2ACS,\n        toNMRSignal:fromACS2NMRSignal1D\n    }\n})();\n\nmodule.exports=ACS;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/AcsParser.js\n ** module id = 25\n ** module chunks = 0\n **/"],"sourceRoot":""}